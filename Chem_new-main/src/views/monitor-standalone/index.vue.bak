<template>
  <div class="main-container">
    <!-- 侧边栏控制按钮 - 无论何种模式都显示 -->
    <button
      class="sidebar-toggle"
      :class="{
        'toggle-framework-collapsed': !appSidebarOpened
      }"
      @click="isSidebarOpen = !isSidebarOpen"
    >
      {{ isSidebarOpen ? "◀" : "▶" }}
    </button>

    <!-- 工具栏 - 只保留创建硬件结构功能 -->
    <div class="toolbar">
      <!-- 创建反应路径按钮 -->
      <button 
        v-if="isAdmin"
        class="tool-button" 
        :class="{ 'active': isCreateMode }"
        @click="isCreateMode ? exitCreateMode() : enterCreateMode()"
      >
        {{ isCreateMode ? '退出创建模式' : '创建硬件结构' }}
      </button>
      
      <!-- 保存反应路径按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button save-button"
        @click="openSaveDialog"
      >
        保存硬件结构
      </button>
      
      <!-- 撤销操作按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button undo-button"
        @click="undoLastOperation"
        :disabled="operationHistory.length === 0"
        title="撤销上一步操作 (Ctrl+Z)"
      >
        撤销上一步 <span v-if="operationHistory.length > 0" class="operation-count">({{ operationHistory.length }})</span>
      </button>
    </div>

    <!-- 创建模式侧边栏 - 仅在创建模式下显示 -->
    <div
      v-if="isAdmin && isCreateMode"
      class="sidebar create-mode-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>创建硬件结构</h3>
      
      <!-- 设备图标拖拽区 -->
      <div class="icons-container">
        <h4>可用设备</h4>
        <div
          v-for="(icon, index) in nodeIcons"
          :key="index"
          class="icon-item"
          draggable="true"
          :data-type="icon.type"
          @dragstart="e => handleDragStart(e, icon)"
          @dragend="handleDragEnd"
        >
          <img :src="icon.src" class="icon-image" />
          <span>{{ icon.label }}</span>
        </div>
      </div>

      <!-- 连线模式按钮 - 仅在创建模式中显示 -->
      <div class="edge-mode-container">
        <button
          class="edge-mode-button"
          :class="{ active: isEdgeMode }"
          title="连线模式"
          @click="toggleEdgeMode"
        >
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path
              d="M3,3 L9,9 M15,15 L21,21"
              stroke="currentColor"
              stroke-width="2"
              fill="none"
            />
            <circle cx="8" cy="8" r="4" fill="currentColor" />
            <circle cx="16" cy="16" r="4" fill="currentColor" />
          </svg>
          <span>连线模式</span>
        </button>
      </div>
    </div>

    <!-- 选择反应路径侧边栏 - 在非创建模式下显示 -->
    <div
      v-if="!isCreateMode"
      class="sidebar path-selector-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>选择硬件结构</h3>
      
      <!-- 用户保存的硬件结构 -->
      <div v-if="savedPaths.length > 0" class="path-section">
        <h4>自定义结构</h4>
        <div class="path-options">
          <div 
            v-for="path in savedPaths" 
            :key="path.name"
            class="path-option custom-path"
            :class="{ 'selected': selectedPath && selectedPath.name === path.name }"
          >
            <span @click="loadStructureFromFile(path)">{{ path.name }}</span>
            <button 
              class="delete-path-btn" 
              title="删除此路径"
              @click.stop="openDeletePathDialog(path)"
            >×</button>
          </div>
        </div>
      </div>
      
      <!-- 图标说明区域 -->
      <div class="icons-legend-section">
        <h4>设备图标说明</h4>
        <div class="icons-legend">
          <div class="legend-item">
            <img :src="pump" class="legend-icon" />
            <span>泵 - 用于精确控制液体流动</span>
          </div>
          <div class="legend-item">
            <img :src="valve" class="legend-icon" />
            <span>阀门 - 控制流体通道的开关</span>
          </div>
          <div class="legend-item">
            <img :src="chip" class="legend-icon" />
            <span>加热芯片 - 控制反应温度</span>
          </div>
          <div class="legend-item">
            <img :src="bottle" class="legend-icon" />
            <span>瓶 - 存储反应物或产物</span>
          </div>
          <div class="legend-item">
            <img :src="mfc" class="legend-icon" />
            <span>MFC控制器 - 控制气体流量</span>
          </div>
          <div class="legend-item">
            <img :src="light" class="legend-icon" />
            <span>光照控制 - 提供光催化条件</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">加载中...</div>
    </div>
    
    <!-- 错误提示 -->
    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
      <button class="close-error-btn" @click="errorMessage = ''">×</button>
    </div>

    <!-- G6 画布容器 -->
    <div
      ref="container"
      class="graph-container"
      :class="{
        'graph-container-full': !isSidebarOpen,
        'graph-container-collapsed': !appSidebarOpened && isSidebarOpen,
        'drag-disabled': !isDragEnabled,
        'create-mode': isCreateMode
      }"
      @dragover.prevent="isCreateMode ? $event.preventDefault() : null"
      @drop="isCreateMode ? handleDrop($event) : null"
    />

    <!-- 设备控制面板 -->
    <div v-if="showControlPanel" class="device-control-panel">
      <div class="panel-content">
        <!-- 设备ID和状态 -->
        <div class="device-info">
          <div class="device-header">
            <div class="device-title">设备监控: {{ deviceData.id }}</div>
            <div class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
              {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
            </div>
          <button class="close-btn" @click="closeControlPanel">×</button>
          </div>
          <div class="device-status" :class="deviceData.status">
            状态: {{ translateStatus(deviceData.status) }}
          </div>
        </div>

        <!-- 泵控制 -->
        <div v-if="deviceData.type === 'pump'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前速度:</span>
              <span class="status-value">{{ deviceData.speed }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">当前位置:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">吸取端口:</span>
              <span class="status-value">{{ deviceData.aspiratePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">输送端口:</span>
              <span class="status-value">{{ deviceData.dispensePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
        </div>

        <!-- 阀门控制 -->
        <div v-if="deviceData.type === 'valve'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前孔位:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">产品收集阀:</span>
              <span class="status-value">{{ deviceData.isProductValve ? '是' : '否' }}</span>
            </div>
          </div>
        </div>

        <!-- 加热芯片控制 -->
        <div v-if="deviceData.type === 'chip'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前温度:</span>
              <span class="status-value">{{ deviceData.currentTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">目标温度:</span>
              <span class="status-value">{{ deviceData.targetTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">加热速度:</span>
              <span class="status-value">{{ deviceData.heatingSpeed }}</span>
            </div>
          </div>
        </div>

        <!-- MFC控制 -->
        <div v-if="deviceData.type === 'mfc'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
        </div>

        <!-- 光照控制 -->
        <div v-if="deviceData.type === 'light'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前光强:</span>
              <span class="status-value">{{ deviceData.intensity }}</span>
            </div>
          </div>
        </div>

        <!-- 瓶控制 -->
        <div v-if="deviceData.type === 'bottle'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">反应物:</span>
              <span class="status-value">{{ deviceData.reactant || '未设置' }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 保存路径名称对话框 -->
    <div v-if="isShowPathNameDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>保存硬件结构</h3>
        <div class="dialog-form">
          <label for="pathName">名称</label>
          <input 
            id="pathName"
            v-model="pathName"
            type="text"
            placeholder="请输入硬件结构名称"
            @keyup.enter="saveCurrentPath"
          />
        </div>
        <div class="dialog-buttons">
          <button @click="isShowPathNameDialog = false">取消</button>
          <button class="primary-button" @click="saveCurrentPath">保存</button>
        </div>
      </div>
    </div>

    <!-- 删除路径确认对话框 -->
    <div v-if="isShowDeletePathDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>删除硬件结构</h3>
        <div class="dialog-form">
          <p>确定要删除硬件结构 "{{ pathToDelete?.name }}" 吗？此操作不可恢复。</p>
          <p class="warning-text">此操作不可恢复！</p>
        </div>
        <div class="dialog-buttons">
          <button @click="isShowDeletePathDialog = false">取消</button>
          <button class="danger-button" @click="deleteReactionPath">删除</button>
        </div>
      </div>
    </div>

    <!-- WebSocket连接状态 -->
    <div class="ws-status" :class="{ 'connected': wsConnected }">
      <span v-if="wsConnected">已连接到服务器</span>
      <span v-else>未连接到服务器</span>
    </div>

    <!-- WebSocket连接状态指示器 -->
    <div class="websocket-status-container" :class="{ 'ws-connected': wsConnected, 'ws-disconnected': !wsConnected }">
      <div class="status-indicator"></div>
      <span class="status-text">{{ wsConnected ? 'WebSocket已连接' : 'WebSocket未连接' }}</span>
      <div v-if="!wsConnected" class="reconnect-controls">
        <el-tooltip effect="dark" placement="bottom">
          <template #content>
            <div>
              <p>可能的原因:</p>
              <ul>
                <li>后端服务未启动</li>
                <li>网络连接问题</li>
                <li>跨域策略限制</li>
              </ul>
              <p>排查步骤:</p>
              <ul>
                <li>确保后端服务在端口3000运行</li>
                <li>查看浏览器控制台错误信息</li>
                <li>检查浏览器网络请求</li>
              </ul>
            </div>
          </template>
          <el-button type="warning" size="small" icon="Warning">连接失败原因</el-button>
        </el-tooltip>
        <el-button type="primary" size="small" @click="reconnectWebSocket">重新连接</el-button>
      </div>
      <div v-if="wsConnected" class="connection-info">
        <span class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
          {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
        </span>
      </div>
    </div>

    <!-- 添加硬件连接控制面板 -->
    <div class="hardware-control-container">
      <el-card class="hardware-control-card">
        <template #header>
          <div class="hardware-card-header">
            <span>硬件设备连接</span>
            <el-tag :type="isHardwareConnected ? 'success' : 'danger'" size="small">
              {{ isHardwareConnected ? '已连接' : '未连接' }}
            </el-tag>
          </div>
        </template>
        <div class="hardware-card-content">
          <el-form :inline="true">
            <el-form-item label="硬件IP地址">
              <el-input v-model="hardwareIP" placeholder="例如：192.168.1.14" :disabled="isHardwareConnected"></el-input>
            </el-form-item>
            <el-form-item>
              <el-button 
                :type="isHardwareConnected ? 'danger' : 'primary'" 
                :loading="isHardwareConnecting" 
                @click="isHardwareConnected ? disconnectHardware() : connectHardware()">
                {{ isHardwareConnected ? '断开连接' : '连接硬件' }}
              </el-button>
            </el-form-item>
          </el-form>
          <div v-if="hardwareErrorMessage" class="hardware-error-message">
            <el-alert :title="hardwareErrorMessage" type="error" show-icon></el-alert>
          </div>
        </div>
      </el-card>
    </div>

    <!-- 设备选择对话框 -->
    <div v-if="showDeviceSelectionDialog" class="dialog-overlay">
      <div class="dialog-content device-selection-dialog">
        <h3>选择{{ getDeviceTypeName(dropPosition.type) }}</h3>
        
        <!-- 搜索框 -->
        <div class="search-box">
          <input 
            v-model="deviceSearchQuery" 
            type="text" 
            placeholder="搜索设备ID..."
            @input="filterDevices"
          />
        </div>
        
        <!-- 设备列表 -->
        <div class="device-list">
          <div v-if="filteredDevices.length === 0" class="no-devices">
            没有可用的{{ getDeviceTypeName(dropPosition.type) }}设备
          </div>
          
          <!-- 设备分组显示 -->
          <template v-for="(group, index) in deviceGroups" :key="index">
            <div class="device-group" v-if="group.devices.length > 0">
              <div class="group-title">{{ group.title }}</div>
              <div 
                v-for="device in group.devices" 
                :key="device.id"
                class="device-item"
                @click="selectDeviceAndAddToGraph(device)"
              >
                <div class="device-info">
                  <div class="device-id">{{ device.id }}</div>
                  <div class="device-module-id" v-if="device.moduleMetadata">
                    模块ID: {{ device.moduleMetadata.moduleId }}
                  </div>
                </div>
                <div class="device-status" :class="device.status">
                  {{ translateStatus(device.status) }}
                </div>
              </div>
            </div>
          </template>
        </div>
        
        <div class="dialog-buttons">
          <button @click="showDeviceSelectionDialog = false">取消</button>
        </div>
      </div>
    </div>

    <!-- 反应流程编辑器界面已移除，保留必要的隐藏对话框用于后台处理 -->
    <el-dialog
      v-model="isWorkflowMode"
      title="反应流程处理"
      width="0"
      :modal="false"
      :close-on-click-modal="false"
      :show-close="false"
      :append-to-body="true"
      destroy-on-close
    ></el-dialog>

    <!-- 反应路径选择面板 - 新增 -->
    <div v-if="isShowingReactionPath" class="reaction-path-panel">
      <div class="panel-header">
        <div class="panel-title">反应路径</div>
        <button class="close-btn" @click="isShowingReactionPath = false">×</button>
      </div>
      
      <!-- 加载状态 -->
      <div v-if="isLoadingReactionPaths" class="loading-paths">
        <div class="loading-spinner"></div>
        <div class="loading-text">加载反应路径数据中...</div>
      </div>
      
      <!-- 错误信息 -->
      <div v-else-if="reactionPathsError" class="path-error">
        <div class="error-icon">!</div>
        <div class="error-text">{{ reactionPathsError }}</div>
        <button class="retry-btn" @click="loadMappingData">重试</button>
      </div>
      
      <!-- 反应路径列表 -->
      <div v-else class="reaction-paths-list">
        <div v-for="(path, index) in reactionPaths" :key="index" class="reaction-path-item" 
          :class="{'active': selectedReactionPathIndex === index}"
          @click="selectReactionPath(index)">
          <div class="path-name">{{ path.name }}</div>
          <div class="path-info">{{ path.description }}</div>
        </div>
        
        <div v-if="reactionPaths.length === 0" class="no-paths">
          暂无可用反应路径
        </div>
      </div>
      
      <div v-if="selectedReactionPathIndex !== null" class="path-actions">
        <div class="path-action-instructions">
          <div class="instruction-step">
            <div class="step-icon">1</div>
            <div class="step-text">点击各设备节点设置参数</div>
          </div>
          <div class="instruction-step">
            <div class="step-icon">2</div>
            <div class="step-text">在参数变更队列面板点击"生成工作流并执行"</div>
          </div>
        </div>
        <button class="clear-path-btn" @click="clearReactionPathHighlight">清除高亮</button>
      </div>
    </div>
    
    <!-- 增强版标准参数配置对话框 -->
    <el-dialog
      v-model="showStandardParamsDialog"
      title="反应路径参数配置"
      width="800px"
      :destroy-on-close="false"
    >
      <div class="standard-workflow-params">
        <h3>请为 "{{ reactionPaths[selectedReactionPathIndex]?.name || '未选择' }}" 反应路径设置参数</h3>
        
        <el-form label-position="top">
          <!-- 基本反应参数设置 -->
          <el-divider content-position="left">基本反应参数</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="反应温度 (°C)">
                <el-input-number v-model="standardParams.reactionTemp" :min="0" :max="300" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应时间 (分钟)">
                <el-input-number v-model="standardParams.reactionTime" :min="1" :max="600" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应体积 (μL)">
                <el-input-number v-model="standardParams.reactionVolume" :min="10" :max="1000" />
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 泵设置 -->
          <el-divider content-position="left">泵设置</el-divider>
          <div v-for="(pump, index) in pathPumps" :key="`pump-${pump.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ pump.id }}</h4>
              <el-switch v-model="standardParams.enabledPumps[pump.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledPumps[pump.id]">
              <el-col :span="6">
                <el-form-item label="泵速度 (%)">
                  <el-input-number v-model="standardParams.pumpSpeeds[pump.id]" :min="1" :max="100" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="抽取体积 (μL)">
                  <el-input-number v-model="standardParams.pumpVolumes[pump.id]" :min="10" :max="1000" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="反应物进液端口">
                  <el-select v-model="standardParams.pumpPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`in-${port}`" :label="`端口 ${port}`" :value="port" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="产品出液端口">
                  <el-select v-model="standardParams.pumpOutPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`out-${port}`" :label="`端口 ${port}`" :value="port" />
                    <el-option key="waste" label="端口 6 (废液)" :value="6" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物">
                  <el-input v-model="standardParams.pumpReagents[pump.id]" placeholder="输入反应物名称" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物浓度">
                  <el-input v-model="standardParams.pumpConcentrations[pump.id]" placeholder="例如: 0.1 M" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 阀门设置 -->
          <el-divider content-position="left">阀门设置</el-divider>
          <div v-for="(valve, index) in pathValves" :key="`valve-${valve.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ valve.id }}</h4>
              <div>
                <el-checkbox v-model="standardParams.valvesToProduct[valve.id]">连接产品</el-checkbox>
                <el-checkbox v-model="standardParams.valvesToWaste[valve.id]">连接废液</el-checkbox>
              </div>
            </div>
            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="初始阀门位置">
                  <el-select v-model="standardParams.valvePositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="产品收集阀门位置" v-if="standardParams.valvesToProduct[valve.id]">
                  <el-select v-model="standardParams.valveProductPositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 加热器设置 -->
          <el-divider content-position="left">加热器设置</el-divider>
          <div v-for="(heater, index) in pathHeaters" :key="`heater-${heater.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ heater.id }}</h4>
              <el-switch v-model="standardParams.enabledHeaters[heater.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledHeaters[heater.id]">
              <el-col :span="12">
                <el-form-item label="反应温度 (°C)">
                  <el-input-number v-model="standardParams.heaterTemps[heater.id]" :min="25" :max="300" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="加热速率">
                  <el-input-number v-model="standardParams.heaterSpeeds[heater.id]" :min="1" :max="20" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 清洗设置 -->
          <el-divider content-position="left">清洗设置</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="清洗溶液体积 (μL)">
                <el-input-number v-model="standardParams.cleaningVolume" :min="50" :max="2000" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗次数">
                <el-input-number v-model="standardParams.cleaningCycles" :min="1" :max="5" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗端口">
                <el-select v-model="standardParams.cleaningPort">
                  <el-option v-for="port in 5" :key="`clean-${port}`" :label="`端口 ${port}`" :value="port" />
                </el-select>
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 步骤说明 -->
          <el-divider content-position="left">反应步骤预览</el-divider>
          <div class="workflow-steps-preview">
            <div class="step-preview-item">
              <div class="step-number">1</div>
              <div class="step-content">
                <div class="step-title">初始化反应路径</div>
                <div class="step-desc">启动所有阀门并设置为初始位置，启动加热芯片至目标温度</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">2</div>
              <div class="step-content">
                <div class="step-title">泵润洗</div>
                <div class="step-desc">将泵排空至废液口进行润洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">3</div>
              <div class="step-content">
                <div class="step-title">抽吸反应溶液</div>
                <div class="step-desc">泵从指定端口抽取反应溶液</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">4</div>
              <div class="step-content">
                <div class="step-title">反应运行</div>
                <div class="step-desc">启动泵输出反应溶液，保持稳定反应{{standardParams.reactionTime}}分钟</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">5</div>
              <div class="step-content">
                <div class="step-title">产品收集</div>
                <div class="step-desc">打开与产品收集相连的阀门</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">6</div>
              <div class="step-content">
                <div class="step-title">废液排出</div>
                <div class="step-desc">切换连接废液口的阀门，准备系统清洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">7</div>
              <div class="step-content">
                <div class="step-title">系统清洗</div>
                <div class="step-desc">泵抽取清洗溶液并冲洗管道系统，完成{{standardParams.cleaningCycles}}次循环</div>
              </div>
            </div>
          </div>
        </el-form>
      </div>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="showStandardParamsDialog = false">取消</el-button>
          <el-button type="primary" @click="confirmGenerateWorkflow">生成工作流</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, computed, watch, reactive } from "vue";
import { Graph } from "@antv/g6";
import { useAppStoreHook } from "@/store/modules/app";
import axios from "axios";
import { saveAs } from 'file-saver'; // 需要安装 file-saver 库用于保存文件
import { ElMessage,ElMessageBox } from 'element-plus';
import { useRoute, useRouter } from 'vue-router';
const router = useRouter();

// 引入图片文件
import pump from "@/assets/jpg/pump.jpg";
import valve from "@/assets/jpg/valve.jpg";
import chip from "@/assets/jpg/chip.jpg";
import mfc from "@/assets/svg/mfc.svg?url"; // 保留原有mfc图标
import light from "@/assets/svg/light.svg?url"; // 保留原有light图标
import bottle from "@/assets/jpg/bottle.jpg";


defineOptions({
  name:"MonitorStandalone"
})
const isAdmin = ref(true);
const isSidebarOpen = ref(true);
const isLoading = ref(false); // 添加加载状态
const errorMessage = ref(""); // 添加错误信息

// 获取应用侧边栏状态
const pureApp = useAppStoreHook();
const appSidebarOpened = computed(() => pureApp.getSidebarStatus);

const container = ref(null);
let graph = null;
let draggedIcon = null;

// 可拖拽图标列表
const nodeIcons = ref([
  { type: "pump", src: pump, label: "泵" },
  { type: "valve", src: valve, label: "阀" },
  { type: "chip", src: chip, label: "加热芯片" },
  { type: "mfc", src: mfc, label: "MFC控制器" },
  { type: "light", src: light, label: "光照控制" },
  { type: "bottle", src: bottle, label: "瓶" }
]);

const selectedDevice = ref(null);
const deviceData = ref({}); // 当前设备状态数据（由下位机更新）
const controlParams = ref({}); // 新增：控制参数数据（用于用户调整参数）

// 创建模式状态
const isCreateMode = ref(false);
const pathName = ref(''); // 用于存储新创建的硬件结构名称
const pathDescription = ref(''); // 用于存储硬件结构描述
const isShowPathNameDialog = ref(false); // 控制显示路径名称输入对话框

// 已有的硬件结构列表
const savedPaths = ref([]);

// 当前编辑的路径信息
const currentEditPath = ref(null);

// 删除路径相关变量
const isShowDeletePathDialog = ref(false);
const pathToDelete = ref(null);

const selectedPath = ref(null);
const selectedControllerIndex = ref(1); // 设置默认控制器索引为1

// 操作历史和撤销相关状态
const operationHistory = ref([]); // 操作历史记录
const maxHistoryLength = 20; // 最大历史记录长度

// 存储用户修改的参数
const pendingChanges = ref(new Map());
// 控制参数变更队列面板显示
const showPendingChangesPanel = ref(false);

// 流程执行器
const workflowExecutor = reactive({
  currentWorkflow: null,
  activeStepIndex: -1,
  status: 'idle', // idle, running, paused, completed, error
  startTime: null,
  endTime: null,
  stepResults: new Map(), // 存储每个步骤的执行结果
  waitingConditions: [], // 当前正在等待的条件

  updateWaitingCondition(index, progress, timeout = false) {
    if(this.waitingConditions[index]) {
      this.waitingConditions[index].progress = progress;
      this.waitingConditions[index].timeout = timeout;
    }
  },
  
  async executeWorkflow(workflow) {
    this.currentWorkflow = workflow;
    this.status = 'running';
    this.activeStepIndex = 0;
    this.startTime = Date.now();
    this.stepResults.clear();
    
    try {
      while(this.activeStepIndex < workflow.steps.length && (this.status === 'running' || this.status === 'paused')) {
        // 如果暂停，等待恢复
        if(this.status === 'paused') {
          await new Promise(resolve => {
            const checkInterval = setInterval(() => {
              if(this.status === 'running') {
                clearInterval(checkInterval);
                resolve();
              } else if(this.status === 'idle') {
                clearInterval(checkInterval);
                throw new Error('流程已终止');
              }
            }, 500);
          });
        }
        
        // 执行当前步骤
        const step = workflow.steps[this.activeStepIndex];
        
        console.log(`执行步骤 ${this.activeStepIndex + 1}: ${step.name}`);
        
        try {
          await this.executeStep(step);
          this.stepResults.set(step.id, { success: true });
        } catch(error) {
          console.error(`步骤 ${step.name} 执行失败:`, error);
          this.stepResults.set(step.id, { success: false, error: error.message });
          
          // 询问用户是否继续
          try {
            await ElMessageBox.confirm(
              `步骤 "${step.name}" 执行失败: ${error.message}\n是否继续执行后续步骤？`,
              '步骤执行失败',
              {
                confirmButtonText: '继续',
                cancelButtonText: '终止流程',
                type: 'warning',
              }
            );
            // 用户选择继续
          } catch (e) {
            // 用户选择终止
            throw new Error('用户终止了流程');
          }
        }
        
        this.activeStepIndex++;
        
        // 通知更新进度
        ElMessage.success(`已完成步骤 ${this.activeStepIndex}/${workflow.steps.length}: ${step.name}`);
      }
      
      if(this.status === 'running') {
        this.status = 'completed';
        this.endTime = Date.now();
        ElMessage.success(`流程 "${workflow.name}" 已成功完成！`);
      }
    } catch(error) {
      this.status = 'error';
      this.endTime = Date.now();
      console.error("流程执行错误:", error);
      ElMessage.error(`流程执行错误: ${error.message}`);
    }
  },
  
  async executeStep(step) {
    console.log(`开始执行步骤: ${step.name}`);
    
    // 检查步骤是否有前置条件
    if(step.conditions && step.conditions.length > 0) {
      console.log(`步骤 "${step.name}" 有 ${step.conditions.length} 个前置条件，开始检查...`);
      
      // 显示等待前置条件的UI提示
      this.waitingConditions = step.conditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index
      }));
      
      try {
        await this.checkConditions(step.conditions);
        console.log(`步骤 "${step.name}" 的前置条件已满足`);
        ElMessage.success(`前置条件已满足，开始执行步骤`);
      } catch (error) {
        console.error(`步骤 "${step.name}" 的前置条件检查失败:`, error);
        ElMessage.error(`前置条件未满足: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    }
    
    // 执行设备命令
    console.log(`开始发送 ${step.deviceCommands.length} 个设备命令...`);
    const commandPromises = step.deviceCommands.map(cmd => 
      this.sendDeviceCommand(cmd)
    );
    
    // 等待命令发送完成（注意：这只是发送完成，不是设备执行完成）
    try {
      const results = await Promise.all(commandPromises);
      console.log(`所有命令已成功发送，共 ${results.length} 个命令`);
    } catch (error) {
      console.error(`命令发送过程出错:`, error);
      ElMessage.error(`命令发送失败: ${error.message}`);
      throw error;
    }
    
    // 不论是否设置了waitForCompletion，都自动生成和检查完成条件
    // 这确保每个步骤都基于实际设备状态来确定完成条件
    
    // 自动从命令中生成完成条件
    const completionConditions = this.generateCompletionConditions(step.deviceCommands);
    
    if(completionConditions.length > 0) {
      // 显示等待信息
      ElMessage.info(`等待设备达到目标状态...共 ${completionConditions.length} 个条件需要检查`);
      
      // 设置UI等待状态
      this.waitingConditions = completionConditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index,
        deviceType: condition.deviceType,
        deviceId: condition.deviceId,
        parameter: condition.parameter || '状态',
        comparison: condition.comparison || 'eq',
        value: condition.value || condition.status
      }));
      
      try {
        // 检查所有完成条件
        await this.checkConditions(completionConditions);
        ElMessage.success(`设备已达到目标状态`);
      } catch (error) {
        console.error(`完成条件检查失败:`, error);
        ElMessage.error(`等待设备达到目标状态失败: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    } else {
      console.log(`步骤 "${step.name}" 没有生成任何完成条件，将继续执行`);
      
      // 如果没有自动生成完成条件但设置了waitForCompletion，则至少等待一个短暂时间
      if(step.waitForCompletion) {
        console.log(`步骤需要等待完成但没有具体条件，添加一个短暂等待时间（3秒）...`);
        await this.executeDelay(3);
      }
    }
    
    // 只有在明确设置了延迟时间的情况下才执行额外延迟
    if(step.delayAfter > 0) {
      console.log(`执行步骤后额外延迟 ${step.delayAfter} 秒...`);
      ElMessage.info(`步骤已完成，额外等待 ${step.delayAfter} 秒以确保系统稳定...`);
      await this.executeDelay(step.delayAfter);
    }
    
    console.log(`步骤 "${step.name}" 执行完成`);
  },
  
  async sendDeviceCommand(cmd) {
    console.log(`发送设备命令:`, cmd);
    
    // 构建适合WebSocket发送的命令格式
    const wsCommand = {
      id: cmd.deviceId,
      type: cmd.deviceType,
      action: cmd.action,
      parameters: cmd.parameters || {}
    };
    
    // 发送命令给WebSocket
    return new Promise((resolve, reject) => {
      // 设置超时
      const timeout = setTimeout(() => {
        reject(new Error(`命令执行超时: ${cmd.deviceType} ${cmd.deviceId} ${cmd.action}`));
      }, 30000); // 30秒超时
      
      // 创建一次性的消息监听器
      let messageHandler = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // 如果是命令结果响应或错误响应
          if (data.type === 'commandResult' && data.data) {
            // 检查是否是对应的命令响应
            const result = data.data;
            if (result.command && result.command.id === cmd.deviceId && result.command.action === cmd.action) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              if (result.success) {
                console.log(`命令执行成功:`, result);
                resolve(result);
              } else {
                console.error(`命令执行失败:`, result);
                reject(new Error(result.error || '命令执行失败'));
              }
            }
          }
        } catch (error) {
          console.error("解析WebSocket消息失败:", error);
        }
      };
      
      // 添加临时消息监听
      if (ws.value) {
        ws.value.addEventListener('message', messageHandler);
      }
      
      // 发送WebSocket消息
      const success = sendWsMessage({
        type: 'updateDeviceParameters',
        payload: [wsCommand]
      });
      
      if (!success) {
        clearTimeout(timeout);
        if (ws.value) {
          ws.value.removeEventListener('message', messageHandler);
        }
        reject(new Error('WebSocket消息发送失败'));
      }
    });
  },
  
  async checkConditions(conditions) {
    const conditionPromises = conditions.map(async condition => {
      switch(condition.type) {
        case 'deviceStatus':
          return this.checkDeviceStatusCondition(condition);
        
        case 'timeout':
          return this.checkTimeoutCondition(condition);
          
        case 'deviceParameter': // 新增：设备参数条件类型
          return this.checkDeviceParameterCondition(condition);
          
        case 'sensorValue':
          return this.checkSensorValueCondition(condition);
          
        default:
          throw new Error(`未知的条件类型: ${condition.type}`);
      }
    });
    // 等待所有条件满足
    await Promise.all(conditionPromises);
  },

  
  async checkDeviceStatusCondition(condition) {
    console.log(`检查设备状态条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待设备 ${condition.deviceId} 状态 ${condition.status} 超时`);
      }
      
      // 获取设备当前状态
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device && device.status === condition.status) {
        console.log(`条件满足: 设备 ${condition.deviceId} 状态为 ${condition.status}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  // 检查设备参数条件 - 优化版3.0
  async checkDeviceParameterCondition(condition, conditionIndex) {
    console.log(`检查设备参数条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000;
    
    // 获取目标参数的描述，用于日志和UI显示
    const paramName = condition.parameter;
    const paramDisplayName = this.getParameterDisplayName(condition.deviceType, paramName);
    const deviceTypeName = this.getDeviceTypeName(condition.deviceType);
    const comparisonText = this.getComparisonText(condition.comparison);
    const targetValue = condition.value;
    const tolerance = condition.tolerance || 
      (paramName === 'currentTemp' || paramName === 'temperature' ? 2 : // 温度2度容差
       paramName === 'position' ? 10 : // 位置10单位容差
       paramName === 'flowRate' ? 0.2 : // 流速0.2ml/min容差
       0.05 * targetValue); // 默认5%容差
    
    // 记录初始值，用于计算进度
    let initialValue = null;
    const device = globalDevices.value.get(condition.deviceId);
    if (device) {
      initialValue = device[condition.parameter];
      console.log(`设备${condition.deviceId}的${paramDisplayName}初始值: ${initialValue}, 目标值: ${targetValue}`);
    }
    
    // 动态调整稳定计数器 - 不同参数类型需要不同的稳定性要求
    const requiredStabilityCount = 
      (paramName === 'currentTemp' || paramName === 'temperature') ? 5 : // 温度需要更多稳定检查
      (paramName === 'position') ? 3 : // 位置需要中等稳定检查
      (paramName === 'flowRate') ? 4 : // 流速需要较多稳定检查
      2; // 其他参数2次稳定即可
    
    console.log(`设备${condition.deviceId}参数${paramDisplayName}需要连续${requiredStabilityCount}次稳定才算满足条件`);
    
    // 稳定计数器
    let stabilityCounter = 0;
    
    // 显示开始等待的提示
    ElMessage.info(`等待${deviceTypeName}(${condition.deviceId})的${paramDisplayName}${comparisonText}${targetValue}...`);
    
    // 记录最后一次值，用于检测停滞
    let lastValue = null;
    let stagnantCounter = 0;
    
    // 检测最大进展值，避免倒退
    let maxProgress = 0;
    
    while(this.status === 'running') {
      // 计算进度百分比 - 时间型进度
      const elapsedTime = Date.now() - startTime;
      const timeProgressPercent = Math.min(Math.round((elapsedTime / timeoutMs) * 100), 99);
      
      // 检查是否超时
      if(elapsedTime > timeoutMs) {
        // 更新UI显示为超时状态
        if (conditionIndex !== undefined) {
          this.updateWaitingCondition(conditionIndex, 100, true);
        }
        
        const errorMsg = `等待设备 ${condition.deviceId} 的${paramDisplayName}达到目标值(${targetValue})超时`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      
      // 获取设备当前参数值
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device) {
        const currentValue = device[condition.parameter];
        
        // 如果还没有初始值记录，现在记录
        if (initialValue === null) {
          initialValue = currentValue;
          console.log(`记录初始值: ${initialValue}`);
        }
        
        // 检查是否停滞（值没有变化）
        if (lastValue !== null && currentValue === lastValue) {
          stagnantCounter++;
          // 如果值超过10次检查没有变化（约5秒），输出警告
          if (stagnantCounter >= 10 && stagnantCounter % 10 === 0) {
            console.warn(`警告: 设备${condition.deviceId}的${paramDisplayName}已停滞在${currentValue}超过${stagnantCounter/2}秒`);
          }
        } else {
          stagnantCounter = 0;
          lastValue = currentValue;
        }
        
        let conditionMet = false;
        
        // 根据比较类型检查条件
        switch(condition.comparison) {
          case 'eq': // 等于
            // 带容差的相等判断
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
            
          case 'gt': // 大于
            conditionMet = currentValue > condition.value;
            break;
            
          case 'lt': // 小于
            conditionMet = currentValue < condition.value;
            break;
            
          case 'gte': // 大于等于
            conditionMet = currentValue >= condition.value;
            break;
            
          case 'lte': // 小于等于
            conditionMet = currentValue <= condition.value;
            break;
            
          case 'approx': // 近似值（主要用于浮点数）
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
        }
        
        // 根据条件是否满足调整稳定计数器
        if(conditionMet) {
          stabilityCounter++;
          
          // 计算基于接近目标值的进度 - 达到稳定次数的百分比
          const valueProgressPercent = Math.min(Math.round((stabilityCounter / requiredStabilityCount) * 100), 99);
          
          // 取两种进度的最大值，确保进度一直在前进
          let combinedProgress = Math.max(timeProgressPercent, valueProgressPercent);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态 - 显示更积极的进度
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
          
          // 如果已经连续多次满足条件，认为条件稳定满足
          if(stabilityCounter >= requiredStabilityCount) {
            // 条件满足时，设置进度为100%
            if (conditionIndex !== undefined) {
              this.updateWaitingCondition(conditionIndex, 100);
            }
            
            console.log(`条件已稳定满足: ${deviceTypeName}(${condition.deviceId})的${paramDisplayName}已${comparisonText}${targetValue}`);
            // 记录最终值和达成时间
            const reachedInSec = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`目标值: ${targetValue}, 当前值: ${currentValue}, 容差: ±${tolerance}, 耗时: ${reachedInSec}秒`);
            
            // 直接跳出循环，提前满足条件
            return true;
          }
          
          console.log(`接近条件满足(${stabilityCounter}/${requiredStabilityCount}): 当前值: ${currentValue}, 目标值: ${targetValue}, 容差: ±${tolerance}`);
        } else {
          // 如果条件不满足，重置稳定计数器
          stabilityCounter = 0;
          
          // 对于可测量的进度（如温度、位置变化），计算完成百分比
          let valueProgress = 0;
          
          if (initialValue !== null && initialValue !== currentValue) {
            // 根据不同参数类型计算进度
            if (paramName === 'temperature' || paramName === 'currentTemp') {
              // 温度变化进度
              const direction = targetValue > initialValue ? 1 : -1; // 是加热还是冷却
              if (direction > 0) { // 加热
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentValue - initialValue) / (targetValue - initialValue) * 100)
                ));
              } else { // 冷却
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((initialValue - currentValue) / (initialValue - targetValue) * 100)
                ));
              }
            } else if (paramName === 'position') {
              // 位置移动进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalDistance = Math.abs(targetValue - initialValue);
              const currentDistance = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentDistance / totalDistance) * 100)
              ));
            } else if (paramName === 'flowRate') {
              // 流速变化进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentChange / totalChange) * 100)
              ));
            } else {
              // 其他参数的通用进度计算
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              if (totalChange > 0) {
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentChange / totalChange) * 100)
                ));
              }
            }
          }
          
          // 取两种进度的最大值
          let combinedProgress = Math.max(timeProgressPercent, valueProgress);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
        }
        
        // 记录进度 - 但降低日志频率
        const progressTime = ((Date.now() - startTime) / 1000).toFixed(1);
        if (parseInt(progressTime) % 5 === 0) { // 每5秒记录一次
          console.log(`等待进度: ${maxProgress}%, 当前值: ${currentValue}, 目标值: ${targetValue}, 已等待${progressTime}秒`);
        }
      } else {
        console.warn(`找不到设备 ${condition.deviceId} 的数据，请检查设备是否连接`);
      }
      
      // 等待检查间隔 - 根据不同设备参数类型调整
      const checkInterval = 
        (paramName === 'currentTemp' || paramName === 'temperature') ? 1000 : // 温度1秒检查一次
        (paramName === 'position') ? 500 : // 位置0.5秒检查一次
        (paramName === 'flowRate') ? 750 : // 流速0.75秒检查一次
        300; // 其他参数0.3秒检查一次
      
      await new Promise(resolve => setTimeout(resolve, checkInterval));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  // 获取参数的友好显示名称
  getParameterDisplayName(deviceType, parameter) {
    const displayNames = {
      'position': '位置',
      'speed': '速度',
      'currentTemp': '温度',
      'temperature': '温度',
      'flowRate': '流速',
      'intensity': '光强',
      'port': '端口',
      'aspiratePort': '吸取端口',
      'dispensePort': '输送端口'
    };
    
    return displayNames[parameter] || parameter;
  },
  
  // 获取设备类型的友好名称
  getDeviceTypeName(deviceType) {
    const displayNames = {
      'pump': '泵',
      'valve': '阀门',
      'chip': '加热芯片',
      'mfc': '流量控制器',
      'light': '光照控制'
    };
    
    return displayNames[deviceType] || deviceType;
  },
  
  // 获取比较符号的文本表示
  getComparisonText(comparison) {
    const displayTexts = {
      'eq': '等于',
      'gt': '大于',
      'lt': '小于',
      'gte': '大于等于',
      'lte': '小于等于',
      'approx': '约等于'
    };
    
    return displayTexts[comparison] || comparison;
  },
  async checkTimeoutCondition(condition) {
    console.log(`执行等待条件: ${condition.duration}秒`);
    
    const durationMs = condition.duration * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个等待条件用于UI显示
    const waitingCondition = {
      type: 'timeout',
      description: `等待${condition.duration}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表以显示在UI上
    const conditionIndex = this.waitingConditions.length;
    this.waitingConditions.push(waitingCondition);
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      waitingCondition.progress = progressPercent;
      waitingCondition.description = `等待中: 剩余${remainingTime}秒`;
      this.waitingConditions[conditionIndex] = { ...waitingCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`等待进度: ${progressPercent}%, 已等待${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        waitingCondition.description = `等待已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[conditionIndex] = { ...waitingCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime.value += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成等待
    waitingCondition.progress = 100;
    waitingCondition.description = `等待完成: ${condition.duration}秒`;
    this.waitingConditions[conditionIndex] = { ...waitingCondition };
    
    console.log(`等待条件满足: 完成${condition.duration}秒等待`);
    return true;
  },
  
  // 执行时间延迟 - 增强版，支持暂停和终止
  async executeDelay(seconds) {
    console.log(`执行延迟: ${seconds}秒`);
    
    const durationMs = seconds * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个延迟条件用于UI显示
    const delayCondition = {
      type: 'delay',
      description: `系统稳定: ${seconds}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表
    this.waitingConditions = [delayCondition];
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      delayCondition.progress = progressPercent;
      delayCondition.description = `系统稳定中: 剩余${remainingTime}秒`;
      this.waitingConditions[0] = { ...delayCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`延迟进度: ${progressPercent}%, 已延迟${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        delayCondition.description = `延迟已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[0] = { ...delayCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成延迟
    delayCondition.progress = 100;
    delayCondition.description = `延迟完成: ${seconds}秒`;
    this.waitingConditions[0] = { ...delayCondition };
    
    // 清空等待条件列表
    setTimeout(() => {
      this.waitingConditions = [];
    }, 500);
    
    console.log(`延迟完成: ${seconds}秒`);
  },
  
  async checkSensorValueCondition(condition) {
    console.log(`检查传感器值条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待传感器 ${condition.sensorId} 条件满足超时`);
      }
      
      // TODO: 获取传感器实时数据，可以通过WebSocket或API实现
      // 这里使用模拟值
      const sensorValue = await getSensorValue(condition.sensorId);
      
      // 根据比较类型检查条件
      let conditionMet = false;
      switch(condition.comparison) {
        case 'gt':
          conditionMet = sensorValue > condition.value;
          break;
        case 'lt':
          conditionMet = sensorValue < condition.value;
          break;
        case 'eq':
          conditionMet = Math.abs(sensorValue - condition.value) < 0.001; // 浮点数比较
          break;
        case 'gte':
          conditionMet = sensorValue >= condition.value;
          break;
        case 'lte':
          conditionMet = sensorValue <= condition.value;
          break;
      }
      
      if(conditionMet) {
        console.log(`条件满足: 传感器 ${condition.sensorId} 值 ${sensorValue} ${condition.comparison} ${condition.value}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  pauseWorkflow() {
    if(this.status === 'running') {
      this.status = 'paused';
      console.log('流程已暂停');
    }
  },
  
  resumeWorkflow() {
    if(this.status === 'paused') {
      this.status = 'running';
      console.log('流程已恢复');
    }
  },
  
  stopWorkflow() {
    this.status = 'idle';
    console.log('流程已终止');
  },

  // 从设备命令自动生成完成条件 - 增强版2.0
  generateCompletionConditions(deviceCommands) {
    const conditions = [];
    
    // 对命令进行优先级排序 - 某些命令的执行需要优先检查
    const prioritizedCommands = [...deviceCommands].sort((a, b) => {
      // 加热器设置温度的命令具有较高优先级，因为温度变化通常最慢
      if (a.deviceType === 'chip' && a.action === 'setTemp') return -1;
      if (b.deviceType === 'chip' && b.action === 'setTemp') return 1;
      
      // 泵设置位置的命令其次
      if (a.deviceType === 'pump' && a.action === 'setPosition') return -1;
      if (b.deviceType === 'pump' && b.action === 'setPosition') return 1;
      
      return 0; // 其他命令维持原顺序
    });
    
    // 为每个命令生成完成条件
    prioritizedCommands.forEach(cmd => {
      // 首先检查命令是否需要生成完成条件
      if (cmd.generateCompletionCondition === false) {
        console.log(`命令 ${cmd.deviceId}-${cmd.action} 已禁用自动生成完成条件`);
        return; // 跳过此命令
      }
      
      // 设置默认超时时间，如果命令中指定了则使用指定值
      const defaultTimeout = cmd.completionTimeout || 60;
      
      // 获取当前设备数据以供参考
      const device = globalDevices.value.get(cmd.deviceId);
      
      // 根据不同设备类型和命令生成不同的完成条件
      switch(cmd.deviceType) {
        case 'pump':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              tolerance: 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'aspirate' && cmd.parameters?.volume !== undefined) {
            // 吸取液体操作 - 需要监控位置变化
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'gte',
              value: cmd.parameters.volume * 0.95, // 至少达到设定体积的95%
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'dispense' && cmd.parameters?.volume !== undefined) {
            // 排出液体操作 - 需要监控位置变化
            const device = globalDevices.value.get(cmd.deviceId);
            const currentPosition = device?.position || 0;
            const targetPosition = Math.max(0, currentPosition - cmd.parameters.volume);
            
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: targetPosition + 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'setSpeed') {
            // 设置速度 - 监控速度是否已设置
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'speed',
              comparison: 'eq',
              value: cmd.parameters.speed,
              tolerance: 1, // 允许1%的误差
              timeout: 5 // 速度设置应该很快
            });
          } else if(cmd.action === 'empty') {
            // 清空泵 - 监控位置是否接近零
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: 10, // 视为接近空
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'initialize') {
            // 初始化 - 监控状态变为idle
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 5 // 停止应该很快
            });
          }
          break;
          
        case 'chip':
          if(cmd.action === 'setTemp' && cmd.parameters?.temperature !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              parameter: 'currentTemp',
              comparison: 'approx', // 使用更精确的近似比较
              value: cmd.parameters.temperature,
              tolerance: 2, // 允许2度的误差
              timeout: Math.max(120, defaultTimeout) // 加热需要较长时间，至少120秒
            });
          } else if(cmd.action === 'powerOn') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'heating',
              timeout: 10
            });
          } else if(cmd.action === 'powerOff') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: 10
            });
          }
          break;
          
        case 'valve':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'open') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'open',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'close') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'closed',
              timeout: defaultTimeout
            });
          }
          break;
          
        case 'mfc':
          if(cmd.action === 'setFlowRate' && cmd.parameters?.flowRate !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              parameter: 'flowRate',
              comparison: 'approx',
              value: cmd.parameters.flowRate,
              tolerance: 0.2, // 允许0.2ml/min误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'start') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'running',
              timeout: 10
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 10
            });
          }
          break;
          
        case 'light':
          if(cmd.action === 'setIntensity' && cmd.parameters?.intensity !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              parameter: 'intensity',
              comparison: 'approx',
              value: cmd.parameters.intensity,
              tolerance: 1, // 允许1%的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'on') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'on',
              timeout: 5
            });
          } else if(cmd.action === 'off') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'off',
              timeout: 5
            });
          }
          break;
      }
    });
    
    // 记录生成的完成条件
    console.log(`为${deviceCommands.length}个命令生成了${conditions.length}个完成条件`);
    conditions.forEach((condition, index) => {
      console.log(`条件${index+1}:`, JSON.stringify(condition));
    });
    
    return conditions;
  }
});

// 添加操作到历史记录
const addToHistory = (operation) => {
  // 添加新操作到历史记录
  operationHistory.value.push(operation);
  
  // 如果历史记录超过最大长度，移除最早的记录
  if (operationHistory.value.length > maxHistoryLength) {
    operationHistory.value.shift();
  }
  
  console.log(`已添加操作到历史记录，当前历史长度: ${operationHistory.value.length}`);
};

// 进入硬件结构创建模式
const enterCreateMode = () => {
  isCreateMode.value = true;
  isSidebarOpen.value = true; // 确保侧边栏打开
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 重置拖拽和连线状态
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空操作历史
  operationHistory.value = [];
  
  // 初始化编辑状态 - 设置默认值
  currentEditPath.value = {
    name: '',
    type: 'custom',
    controllerIndex: 1
  };
  console.log("进入创建模式", isDragEnabled.value);
};

// 退出创建模式
const exitCreateMode = () => {
  isCreateMode.value = false;
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 如果有选中的自定义路径，重新加载
  if (selectedPath.value && typeof selectedPath.value === 'object') {
    // 自定义路径
    loadStructureFromFile(selectedPath.value);
  }
};

// 从文件加载硬件结构
const loadStructureFromFile = async (path) => {
  try {
    isLoading.value = true;
    console.log("尝试加载硬件结构:", path);
    
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 1. 首先尝试从新的API路径获取文件内容
    const pathId = path.id || path.name; // 使用ID优先，否则使用name
    console.log("正在从API加载路径ID:", pathId);
    
    try {
      const response = await axios.get(`${baseUrl}/api/devices/path/${encodeURIComponent(pathId)}`);
      
      if (response.data.code !== 0 || !response.data.data) {
        throw new Error("API返回错误或数据为空");
      }
      
      const pathConfig = response.data.data;
      console.log("从API加载的路径数据:", pathConfig);
      
      // 确保图表已初始化
      if (!graph) {
        console.error("图表实例未初始化，无法加载路径");
        errorMessage.value = "图表实例未初始化，请刷新页面重试";
        return;
      }
      
      // 重新初始化图表以解决潜在的渲染问题
      // 1. 获取容器尺寸
      const containerEl = container.value;
      if (!containerEl) {
        errorMessage.value = "找不到图表容器";
        return;
      }
      
      const graphWidth = containerEl.clientWidth || 800;
      const graphHeight = containerEl.clientHeight || 600;
      
      // 2. 销毁旧图表
      if (graph) {
        graph.destroy();
      }
      
      // 3. 创建新图表
      console.log(`重新初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
      graph = new Graph({
        container: containerEl,
        width: graphWidth,
        height: graphHeight,
        behaviors: [
          
          {
            type: 'zoom-canvas',
            sensitivity: 1.5,
            key: 'zoom-canvas',
            enable: true
          },
          {
            type: 'click-select',
            key: 'click-select',
            enable: true
          },
          {
            type: 'drag-element',
            key: 'drag-element',
            enable: true,
            shouldBegin: (e) => {
              return isCreateMode.value && isAdmin.value;
            }
          }
        ],
        node: {
          style: {
            fill: '#91d5ff',
            stroke: '#40a9ff',
            lineWidth: 1,
            radius: 6,
            cursor: 'move'
          }
        },
        edge: {
          style: {
            stroke: '#91d5ff',
            lineWidth: 2,
            endArrow: {
              fill: '#91d5ff',
              stroke: '#91d5ff'
            }
          }
        }
      });
      
      // 重新注册事件
      graph.on('node:click', handleDeviceClick);
      
      // 处理和添加节点
      const nodesData = [];
      if (pathConfig.data && pathConfig.data.nodes && Array.isArray(pathConfig.data.nodes)) {
        for (const node of pathConfig.data.nodes) {
          if (!node.id) continue;
          
          // 创建标准节点数据
          const processedNode = {
            id: node.id,
            type: "image",
            data: {
              deviceType: node.data?.deviceType || node.id.split('-')[0] || 'unknown',
              label: node.data?.label || "设备"
            },
            style: {
              x: node.style?.x || 100 + Math.random() * 300,
              y: node.style?.y || 100 + Math.random() * 200,
              size: node.style?.size || [40, 40],
              label: node.style?.label || `设备 (${node.id})`,
              labelCfg: {
                position: "bottom",
                offset: [0, 5],
                style: {
                  fill: "#333",
                  fontSize: 12
                }
              }
            }
          };
          
          // 设置图标
          const deviceType = processedNode.data.deviceType;
          switch (deviceType) {
            case "pump": 
              processedNode.style.src = pump; // 使用JPG图片
              processedNode.style.label = node.style?.label || `泵 (${node.id})`;
              // 针对JPG格式图片调整尺寸，确保正确显示
              processedNode.style.size = [40, 40];
              break;
            case "valve": 
              processedNode.style.src = valve; // 使用JPG图片
              processedNode.style.label = node.style?.label || `阀 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "chip": 
              processedNode.style.src = chip; // 使用JPG图片
              processedNode.style.label = node.style?.label || `加热芯片 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "mfc": 
              processedNode.style.src = mfc; 
              processedNode.style.label = node.style?.label || `MFC控制器 (${node.id})`;
              break;
            case "light": 
              processedNode.style.src = light; 
              processedNode.style.label = node.style?.label || `光照控制 (${node.id})`;
              break;
            case "bottle": 
              processedNode.style.src = bottle; // 使用JPG图片
              processedNode.style.label = node.style?.label || `瓶 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            default:
              // 如果没有匹配的图标，使用通用图标
              processedNode.style.src = bottle;
          }
          
          nodesData.push(processedNode);
        }
      }
      
      console.log("处理后的节点数据:", nodesData);
      
      // 添加节点到图表
      if (nodesData.length > 0) {
        graph.addNodeData(nodesData);
      } else {
        console.warn("没有有效的节点数据");
      }
      
      // 处理和添加边
      const edgesData = [];
      if (pathConfig.data && pathConfig.data.edges && Array.isArray(pathConfig.data.edges)) {
        for (const edge of pathConfig.data.edges) {
          if (!edge.source || !edge.target) continue;
          
          // 创建标准边数据
          const processedEdge = {
            id: edge.id || `edge-${Math.random().toString(36).substr(2, 9)}`,
            source: edge.source,
            target: edge.target,
            style: {
              stroke: '#91d5ff',
              lineWidth: 2,
              endArrow: {
                fill: '#91d5ff',
                stroke: '#91d5ff'
              }
            }
          };
          
          // 复制其他属性
          if (edge.style) {
            Object.assign(processedEdge.style, edge.style);
          }
          
          edgesData.push(processedEdge);
        }
      }
      
      console.log("处理后的边数据:", edgesData);
      
      // 添加边到图表
      if (edgesData.length > 0) {
        graph.addEdgeData(edgesData);
      }
      
      // 渲染图表
      try {
        console.log("开始渲染图表...");
        
        // 延迟渲染，等待DOM更新
        setTimeout(() => {
          graph.render();
          console.log("图表渲染完成");
          
          // 自动调整视图以适应所有元素
          if (nodesData.length > 0) {
            graph.fitView();
          }
          
          // 硬件图加载完成，初始化反应路径
          onGraphLoaded();
        }, 100);
      } catch (renderError) {
        console.error("图表渲染失败:", renderError);
        errorMessage.value = `图表渲染失败: ${renderError.message}`;
      }
      
      onHardwareStructureLoaded();
      // 更新当前选中的路径
      selectedPath.value = path;
      
      // 设置控制器索引
      if (pathConfig.controllerIndex !== undefined) {
        selectedControllerIndex.value = pathConfig.controllerIndex;
      }
    } catch (apiError) {
      console.error("从API加载路径失败:", apiError);
      errorMessage.value = `加载路径失败: ${apiError.message}`;
    }
  } catch (error) {
    console.error("加载硬件结构失败:", error);
    errorMessage.value = `加载硬件结构失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};


// 向图中添加设备节点
const addDeviceToGraph = (device, iconSrc, label, x, y) => {
  if (!graph) {
    console.error("添加设备失败：图表未初始化");
    return;
  }
  
  console.log("添加设备到图中:", device, "位置:", x, y, "图标:", iconSrc);
  
  try {
    // 检查节点是否已存在
    const existingNode = graph.getNodeData().find(node => node.id === device.id);
    if (existingNode) {
      console.log(`节点 ${device.id} 已存在于图中，不重复添加`);
      
      // 更新节点外观以反映状态
      updateNodeAppearance(device.id, device.status);
      return;
    }
    
    // 要添加的节点数据
    const nodeData = {
      id: device.id,
      type: "image",
      data: {
        label: label,
        deviceType: device.type,
        nodeType: device.type,
        deviceData: device,
        // 记录图片格式信息
        imgFormat: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? 'jpg' : 'svg'
      },
      style: {
        src: iconSrc,
        x: x,
        y: y,
        // 调整图片尺寸，确保JPG图片显示正确
        size: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? [40, 40] : [40, 40],
        label: device.moduleMetadata 
          ? `${label} (${device.moduleMetadata.moduleName} #${device.moduleMetadata.moduleId})` 
          : `${label} (${device.id})`,
        labelCfg: {
          position: "bottom",
          offset: [0, 5],
          style: {
            fill: "#333",
            fontSize: 12
          }
        },
        cursor: "move",
        // 节点外观
        fill: "rgba(255, 255, 255, 0.9)",
        stroke: "#1890ff",
        lineWidth: 1,
        radius: 6,
        shadowColor: "rgba(0,0,0,0.1)",
        shadowBlur: 5
      }
    };
    
    // 打印完整节点数据用于调试
    console.log("添加节点详细数据:", JSON.stringify(nodeData, null, 2));
    console.log("isDragEnabled", isDragEnabled.value);
    // 添加节点
    graph.addNodeData([nodeData]);
    
    // 确保拖拽行为正确
    updateDragBehavior();
    
    // 如果在创建模式下，记录此操作以支持撤销
    if (isCreateMode.value) {
      addToHistory({
        type: 'addNode',
        nodeId: device.id,
        nodeData: nodeData
      });
    }
    
    // 更新节点外观以反映状态
    updateNodeAppearance(device.id, device.status);
    
    // 确保渲染更新 - 这是关键步骤
    graph.render();
    
    console.log("节点添加成功，已渲染");
  } catch (error) {
    console.error("添加设备到图中失败:", error);
    errorMessage.value = `添加设备到图中失败: ${error.message}`;
  }
};

// 保存当前硬件结构
const saveCurrentPath = async () => {
  try {
    // 检查是否输入了名称
    if (!pathName.value.trim()) {
      errorMessage.value = "请输入硬件结构名称";
      return;
    }
    
    isLoading.value = true;
    
    // 获取当前图的数据
    const nodes = graph.getNodeData();
    const edges = graph.getEdgeData();
    
    console.log("正在保存硬件结构，节点数据:", nodes);
    console.log("正在保存硬件结构，边数据:", edges);
    
    // 修改nodes，保存完整的节点信息以便正确恢复
    const simplifiedNodes = nodes.map(node => {
      const deviceType = node.data?.deviceType || (node.id.split('-')[0]);
      
      // 需要保留的关键样式属性
      const style = {
        x: node.style?.x || 0,
        y: node.style?.y || 0,
        src: node.style?.src,
        size: node.style?.size,
        label: node.style?.label,
        labelCfg: node.style?.labelCfg,
        cursor: node.style?.cursor,
        fill: node.style?.fill,
        stroke: node.style?.stroke,
        lineWidth: node.style?.lineWidth,
        radius: node.style?.radius,
        shadowColor: node.style?.shadowColor,
        shadowBlur: node.style?.shadowBlur
      };
      
      return {
        id: node.id,
        type: node.type,
        data: {
          label: node.data?.label || "",
          deviceType: deviceType,
          nodeType: node.data?.nodeType || deviceType,
          deviceData: node.data?.deviceData
        },
        style: style
      };
    });
    
    // 处理图片路径问题，防止序列化错误
    const serializedNodes = fixImageSrcForSerialization(simplifiedNodes);
    
    console.log("处理后的节点数据:", serializedNodes);
    
    // 创建路径配置对象
    const pathConfig = {
      name: pathName.value,
      description: pathDescription.value || '',
      createdBy: 'user', // 可以从用户系统获取
      type: 'custom', // 使用自定义类型
      controllerIndex: selectedControllerIndex.value || 1,
      data: {
        nodes: serializedNodes,
        edges
      }
    };
    
    console.log("正在保存硬件结构，数据:", pathConfig);
    
    // 使用服务器的完整URL
    // 在开发环境中，需要指定后端服务器地址
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 调用API保存到服务器 - 使用新的API路径
    const response = await axios.post(`${baseUrl}/api/devices/path`, pathConfig);
    
    console.log("保存路径响应:", response);
    
    if (response.data.code === 0) {
      // 保存成功
      // 1. 更新当前编辑的路径
      const savedPath = response.data.data;
      currentEditPath.value = savedPath;
      selectedPath.value = savedPath;
      
      // 2. 更新路径列表
      let updatedPaths = [...savedPaths.value];
      const existingIndex = updatedPaths.findIndex(p => p.name === savedPath.name);
      
      if (existingIndex >= 0) {
        // 更新现有路径
        updatedPaths[existingIndex] = savedPath;
      } else {
        // 添加新路径
        updatedPaths.push(savedPath);
      }
      
      // 3. 保存到本地存储
      savedPaths.value = updatedPaths;
      localStorage.setItem('savedReactionPaths', JSON.stringify(updatedPaths));
      
      // 提示用户
      alert(`硬件结构 "${pathName.value}" 已保存成功!`);
      
      // 关闭对话框
      isShowPathNameDialog.value = false;
    } else {
      errorMessage.value = response.data.msg || "保存失败，请重试";
    }
  } catch (error) {
    console.error("保存硬件结构失败:", error);
    errorMessage.value = `保存失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};



// 拖拽开始
const handleDragStart = (e, icon) => {
  draggedIcon = icon;
  e.dataTransfer.setData('text/plain', JSON.stringify({ type: icon.type }));
  e.dataTransfer.effectAllowed = 'copy';
};

// 拖拽结束
const handleDragEnd = () => {
  draggedIcon = null;
};

// 处理节点点击，用于连线
const handleNodeClick = e => {
  if (!isEdgeMode.value) return;

  // 打印关键信息而非整个事件对象，避免循环引用问题
  console.log("点击节点事件:", {
    type: e.type,
    target: e.target ? { type: e.target.type } : null,
    item: e.item ? { id: e.item.id, type: e.item.type } : null,
    itemId: e.itemId
  });

  // G6 v5中，节点ID可能在不同位置
  let nodeId = null;

  // 尝试不同路径获取节点ID
  if (e.itemId) {
    nodeId = e.itemId;
  } else if (e.item && e.item.id) {
    nodeId = e.item.id;
  } else if (e.target && e.target.get && typeof e.target.get === "function") {
    try {
      nodeId = e.target.get("id");
    } catch (err) {
      console.log("获取target.id失败:", err);
    }
  } else if (
    e.currentTarget &&
    e.currentTarget.get &&
    typeof e.currentTarget.get === "function"
  ) {
    try {
      nodeId = e.currentTarget.get("id");
    } catch (err) {
      console.log("获取currentTarget.id失败:", err);
    }
  }

  console.log("获取到的节点ID:", nodeId);

  if (!nodeId) {
    console.error("无法获取节点ID");
    // 尝试直接从原始节点数据获取ID
    if (e.item && e.item.getModel) {
      try {
        const model = e.item.getModel();
        nodeId = model.id;
        console.log("从model获取到ID:", nodeId);
      } catch (err) {
        console.log("获取model失败:", err);
      }
    }

    if (!nodeId) return;
  }

  // 若还没选中源节点，则将当前点击节点设为源节点
  if (!sourceNode.value) {
    sourceNode.value = nodeId;
    // 高亮源节点 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          fill: "#1890ff",
          stroke: "#096dd9"
        }
      }
    ]);
  } else if (sourceNode.value !== nodeId) {
    // 已选中源节点，且当前点击了不同的节点，创建连线
    const edgeId = `edge-${Date.now()}`;

    // 边数据
    const edgeData = {
      id: edgeId,
      source: sourceNode.value,
      target: nodeId,
      data: {
        label: "", // 可选: 添加边标签
        weight: 1
      },
      style: {
        stroke: "#1890ff",
        lineWidth: 2,
        endArrow: true
      }
    };

    // 添加边 - 按照最新G6文档的方式
    graph.addEdgeData([edgeData]);
    
    // 记录添加边的操作
    if (isCreateMode.value) {
      addToHistory({
        type: 'addEdge',
        edgeId: edgeId,
        edgeData: edgeData
      });
    }

    // 取消源节点的高亮 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: sourceNode.value,
        style: {
          fill: "#91d5ff", // 恢复默认颜色
          stroke: "#40a9ff"
        }
      }
    ]);

    // 重置源节点
    sourceNode.value = null;

    // 渲染更新
    graph.render();
  }
};

// 从后端获取设备信息
const fetchDeviceInfo = async (deviceId) => {
  if (!deviceId) {
    console.warn("无效的设备ID");
    return null;
  }
  
  console.log("获取设备信息:", deviceId);
  
  try {
    // 尝试从缓存获取设备类型
    let deviceType = null;
    
    // 从设备ID推断类型
    if (deviceId.includes("pump")) {
      deviceType = "pump";
    } else if (deviceId.includes("valve")) {
      deviceType = "valve";
    } else if (deviceId.includes("chip")) {
      deviceType = "chip";
    } else if (deviceId.includes("mfc")) {
      deviceType = "mfc";
    } else if (deviceId.includes("light")) {
      deviceType = "light";
    }
    
    // 首先尝试通过WebSocket获取设备信息
    if (wsConnected.value) {
      console.log("尝试通过WebSocket获取设备信息");
      const deviceInfoPromise = new Promise((resolve, reject) => {
        // 设置超时
        const timeout = setTimeout(() => {
          console.warn("WebSocket获取设备信息超时");
          resolve(null); // 超时时返回null
        }, 3000);
        
        // 创建一次性的消息监听器
        let messageHandler = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("收到WebSocket消息:", data);
            
            // 如果是设备信息响应或错误响应
            if (data.type === 'deviceInfo' && data.data && data.data.id === deviceId) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              console.log("成功获取到设备信息:", data.data);
              resolve(data.data);
            } else if (data.type === 'error' && data.data && data.data.message && data.data.message.includes(deviceId)) {
              console.warn("WebSocket返回错误:", data.data);
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              // 如果是"设备不存在"错误，尝试注册设备
              if (data.data.message.includes("不存在") && deviceType) {
                console.log(`设备 ${deviceId} 不存在`);
                // 返回默认数据
                resolve(null);
              } else {
                // 其他错误则返回null
                resolve(null);
              }
            }
          } catch (error) {
            console.error("解析WebSocket消息失败:", error);
            ws.value.removeEventListener('message', messageHandler);
            clearTimeout(timeout);
            resolve(null);
          }
        };
        
        // 添加临时消息监听
        if (ws.value) {
          ws.value.addEventListener('message', messageHandler);
        }
        
        // 发送WebSocket消息获取设备信息
        const success = sendWsMessage({
          type: 'getDeviceInfo', // 使用正确的消息类型
          payload: { id: deviceId }
        });
        
        if (!success) {
          console.warn("WebSocket消息发送失败");
          clearTimeout(timeout);
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
          resolve(null);
        }
        
        // 在超时后移除监听器
        setTimeout(() => {
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
        }, 3000);
      });
      
      const deviceInfo = await deviceInfoPromise;
      if (deviceInfo) {
        return deviceInfo;
      }
    }
    // 如果失败，使用默认值
    console.log(`无法从后端获取设备 ${deviceId} 的信息，使用默认值`);
    
    // 如果无法确定设备类型，返回null
    console.warn("无法确定设备类型，无法创建默认信息");
    return null;
  } catch (error) {
    console.error("获取设备信息失败:", error);
    return null;
  }
};

// 处理设备点击事件
const handleDeviceClick = async (e) => {
  try {
    // 连线模式下使用原来的点击逻辑
    if (isEdgeMode.value) {
      handleNodeClick(e);
      return;
    }

    // 获取节点ID
    let nodeId = null;
    if (e.itemId) {
      nodeId = e.itemId;
    } else if (e.item && e.item.id) {
      nodeId = e.item.id;
    } else if (e.target && e.target.get && typeof e.target.get === "function") {
      try {
        nodeId = e.target.get("id");
      } catch (err) {
        console.log("获取target.id失败:", err);
      }
    }

    if (!nodeId) {
      console.warn("无法获取节点ID，取消处理设备点击");
      return;
    }

    // 使用新的selectDevice函数处理设备选择
    selectDevice(nodeId);
  } catch (error) {
    console.error("处理设备点击失败:", error);
    errorMessage.value = `处理设备点击失败: ${error.message}`;
  }
};

// 更新节点外观以反映设备状态
const updateNodeAppearance = (nodeId, status) => {
  console.log('!!!!!!!!!!!!更新节点外观:', nodeId, status);
  if (!graph) return;
  
  try {
    let strokeColor = "#1890ff"; // 默认边框颜色
    let shadowColor = "rgba(0,0,0,0.1)"; // 默认阴影颜色
    
    // 根据状态设置样式
    switch (status) {
      case "running":
    case "open":
      case "heating":
        strokeColor = "#67c23a"; // 绿色
        shadowColor = "rgba(103, 194, 58, 0.3)";
      break;
      case "stopped":
      case "closed":
      case "idle":
        strokeColor = "#909399"; // 灰色
        shadowColor = "rgba(144, 147, 153, 0.3)";
      break;
      case "error":
        strokeColor = "#f56c6c"; // 红色
        shadowColor = "rgba(245, 108, 108, 0.3)";
        break;
      case "cooling":
        strokeColor = "#1890ff"; // 蓝色
        shadowColor = "rgba(24, 144, 255, 0.3)";
      break;
    }
    
    // 更新节点样式
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          stroke: strokeColor,
          shadowColor: shadowColor,
          shadowBlur: 10
        }
      }
    ]);
    graph.render();
  } catch (error) {
    console.error("更新节点外观失败:", error);
  }
};

// 控制面板显示状态
const showControlPanel = ref(false);

// 关闭控制面板
const closeControlPanel = () => {
  showControlPanel.value = false;
  selectedDevice.value = null;
  // 重置控制参数对象
  controlParams.value = {};
};

// 控制拖拽功能启用/禁用
const updateDragBehavior = () => {
  if (!graph) return;

  // 使用计算属性来决定是否启用拖拽
  const enableDrag = isDragEnabled.value;

  try {
    // 更新拖拽节点行为
    graph.updateBehavior({
      key: "drag-node",
      enable: enableDrag
    });

    // 更新节点选择行为
    graph.updateBehavior({
      key: "click-select",
      enable: enableDrag
    });
    
    // 更新鼠标样式提示
    if (container.value) {
      container.value.style.cursor = enableDrag ? "default" : "not-allowed";
    }
    
    console.log(`拖拽行为已${enableDrag ? '启用' : '禁用'}, 创建模式: ${isCreateMode.value}`);
  } catch (err) {
    console.error("更新拖拽行为失败:", err);
  }
};

// 监听拖拽启用状态变化
watch(isDragEnabled, () => {
  updateDragBehavior();
});

// 切换连线模式
const toggleEdgeMode = () => {
  isEdgeMode.value = !isEdgeMode.value;

  if (!isEdgeMode.value) {
    // 退出连线模式时，如果有高亮的节点，取消高亮
    if (sourceNode.value) {
      // 使用G6 v5中的正确方法恢复节点样式
      graph.updateNodeData([
        {
          id: sourceNode.value,
          style: {
            fill: "#91d5ff", // 恢复默认颜色
            stroke: "#40a9ff"
          }
        }
      ]);
    }
    // 清空选中的源节点
    sourceNode.value = null;
  }

  // 更新鼠标样式和拖拽行为
  if (graph) {
    if (isEdgeMode.value) {
      // 进入连线模式，修改画布样式
      container.value.style.cursor = "crosshair";

      // 禁用拖拽节点行为
      graph.updateBehavior({
        key: "drag-node",
        enable: false
      });
    } else {
      // 退出连线模式时，调用updateDragBehavior
      // 这将根据侧边栏状态和管理员状态决定是否启用拖拽
      updateDragBehavior();
    }
  }
};

// 定时刷新设备数据
let refreshInterval = null;

// 启动定时刷新
const startDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
  }
  
  refreshInterval = setInterval(async () => {
    // 如果当前有选中的设备，刷新其数据
    if (selectedDevice.value && showControlPanel.value) {
      try {
        const updatedDevice = await fetchDeviceInfo(selectedDevice.value);
        if (updatedDevice) {
          // 只更新设备状态数据，不影响控制参数
          deviceData.value = updatedDevice;
          // 同时更新节点外观
          updateNodeAppearance(selectedDevice.value, updatedDevice.status);
        }
      } catch (error) {
        console.error("刷新设备数据失败:", error);
      }
    }
  }, 3000); // 每3秒刷新一次
};

// 停止定时刷新
const stopDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
};


// WebSocket连接状态
const wsConnected = ref(false);
const ws = ref(null);

// 调整图形大小的函数
const resizeGraph = () => {
  if (!graph || !container.value) return;
  
  const width = container.value.clientWidth;
  const height = container.value.clientHeight || 600;
  
  graph.setSize([width, height]);
  graph.render();
  console.log(`调整图形大小至 ${width}x${height}`);
};

// 修改WebSocket连接成功后的处理
const handleWsOpen = () => {
  console.log('WebSocket连接已建立');
  wsConnected.value = true;
  
  // 发送验证信息
  if (localStorage.token) {
    const authMessage = {
      type: 'authenticate',
      token: localStorage.token
    };
    sendWsMessage(authMessage);
  }
  
  // 连接成功后自动获取硬件状态
  setTimeout(() => {
    sendWsMessage({
      type: 'getHardwareStatus'
    });
    
    // 同时获取所有设备列表
    sendWsMessage({
      type: 'getDevices'
    });
  }, 500);
};

// 连接WebSocket服务器
const connectWebSocket = async () => {
  try {
    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
      console.log('WebSocket已连接');
      return;
    }
    
    // 关闭之前的连接
    if (ws.value) {
      manualClose.value = true;
      ws.value.close();
    }
    
    manualClose.value = false;
    
    console.log("尝试连接WebSocket服务器...");
    // 确定WebSocket连接地址
    const baseUrl = process.env.NODE_ENV === 'development'
      ? 'ws://localhost:3000'
      : window.location.origin.replace(/^http/, 'ws');
    const wsUrl = `${baseUrl}/api/devices/realtime`;
    
    ws.value = new WebSocket(wsUrl);
    
    ws.value.onopen = handleWsOpen;
    
    ws.value.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('收到WebSocket消息:', data);
        handleWsMessage(data);
      } catch (error) {
        console.error('WebSocket消息解析错误:', error);
      }
    };
    
    ws.value.onclose = (event) => {
      console.log('WebSocket连接已关闭', event.code, event.reason);
      wsConnected.value = false;

      // 如果不是用户主动关闭，则尝试重连
      if (!manualClose.value) {
        console.log("尝试重新连接...");
        setTimeout(connectWebSocket, 5000);
      }
    };

    ws.value.onerror = (error) => {
      console.error('WebSocket错误:', error);
      wsConnected.value = false;
      errorMessage.value = '无法连接到WebSocket服务器';
    };
  } catch (error) {
    console.error('创建WebSocket实例失败:', error);
    wsConnected.value = false;
    errorMessage.value = `创建WebSocket连接失败: ${error.message}`;
  }
};


// 更新设备状态
const updateDeviceStatus = (deviceData) => {
  // 首先更新全局设备仓库
  if (deviceData.id) {
    // 如果设备已存在，合并数据；否则添加新设备
    if (globalDevices.value.has(deviceData.id)) {
      const existingDevice = globalDevices.value.get(deviceData.id);
      
      // 检查是否有该设备的待发送更改
      const deviceKey = `${deviceData.type}_${deviceData.id}`;
      const hasPendingChanges = pendingChanges.value.has(deviceKey);
      
      // 合并设备数据，但保留待发送的本地修改
      const updatedDevice = {...existingDevice, ...deviceData};
      
      // 如果有待发送更改，保留用户编辑的值
      if (hasPendingChanges) {
        const pendingParams = pendingChanges.value.get(deviceKey).params;
        Object.keys(pendingParams).forEach(key => {
          updatedDevice[key] = pendingParams[key];
        });
      }
      
      globalDevices.value.set(deviceData.id, updatedDevice);
    } else {
      globalDevices.value.set(deviceData.id, deviceData);
    }
    
    // 更新图上的设备节点状态
    if (graph) {
      const node = graph.findById(deviceData.id);
      if (node) {
        // 更新节点状态
        graph.updateItem(node, {
          status: deviceData.status,
          ...deviceData
        });
      }
    }
    
    // 如果是当前选中的设备，从全局仓库获取最新数据更新控制面板
    if (selectedDevice.value === deviceData.id) {
      const updatedDeviceData = globalDevices.value.get(deviceData.id);
      // 深拷贝确保控制面板数据独立
      deviceData.value = JSON.parse(JSON.stringify(updatedDeviceData));
    }
  }
};

<template>
  <div class="main-container">
    <!-- 侧边栏控制按钮 - 无论何种模式都显示 -->
    <button
      class="sidebar-toggle"
      :class="{
        'toggle-framework-collapsed': !appSidebarOpened
      }"
      @click="isSidebarOpen = !isSidebarOpen"
    >
      {{ isSidebarOpen ? "◀" : "▶" }}
    </button>

    <!-- 工具栏 - 只保留创建硬件结构功能 -->
    <div class="toolbar">
      <!-- 创建反应路径按钮 -->
      <button 
        v-if="isAdmin"
        class="tool-button" 
        :class="{ 'active': isCreateMode }"
        @click="isCreateMode ? exitCreateMode() : enterCreateMode()"
      >
        {{ isCreateMode ? '退出创建模式' : '创建硬件结构' }}
      </button>
      
      <!-- 保存反应路径按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button save-button"
        @click="openSaveDialog"
      >
        保存硬件结构
      </button>
      
      <!-- 撤销操作按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button undo-button"
        @click="undoLastOperation"
        :disabled="operationHistory.length === 0"
        title="撤销上一步操作 (Ctrl+Z)"
      >
        撤销上一步 <span v-if="operationHistory.length > 0" class="operation-count">({{ operationHistory.length }})</span>
      </button>
    </div>

    <!-- 创建模式侧边栏 - 仅在创建模式下显示 -->
    <div
      v-if="isAdmin && isCreateMode"
      class="sidebar create-mode-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>创建硬件结构</h3>
      
      <!-- 设备图标拖拽区 -->
      <div class="icons-container">
        <h4>可用设备</h4>
        <div
          v-for="(icon, index) in nodeIcons"
          :key="index"
          class="icon-item"
          draggable="true"
          :data-type="icon.type"
          @dragstart="e => handleDragStart(e, icon)"
          @dragend="handleDragEnd"
        >
          <img :src="icon.src" class="icon-image" />
          <span>{{ icon.label }}</span>
        </div>
      </div>

      <!-- 连线模式按钮 - 仅在创建模式中显示 -->
      <div class="edge-mode-container">
        <button
          class="edge-mode-button"
          :class="{ active: isEdgeMode }"
          title="连线模式"
          @click="toggleEdgeMode"
        >
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path
              d="M3,3 L9,9 M15,15 L21,21"
              stroke="currentColor"
              stroke-width="2"
              fill="none"
            />
            <circle cx="8" cy="8" r="4" fill="currentColor" />
            <circle cx="16" cy="16" r="4" fill="currentColor" />
          </svg>
          <span>连线模式</span>
        </button>
      </div>
    </div>

    <!-- 选择反应路径侧边栏 - 在非创建模式下显示 -->
    <div
      v-if="!isCreateMode"
      class="sidebar path-selector-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>选择硬件结构</h3>
      
      <!-- 用户保存的硬件结构 -->
      <div v-if="savedPaths.length > 0" class="path-section">
        <h4>自定义结构</h4>
        <div class="path-options">
          <div 
            v-for="path in savedPaths" 
            :key="path.name"
            class="path-option custom-path"
            :class="{ 'selected': selectedPath && selectedPath.name === path.name }"
          >
            <span @click="loadStructureFromFile(path)">{{ path.name }}</span>
            <button 
              class="delete-path-btn" 
              title="删除此路径"
              @click.stop="openDeletePathDialog(path)"
            >×</button>
          </div>
        </div>
      </div>
      
      <!-- 图标说明区域 -->
      <div class="icons-legend-section">
        <h4>设备图标说明</h4>
        <div class="icons-legend">
          <div class="legend-item">
            <img :src="pump" class="legend-icon" />
            <span>泵 - 用于精确控制液体流动</span>
          </div>
          <div class="legend-item">
            <img :src="valve" class="legend-icon" />
            <span>阀门 - 控制流体通道的开关</span>
          </div>
          <div class="legend-item">
            <img :src="chip" class="legend-icon" />
            <span>加热芯片 - 控制反应温度</span>
          </div>
          <div class="legend-item">
            <img :src="bottle" class="legend-icon" />
            <span>瓶 - 存储反应物或产物</span>
          </div>
          <div class="legend-item">
            <img :src="mfc" class="legend-icon" />
            <span>MFC控制器 - 控制气体流量</span>
          </div>
          <div class="legend-item">
            <img :src="light" class="legend-icon" />
            <span>光照控制 - 提供光催化条件</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">加载中...</div>
    </div>
    
    <!-- 错误提示 -->
    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
      <button class="close-error-btn" @click="errorMessage = ''">×</button>
    </div>

    <!-- G6 画布容器 -->
    <div
      ref="container"
      class="graph-container"
      :class="{
        'graph-container-full': !isSidebarOpen,
        'graph-container-collapsed': !appSidebarOpened && isSidebarOpen,
        'drag-disabled': !isDragEnabled,
        'create-mode': isCreateMode
      }"
      @dragover.prevent="isCreateMode ? $event.preventDefault() : null"
      @drop="isCreateMode ? handleDrop($event) : null"
    />

    <!-- 设备控制面板 -->
    <div v-if="showControlPanel" class="device-control-panel">
      <div class="panel-content">
        <!-- 设备ID和状态 -->
        <div class="device-info">
          <div class="device-header">
            <div class="device-title">设备控制: {{ deviceData.id }}</div>
            <div class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
              {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
            </div>
          <button class="close-btn" @click="closeControlPanel">×</button>
          </div>
          <div class="device-status" :class="deviceData.status">
            状态: {{ translateStatus(deviceData.status) }}
          </div>
        </div>

        <!-- 泵控制 -->
        <div v-if="deviceData.type === 'pump'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前速度:</span>
              <span class="status-value">{{ deviceData.speed }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">当前位置:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">吸取端口:</span>
              <span class="status-value">{{ deviceData.aspiratePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">输送端口:</span>
              <span class="status-value">{{ deviceData.dispensePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
        </div>

        <!-- 阀门控制 -->
        <div v-if="deviceData.type === 'valve'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前孔位:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">产品收集阀:</span>
              <span class="status-value">{{ deviceData.isProductValve ? '是' : '否' }}</span>
            </div>
          </div>
        </div>

        <!-- 加热芯片控制 -->
        <div v-if="deviceData.type === 'chip'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前温度:</span>
              <span class="status-value">{{ deviceData.currentTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">目标温度:</span>
              <span class="status-value">{{ deviceData.targetTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">加热速度:</span>
              <span class="status-value">{{ deviceData.heatingSpeed }}</span>
            </div>
          </div>
        </div>

        <!-- MFC控制 -->
        <div v-if="deviceData.type === 'mfc'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
        </div>

        <!-- 光照控制 -->
        <div v-if="deviceData.type === 'light'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前光强:</span>
              <span class="status-value">{{ deviceData.intensity }}</span>
            </div>
          </div>
        </div>

        <!-- 瓶控制 -->
        <div v-if="deviceData.type === 'bottle'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">反应物:</span>
              <span class="status-value">{{ deviceData.reactant || '未设置' }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 保存路径名称对话框 -->
    <div v-if="isShowPathNameDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>保存硬件结构</h3>
        <div class="dialog-form">
          <label for="pathName">名称</label>
          <input 
            id="pathName"
            v-model="pathName"
            type="text"
            placeholder="请输入硬件结构名称"
            @keyup.enter="saveCurrentPath"
          />
        </div>
        <div class="dialog-buttons">
          <button @click="isShowPathNameDialog = false">取消</button>
          <button class="primary-button" @click="saveCurrentPath">保存</button>
        </div>
      </div>
    </div>

    <!-- 删除路径确认对话框 -->
    <div v-if="isShowDeletePathDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>删除硬件结构</h3>
        <div class="dialog-form">
          <p>确定要删除硬件结构 "{{ pathToDelete?.name }}" 吗？此操作不可恢复。</p>
          <p class="warning-text">此操作不可恢复！</p>
        </div>
        <div class="dialog-buttons">
          <button @click="isShowDeletePathDialog = false">取消</button>
          <button class="danger-button" @click="deleteReactionPath">删除</button>
        </div>
      </div>
    </div>

    <!-- WebSocket连接状态 -->
    <div class="ws-status" :class="{ 'connected': wsConnected }">
      <span v-if="wsConnected">已连接到服务器</span>
      <span v-else>未连接到服务器</span>
    </div>

    <!-- WebSocket连接状态指示器 -->
    <div class="websocket-status-container" :class="{ 'ws-connected': wsConnected, 'ws-disconnected': !wsConnected }">
      <div class="status-indicator"></div>
      <span class="status-text">{{ wsConnected ? 'WebSocket已连接' : 'WebSocket未连接' }}</span>
      <div v-if="!wsConnected" class="reconnect-controls">
        <el-tooltip effect="dark" placement="bottom">
          <template #content>
            <div>
              <p>可能的原因:</p>
              <ul>
                <li>后端服务未启动</li>
                <li>网络连接问题</li>
                <li>跨域策略限制</li>
              </ul>
              <p>排查步骤:</p>
              <ul>
                <li>确保后端服务在端口3000运行</li>
                <li>查看浏览器控制台错误信息</li>
                <li>检查浏览器网络请求</li>
              </ul>
            </div>
          </template>
          <el-button type="warning" size="small" icon="Warning">连接失败原因</el-button>
        </el-tooltip>
        <el-button type="primary" size="small" @click="reconnectWebSocket">重新连接</el-button>
      </div>
      <div v-if="wsConnected" class="connection-info">
        <span class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
          {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
        </span>
      </div>
    </div>

    <!-- 添加硬件连接控制面板 -->
    <div class="hardware-control-container">
      <el-card class="hardware-control-card">
        <template #header>
          <div class="hardware-card-header">
            <span>硬件设备连接</span>
            <el-tag :type="isHardwareConnected ? 'success' : 'danger'" size="small">
              {{ isHardwareConnected ? '已连接' : '未连接' }}
            </el-tag>
          </div>
        </template>
        <div class="hardware-card-content">
          <el-form :inline="true">
            <el-form-item label="硬件IP地址">
              <el-input v-model="hardwareIP" placeholder="例如：192.168.1.14" :disabled="isHardwareConnected"></el-input>
            </el-form-item>
            <el-form-item>
              <el-button 
                :type="isHardwareConnected ? 'danger' : 'primary'" 
                :loading="isHardwareConnecting" 
                @click="isHardwareConnected ? disconnectHardware() : connectHardware()">
                {{ isHardwareConnected ? '断开连接' : '连接硬件' }}
              </el-button>
            </el-form-item>
          </el-form>
          <div v-if="hardwareErrorMessage" class="hardware-error-message">
            <el-alert :title="hardwareErrorMessage" type="error" show-icon></el-alert>
          </div>
        </div>
      </el-card>
    </div>

    <!-- 设备选择对话框 -->
    <div v-if="showDeviceSelectionDialog" class="dialog-overlay">
      <div class="dialog-content device-selection-dialog">
        <h3>选择{{ getDeviceTypeName(dropPosition.type) }}</h3>
        
        <!-- 搜索框 -->
        <div class="search-box">
          <input 
            v-model="deviceSearchQuery" 
            type="text" 
            placeholder="搜索设备ID..."
            @input="filterDevices"
          />
        </div>
        
        <!-- 设备列表 -->
        <div class="device-list">
          <div v-if="filteredDevices.length === 0" class="no-devices">
            没有可用的{{ getDeviceTypeName(dropPosition.type) }}设备
          </div>
          
          <!-- 设备分组显示 -->
          <template v-for="(group, index) in deviceGroups" :key="index">
            <div class="device-group" v-if="group.devices.length > 0">
              <div class="group-title">{{ group.title }}</div>
              <div 
                v-for="device in group.devices" 
                :key="device.id"
                class="device-item"
                @click="selectDeviceAndAddToGraph(device)"
              >
                <div class="device-info">
                  <div class="device-id">{{ device.id }}</div>
                  <div class="device-module-id" v-if="device.moduleMetadata">
                    模块ID: {{ device.moduleMetadata.moduleId }}
                  </div>
                </div>
                <div class="device-status" :class="device.status">
                  {{ translateStatus(device.status) }}
                </div>
              </div>
            </div>
          </template>
        </div>
        
        <div class="dialog-buttons">
          <button @click="showDeviceSelectionDialog = false">取消</button>
        </div>
      </div>
    </div>

    <!-- 流程执行面板 -->
    <div v-if="isRunningWorkflow" class="workflow-execution-panel">
      <div class="execution-header">
        <h3>正在执行: {{ currentWorkflow.name }}</h3>
        <div class="execution-controls">
          <button 
            @click="pauseOrResumeWorkflow" 
            class="execution-control-btn"
            :class="{ 'pause': workflowExecutor.status === 'running', 'resume': workflowExecutor.status === 'paused' }"
          >
            {{ workflowExecutor.status === 'running' ? '暂停' : '继续' }}
          </button>
          <button @click="stopWorkflow" class="execution-control-btn stop">终止</button>
        </div>
      </div>
      
      <div class="execution-progress">
        <div class="progress-info">
          <span>步骤: {{ workflowExecutor.activeStepIndex + 1 }}/{{ currentWorkflow.steps.length }}</span>
          <span>状态: {{ translateExecutionStatus(workflowExecutor.status) }}</span>
        </div>
        
        <el-progress 
          :percentage="calculateProgress()" 
          :status="getProgressStatus()"
          :stroke-width="15"
        ></el-progress>
      </div>
      
      <div class="execution-steps">
        <div 
          v-for="(step, index) in currentWorkflow.steps" 
          :key="step.id"
          class="execution-step"
          :class="{
            'completed-step': index < workflowExecutor.activeStepIndex,
            'active-step': index === workflowExecutor.activeStepIndex,
            'pending-step': index > workflowExecutor.activeStepIndex
          }"
        >
          <div class="step-indicator">
            <div class="step-number">{{ index + 1 }}</div>
            <div class="step-status-icon">
              <i v-if="index < workflowExecutor.activeStepIndex" class="el-icon-check"></i>
              <i v-else-if="index === workflowExecutor.activeStepIndex && workflowExecutor.status === 'running'" class="el-icon-loading"></i>
              <i v-else-if="index === workflowExecutor.activeStepIndex && workflowExecutor.status === 'paused'" class="el-icon-time"></i>
            </div>
          </div>
          <div class="step-content">
            <div class="step-name">{{ step.name || '未命名步骤' }}</div>
            <div class="step-description">{{ step.description || '无描述' }}</div>
          </div>
          <!-- 添加等待状态显示 -->
          <div class="step-waiting-status" v-if="index === workflowExecutor.activeStepIndex && workflowExecutor.waitingConditions">
            <div class="waiting-title">等待条件满足:</div>
            <div 
              v-for="(condition, condIndex) in workflowExecutor.waitingConditions" 
              :key="condIndex"
              class="waiting-condition"
            >
              <div class="condition-progress">
                <el-progress 
                  :percentage="condition.progress || 0"
                  :status="condition.timeout ? 'warning' : 'primary'"
                ></el-progress>
              </div>
              <div class="condition-desc">
                等待 {{ getDeviceTypeLabel(condition.deviceType) }} {{ condition.deviceId }} 
                {{ getParameterLabel(condition.parameter) }}
                {{ getComparisonLabel(condition.comparison) }}
                {{ condition.value }}{{ getUnitForParameter(condition.parameter) }}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 流程加载对话框 -->
    <el-dialog
      title="加载反应流程"
      v-model="loadWorkflowDialog"
      width="600px"
    >
      <div class="workflow-list">
        <div v-if="savedWorkflows.length === 0" class="no-workflows">
          暂无保存的反应流程
        </div>
        
        <div 
          v-for="(workflow, index) in savedWorkflows" 
          :key="index" 
          class="workflow-item"
          @click="loadWorkflow(workflow)"
        >
          <div class="workflow-name">{{ workflow.name }}</div>
          <div class="workflow-desc">{{ workflow.description || '无描述' }}</div>
          <div class="workflow-meta">
            <span>{{ workflow.steps.length }}个步骤</span>
            <span>{{ formatDate(workflow.updatedAt || workflow.createdAt) }}</span>
          </div>
          <el-button 
            @click.stop="deleteWorkflow(workflow)" 
            type="danger" 
            size="small" 
            circle
            icon="el-icon-delete"
          ></el-button>
        </div>
      </div>
      
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="loadWorkflowDialog = false">取消</el-button>
        </span>
      </template>
    </el-dialog>

    <!-- 工作流预览对话框 -->
    <el-dialog
      title="工作流预览"
      v-model="showWorkflowPreviewDialog"
      width="800px"
      :close-on-click-modal="false"
      :close-on-press-escape="false"
    >
      <div class="workflow-preview-content">
        <div class="workflow-preview-header">
          <h3>{{ previewWorkflow?.name || '自动生成的工作流' }}</h3>
          <p class="workflow-preview-desc">{{ previewWorkflow?.description || '基于参数变更队列自动生成的工作流' }}</p>
          <div class="workflow-preview-meta">
            <span>{{ previewWorkflow?.steps?.length || 0 }}个步骤</span>
            <span>{{ formatDate(previewWorkflow?.createdAt) }}</span>
          </div>
        </div>
        
        <div class="workflow-preview-steps">
          <div 
            v-for="(step, index) in previewWorkflow?.steps || []" 
            :key="step.id" 
            class="workflow-preview-step"
          >
            <div class="preview-step-header">
              <div class="preview-step-number">{{ index + 1 }}</div>
              <div class="preview-step-name">{{ step.name }}</div>
            </div>
            <div class="preview-step-content">
              <div class="preview-step-desc">{{ step.description }}</div>
              
              <div class="preview-commands-list">
                <h4>设备命令 ({{ step.deviceCommands.length }})</h4>
                <div class="preview-commands-scroll">
                  <div v-for="(cmd, cmdIndex) in step.deviceCommands" :key="cmdIndex" class="preview-command-item">
                    <div class="preview-command-device">
                      <span class="preview-device-type">{{ translateDeviceType(cmd.deviceType) }}</span>
                      <span class="preview-device-id">{{ cmd.deviceId }}</span>
                    </div>
                    <div class="preview-command-action">
                      {{ translateActionName(cmd.action, cmd.deviceType) }}
                      <div class="preview-command-params" v-if="cmd.parameters && Object.keys(cmd.parameters).length > 0">
                        <div v-for="(value, key) in cmd.parameters" :key="key" class="preview-param">
                          {{ translateParamName(key) }}: <span class="param-value">{{ value }}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- 条件和延迟时间 -->
              <div class="preview-step-conditions" v-if="step.conditions && step.conditions.length > 0">
                <h4>执行条件 ({{ step.conditions.length }})</h4>
                <div class="preview-condition-item" v-for="(condition, condIndex) in step.conditions" :key="condIndex">
                  <div class="condition-type">{{ translateConditionType(condition.type) }}</div>
                  <div class="condition-details">
                    <div v-if="condition.type === 'deviceStatus'">
                      等待 {{ translateDeviceType(condition.deviceType) }} {{ condition.deviceId }} 
                      状态变为 {{ translateStatus(condition.status) }}
                      (超时: {{ condition.timeout || 60 }}秒)
                    </div>
                    <div v-else-if="condition.type === 'timeout'">
                      等待 {{ condition.duration }}秒
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="preview-step-delay" v-if="step.conditions && step.conditions.length > 0">
                <div class="delay-icon">🔄</div>
                <div class="delay-text">等待设备状态满足预设条件后继续</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="showWorkflowPreviewDialog = false">取消</el-button>
          <el-button type="primary" @click="executePreviewedWorkflow">执行工作流</el-button>
        </span>
      </template>
    </el-dialog>

    <!-- 反应流程编辑器界面已移除，保留必要的隐藏对话框用于后台处理 -->
    <el-dialog
      v-model="isWorkflowMode"
      title="反应流程处理"
      width="0"
      :modal="false"
      :close-on-click-modal="false"
      :show-close="false"
      :append-to-body="true"
      destroy-on-close
    ></el-dialog>

    <!-- 反应路径选择面板 - 新增 -->
    <div v-if="isShowingReactionPath" class="reaction-path-panel">
      <div class="panel-header">
        <div class="panel-title">反应路径</div>
        <button class="close-btn" @click="isShowingReactionPath = false">×</button>
      </div>
      
      <!-- 加载状态 -->
      <div v-if="isLoadingReactionPaths" class="loading-paths">
        <div class="loading-spinner"></div>
        <div class="loading-text">加载反应路径数据中...</div>
      </div>
      
      <!-- 错误信息 -->
      <div v-else-if="reactionPathsError" class="path-error">
        <div class="error-icon">!</div>
        <div class="error-text">{{ reactionPathsError }}</div>
        <button class="retry-btn" @click="loadMappingData">重试</button>
      </div>
      
      <!-- 反应路径列表 -->
      <div v-else class="reaction-paths-list">
        <div v-for="(path, index) in reactionPaths" :key="index" class="reaction-path-item" 
          :class="{'active': selectedReactionPathIndex === index}"
          @click="selectReactionPath(index)">
          <div class="path-name">{{ path.name }}</div>
          <div class="path-info">{{ path.description }}</div>
        </div>
        
        <div v-if="reactionPaths.length === 0" class="no-paths">
          暂无可用反应路径
        </div>
      </div>
      
      <div v-if="selectedReactionPathIndex !== null" class="path-actions">
        <div class="path-action-instructions">
          <div class="instruction-step">
            <div class="step-icon">1</div>
            <div class="step-text">点击各设备节点设置参数</div>
          </div>
          <div class="instruction-step">
            <div class="step-icon">2</div>
            <div class="step-text">在参数变更队列面板点击"生成工作流并执行"</div>
          </div>
        </div>
        <button class="clear-path-btn" @click="clearReactionPathHighlight">清除高亮</button>
      </div>
    </div>
    
    <!-- 增强版标准参数配置对话框 -->
    <el-dialog
      v-model="showStandardParamsDialog"
      title="反应路径参数配置"
      width="800px"
      :destroy-on-close="false"
    >
      <div class="standard-workflow-params">
        <h3>请为 "{{ reactionPaths[selectedReactionPathIndex]?.name || '未选择' }}" 反应路径设置参数</h3>
        
        <el-form label-position="top">
          <!-- 基本反应参数设置 -->
          <el-divider content-position="left">基本反应参数</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="反应温度 (°C)">
                <el-input-number v-model="standardParams.reactionTemp" :min="0" :max="300" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应时间 (分钟)">
                <el-input-number v-model="standardParams.reactionTime" :min="1" :max="600" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应体积 (μL)">
                <el-input-number v-model="standardParams.reactionVolume" :min="10" :max="1000" />
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 泵设置 -->
          <el-divider content-position="left">泵设置</el-divider>
          <div v-for="(pump, index) in pathPumps" :key="`pump-${pump.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ pump.id }}</h4>
              <el-switch v-model="standardParams.enabledPumps[pump.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledPumps[pump.id]">
              <el-col :span="6">
                <el-form-item label="泵速度 (%)">
                  <el-input-number v-model="standardParams.pumpSpeeds[pump.id]" :min="1" :max="100" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="抽取体积 (μL)">
                  <el-input-number v-model="standardParams.pumpVolumes[pump.id]" :min="10" :max="1000" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="反应物进液端口">
                  <el-select v-model="standardParams.pumpPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`in-${port}`" :label="`端口 ${port}`" :value="port" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="产品出液端口">
                  <el-select v-model="standardParams.pumpOutPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`out-${port}`" :label="`端口 ${port}`" :value="port" />
                    <el-option key="waste" label="端口 6 (废液)" :value="6" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物">
                  <el-input v-model="standardParams.pumpReagents[pump.id]" placeholder="输入反应物名称" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物浓度">
                  <el-input v-model="standardParams.pumpConcentrations[pump.id]" placeholder="例如: 0.1 M" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 阀门设置 -->
          <el-divider content-position="left">阀门设置</el-divider>
          <div v-for="(valve, index) in pathValves" :key="`valve-${valve.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ valve.id }}</h4>
              <div>
                <el-checkbox v-model="standardParams.valvesToProduct[valve.id]">连接产品</el-checkbox>
                <el-checkbox v-model="standardParams.valvesToWaste[valve.id]">连接废液</el-checkbox>
              </div>
            </div>
            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="初始阀门位置">
                  <el-select v-model="standardParams.valvePositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="产品收集阀门位置" v-if="standardParams.valvesToProduct[valve.id]">
                  <el-select v-model="standardParams.valveProductPositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 加热器设置 -->
          <el-divider content-position="left">加热器设置</el-divider>
          <div v-for="(heater, index) in pathHeaters" :key="`heater-${heater.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ heater.id }}</h4>
              <el-switch v-model="standardParams.enabledHeaters[heater.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledHeaters[heater.id]">
              <el-col :span="12">
                <el-form-item label="反应温度 (°C)">
                  <el-input-number v-model="standardParams.heaterTemps[heater.id]" :min="25" :max="300" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="加热速率">
                  <el-input-number v-model="standardParams.heaterSpeeds[heater.id]" :min="1" :max="20" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 清洗设置 -->
          <el-divider content-position="left">清洗设置</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="清洗溶液体积 (μL)">
                <el-input-number v-model="standardParams.cleaningVolume" :min="50" :max="2000" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗次数">
                <el-input-number v-model="standardParams.cleaningCycles" :min="1" :max="5" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗端口">
                <el-select v-model="standardParams.cleaningPort">
                  <el-option v-for="port in 5" :key="`clean-${port}`" :label="`端口 ${port}`" :value="port" />
                </el-select>
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 步骤说明 -->
          <el-divider content-position="left">反应步骤预览</el-divider>
          <div class="workflow-steps-preview">
            <div class="step-preview-item">
              <div class="step-number">1</div>
              <div class="step-content">
                <div class="step-title">初始化反应路径</div>
                <div class="step-desc">启动所有阀门并设置为初始位置，启动加热芯片至目标温度</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">2</div>
              <div class="step-content">
                <div class="step-title">泵润洗</div>
                <div class="step-desc">将泵排空至废液口进行润洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">3</div>
              <div class="step-content">
                <div class="step-title">抽吸反应溶液</div>
                <div class="step-desc">泵从指定端口抽取反应溶液</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">4</div>
              <div class="step-content">
                <div class="step-title">反应运行</div>
                <div class="step-desc">启动泵输出反应溶液，保持稳定反应{{standardParams.reactionTime}}分钟</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">5</div>
              <div class="step-content">
                <div class="step-title">产品收集</div>
                <div class="step-desc">打开与产品收集相连的阀门</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">6</div>
              <div class="step-content">
                <div class="step-title">废液排出</div>
                <div class="step-desc">切换连接废液口的阀门，准备系统清洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">7</div>
              <div class="step-content">
                <div class="step-title">系统清洗</div>
                <div class="step-desc">泵抽取清洗溶液并冲洗管道系统，完成{{standardParams.cleaningCycles}}次循环</div>
              </div>
            </div>
          </div>
        </el-form>
      </div>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="showStandardParamsDialog = false">取消</el-button>
          <el-button type="primary" @click="confirmGenerateWorkflow">生成工作流</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, computed, watch, reactive } from "vue";
import { Graph } from "@antv/g6";
import { useAppStoreHook } from "@/store/modules/app";
import axios from "axios";
import { saveAs } from 'file-saver'; // 需要安装 file-saver 库用于保存文件
import { ElMessage,ElMessageBox } from 'element-plus';
import { useRoute, useRouter } from 'vue-router';
const router = useRouter();

// 引入图片文件
import pump from "@/assets/jpg/pump.jpg";
import valve from "@/assets/jpg/valve.jpg";
import chip from "@/assets/jpg/chip.jpg";
import mfc from "@/assets/svg/mfc.svg?url"; // 保留原有mfc图标
import light from "@/assets/svg/light.svg?url"; // 保留原有light图标
import bottle from "@/assets/jpg/bottle.jpg";


defineOptions({
  name:"MonitorStandalone"
})
const isAdmin = ref(true);
const isSidebarOpen = ref(true);
const isLoading = ref(false); // 添加加载状态
const errorMessage = ref(""); // 添加错误信息

// 添加任务编辑模式相关的状态
const isEditMode = ref(false);
const editTaskData = ref(null);
const deviceParameters = ref({});  // 存储设备参数

// 流程模式状态
const isWorkflowMode = ref(false);
const isRunningWorkflow = ref(false);
const selectedStepIndex = ref(-1);
const loadWorkflowDialog = ref(false);

// 添加标准工作流参数状态
const showStandardParamsDialog = ref(false);
const standardParams = reactive({
  valvePositions: {}, // 阀门位置设置
  valvesToProduct: {}, // 连接产品的阀门
  valvesToWaste: {}, // 连接废液的阀门
  heaterTemps: {}, // 加热器温度
  heaterSpeeds: {}, // 加热器升温速率
  pumpSpeeds: {}, // 泵速度
  pumpVolumes: {}, // 泵抽取体积 
  pumpPorts: {}, // 泵进液端口
  pumpOutPorts: {}, // 泵出液端口
  cleaningVolume: 100, // 默认清洗体积
  reactionTime: 30, // 默认反应时间(分钟)
});

// 从反应路径中提取的设备
const pathValves = ref([]);
const pathPumps = ref([]);
const pathHeaters = ref([]);

// 当前编辑的流程
const currentWorkflow = reactive({
  id: '',
  name: '',
  description: '',
  steps: [],
  createdAt: null,
  updatedAt: null
});
// 已保存的流程列表
const savedWorkflows = ref([]);

// 可用传感器列表（示例）
const availableSensors = ref([
  { id: 'temperature_sensor_1', name: '温度传感器1' },
  { id: 'pressure_sensor_1', name: '压力传感器1' },
  { id: 'ph_sensor_1', name: 'pH传感器1' }
]);

// 连线模式相关
const isEdgeMode = ref(false);
const sourceNode = ref(null);

// 拖拽是否启用的计算属性
const isDragEnabled = computed(() => {
  console.log("isDragEnabled", isAdmin.value, isCreateMode.value, isSidebarOpen.value, isEdgeMode.value);
  // 在创建模式下始终允许拖拽节点，但需要是管理员
  if (isAdmin.value && isCreateMode.value) {
    console.log("创建模式下启用拖拽");
    return true;
  }
  // 其他情况下的原始逻辑
  return false;
});

// 获取应用侧边栏状态
const pureApp = useAppStoreHook();
const appSidebarOpened = computed(() => pureApp.getSidebarStatus);

const container = ref(null);
let graph = null;
let draggedIcon = null;

// 可拖拽图标列表
const nodeIcons = ref([
  { type: "pump", src: pump, label: "泵" },
  { type: "valve", src: valve, label: "阀" },
  { type: "chip", src: chip, label: "加热芯片" },
  { type: "mfc", src: mfc, label: "MFC控制器" },
  { type: "light", src: light, label: "光照控制" },
  { type: "bottle", src: bottle, label: "瓶" }
]);

const selectedDevice = ref(null);
const deviceData = ref({}); // 当前设备状态数据（由下位机更新）
const controlParams = ref({}); // 新增：控制参数数据（用于用户调整参数）

// 创建模式状态
const isCreateMode = ref(false);
const pathName = ref(''); // 用于存储新创建的硬件结构名称
const pathDescription = ref(''); // 用于存储硬件结构描述
const isShowPathNameDialog = ref(false); // 控制显示路径名称输入对话框

// 已有的硬件结构列表
const savedPaths = ref([]);

// 当前编辑的路径信息
const currentEditPath = ref(null);

// 删除路径相关变量
const isShowDeletePathDialog = ref(false);
const pathToDelete = ref(null);

const selectedPath = ref(null);
const selectedControllerIndex = ref(1); // 设置默认控制器索引为1

// 操作历史和撤销相关状态
const operationHistory = ref([]); // 操作历史记录
const maxHistoryLength = 20; // 最大历史记录长度

// 存储用户修改的参数
const pendingChanges = ref(new Map());
// 控制参数变更队列面板显示
const showPendingChangesPanel = ref(false);

// 流程执行器
const workflowExecutor = reactive({
  currentWorkflow: null,
  activeStepIndex: -1,
  status: 'idle', // idle, running, paused, completed, error
  startTime: null,
  endTime: null,
  stepResults: new Map(), // 存储每个步骤的执行结果
  waitingConditions: [], // 当前正在等待的条件

  updateWaitingCondition(index, progress, timeout = false) {
    if(this.waitingConditions[index]) {
      this.waitingConditions[index].progress = progress;
      this.waitingConditions[index].timeout = timeout;
    }
  },
  
  async executeWorkflow(workflow) {
    this.currentWorkflow = workflow;
    this.status = 'running';
    this.activeStepIndex = 0;
    this.startTime = Date.now();
    this.stepResults.clear();
    
    try {
      while(this.activeStepIndex < workflow.steps.length && (this.status === 'running' || this.status === 'paused')) {
        // 如果暂停，等待恢复
        if(this.status === 'paused') {
          await new Promise(resolve => {
            const checkInterval = setInterval(() => {
              if(this.status === 'running') {
                clearInterval(checkInterval);
                resolve();
              } else if(this.status === 'idle') {
                clearInterval(checkInterval);
                throw new Error('流程已终止');
              }
            }, 500);
          });
        }
        
        // 执行当前步骤
        const step = workflow.steps[this.activeStepIndex];
        
        console.log(`执行步骤 ${this.activeStepIndex + 1}: ${step.name}`);
        
        try {
          await this.executeStep(step);
          this.stepResults.set(step.id, { success: true });
        } catch(error) {
          console.error(`步骤 ${step.name} 执行失败:`, error);
          this.stepResults.set(step.id, { success: false, error: error.message });
          
          // 询问用户是否继续
          try {
            await ElMessageBox.confirm(
              `步骤 "${step.name}" 执行失败: ${error.message}\n是否继续执行后续步骤？`,
              '步骤执行失败',
              {
                confirmButtonText: '继续',
                cancelButtonText: '终止流程',
                type: 'warning',
              }
            );
            // 用户选择继续
          } catch (e) {
            // 用户选择终止
            throw new Error('用户终止了流程');
          }
        }
        
        this.activeStepIndex++;
        
        // 通知更新进度
        ElMessage.success(`已完成步骤 ${this.activeStepIndex}/${workflow.steps.length}: ${step.name}`);
      }
      
      if(this.status === 'running') {
        this.status = 'completed';
        this.endTime = Date.now();
        ElMessage.success(`流程 "${workflow.name}" 已成功完成！`);
      }
    } catch(error) {
      this.status = 'error';
      this.endTime = Date.now();
      console.error("流程执行错误:", error);
      ElMessage.error(`流程执行错误: ${error.message}`);
    }
  },
  
  async executeStep(step) {
    console.log(`开始执行步骤: ${step.name}`);
    
    // 检查步骤是否有前置条件
    if(step.conditions && step.conditions.length > 0) {
      console.log(`步骤 "${step.name}" 有 ${step.conditions.length} 个前置条件，开始检查...`);
      
      // 显示等待前置条件的UI提示
      this.waitingConditions = step.conditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index
      }));
      
      try {
        await this.checkConditions(step.conditions);
        console.log(`步骤 "${step.name}" 的前置条件已满足`);
        ElMessage.success(`前置条件已满足，开始执行步骤`);
      } catch (error) {
        console.error(`步骤 "${step.name}" 的前置条件检查失败:`, error);
        ElMessage.error(`前置条件未满足: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    }
    
    // 执行设备命令
    console.log(`开始发送 ${step.deviceCommands.length} 个设备命令...`);
    const commandPromises = step.deviceCommands.map(cmd => 
      this.sendDeviceCommand(cmd)
    );
    
    // 等待命令发送完成（注意：这只是发送完成，不是设备执行完成）
    try {
      const results = await Promise.all(commandPromises);
      console.log(`所有命令已成功发送，共 ${results.length} 个命令`);
    } catch (error) {
      console.error(`命令发送过程出错:`, error);
      ElMessage.error(`命令发送失败: ${error.message}`);
      throw error;
    }
    
    // 不论是否设置了waitForCompletion，都自动生成和检查完成条件
    // 这确保每个步骤都基于实际设备状态来确定完成条件
    
    // 自动从命令中生成完成条件
    const completionConditions = this.generateCompletionConditions(step.deviceCommands);
    
    if(completionConditions.length > 0) {
      // 显示等待信息
      ElMessage.info(`等待设备达到目标状态...共 ${completionConditions.length} 个条件需要检查`);
      
      // 设置UI等待状态
      this.waitingConditions = completionConditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index,
        deviceType: condition.deviceType,
        deviceId: condition.deviceId,
        parameter: condition.parameter || '状态',
        comparison: condition.comparison || 'eq',
        value: condition.value || condition.status
      }));
      
      try {
        // 检查所有完成条件
        await this.checkConditions(completionConditions);
        ElMessage.success(`设备已达到目标状态`);
      } catch (error) {
        console.error(`完成条件检查失败:`, error);
        ElMessage.error(`等待设备达到目标状态失败: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    } else {
      console.log(`步骤 "${step.name}" 没有生成任何完成条件，将继续执行`);
      
      // 如果没有自动生成完成条件但设置了waitForCompletion，则至少等待一个短暂时间
      if(step.waitForCompletion) {
        console.log(`步骤需要等待完成但没有具体条件，添加一个短暂等待时间（3秒）...`);
        await this.executeDelay(3);
      }
    }
    
    // 只有在明确设置了延迟时间的情况下才执行额外延迟
    if(step.delayAfter > 0) {
      console.log(`执行步骤后额外延迟 ${step.delayAfter} 秒...`);
      ElMessage.info(`步骤已完成，额外等待 ${step.delayAfter} 秒以确保系统稳定...`);
      await this.executeDelay(step.delayAfter);
    }
    
    console.log(`步骤 "${step.name}" 执行完成`);
  },
  
  async sendDeviceCommand(cmd) {
    console.log(`发送设备命令:`, cmd);
    
    // 构建适合WebSocket发送的命令格式
    const wsCommand = {
      id: cmd.deviceId,
      type: cmd.deviceType,
      action: cmd.action,
      parameters: cmd.parameters || {}
    };
    
    // 发送命令给WebSocket
    return new Promise((resolve, reject) => {
      // 设置超时
      const timeout = setTimeout(() => {
        reject(new Error(`命令执行超时: ${cmd.deviceType} ${cmd.deviceId} ${cmd.action}`));
      }, 30000); // 30秒超时
      
      // 创建一次性的消息监听器
      let messageHandler = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // 如果是命令结果响应或错误响应
          if (data.type === 'commandResult' && data.data) {
            // 检查是否是对应的命令响应
            const result = data.data;
            if (result.command && result.command.id === cmd.deviceId && result.command.action === cmd.action) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              if (result.success) {
                console.log(`命令执行成功:`, result);
                resolve(result);
              } else {
                console.error(`命令执行失败:`, result);
                reject(new Error(result.error || '命令执行失败'));
              }
            }
          }
        } catch (error) {
          console.error("解析WebSocket消息失败:", error);
        }
      };
      
      // 添加临时消息监听
      if (ws.value) {
        ws.value.addEventListener('message', messageHandler);
      }
      
      // 发送WebSocket消息
      const success = sendWsMessage({
        type: 'updateDeviceParameters',
        payload: [wsCommand]
      });
      
      if (!success) {
        clearTimeout(timeout);
        if (ws.value) {
          ws.value.removeEventListener('message', messageHandler);
        }
        reject(new Error('WebSocket消息发送失败'));
      }
    });
  },
  
  async checkConditions(conditions) {
    const conditionPromises = conditions.map(async condition => {
      switch(condition.type) {
        case 'deviceStatus':
          return this.checkDeviceStatusCondition(condition);
        
        case 'timeout':
          return this.checkTimeoutCondition(condition);
          
        case 'deviceParameter': // 新增：设备参数条件类型
          return this.checkDeviceParameterCondition(condition);
          
        case 'sensorValue':
          return this.checkSensorValueCondition(condition);
          
        default:
          throw new Error(`未知的条件类型: ${condition.type}`);
      }
    });
    // 等待所有条件满足
    await Promise.all(conditionPromises);
  },

  
  async checkDeviceStatusCondition(condition) {
    console.log(`检查设备状态条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待设备 ${condition.deviceId} 状态 ${condition.status} 超时`);
      }
      
      // 获取设备当前状态
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device && device.status === condition.status) {
        console.log(`条件满足: 设备 ${condition.deviceId} 状态为 ${condition.status}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  // 检查设备参数条件 - 优化版3.0
  async checkDeviceParameterCondition(condition, conditionIndex) {
    console.log(`检查设备参数条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000;
    
    // 获取目标参数的描述，用于日志和UI显示
    const paramName = condition.parameter;
    const paramDisplayName = this.getParameterDisplayName(condition.deviceType, paramName);
    const deviceTypeName = this.getDeviceTypeName(condition.deviceType);
    const comparisonText = this.getComparisonText(condition.comparison);
    const targetValue = condition.value;
    const tolerance = condition.tolerance || 
      (paramName === 'currentTemp' || paramName === 'temperature' ? 2 : // 温度2度容差
       paramName === 'position' ? 10 : // 位置10单位容差
       paramName === 'flowRate' ? 0.2 : // 流速0.2ml/min容差
       0.05 * targetValue); // 默认5%容差
    
    // 记录初始值，用于计算进度
    let initialValue = null;
    const device = globalDevices.value.get(condition.deviceId);
    if (device) {
      initialValue = device[condition.parameter];
      console.log(`设备${condition.deviceId}的${paramDisplayName}初始值: ${initialValue}, 目标值: ${targetValue}`);
    }
    
    // 动态调整稳定计数器 - 不同参数类型需要不同的稳定性要求
    const requiredStabilityCount = 
      (paramName === 'currentTemp' || paramName === 'temperature') ? 5 : // 温度需要更多稳定检查
      (paramName === 'position') ? 3 : // 位置需要中等稳定检查
      (paramName === 'flowRate') ? 4 : // 流速需要较多稳定检查
      2; // 其他参数2次稳定即可
    
    console.log(`设备${condition.deviceId}参数${paramDisplayName}需要连续${requiredStabilityCount}次稳定才算满足条件`);
    
    // 稳定计数器
    let stabilityCounter = 0;
    
    // 显示开始等待的提示
    ElMessage.info(`等待${deviceTypeName}(${condition.deviceId})的${paramDisplayName}${comparisonText}${targetValue}...`);
    
    // 记录最后一次值，用于检测停滞
    let lastValue = null;
    let stagnantCounter = 0;
    
    // 检测最大进展值，避免倒退
    let maxProgress = 0;
    
    while(this.status === 'running') {
      // 计算进度百分比 - 时间型进度
      const elapsedTime = Date.now() - startTime;
      const timeProgressPercent = Math.min(Math.round((elapsedTime / timeoutMs) * 100), 99);
      
      // 检查是否超时
      if(elapsedTime > timeoutMs) {
        // 更新UI显示为超时状态
        if (conditionIndex !== undefined) {
          this.updateWaitingCondition(conditionIndex, 100, true);
        }
        
        const errorMsg = `等待设备 ${condition.deviceId} 的${paramDisplayName}达到目标值(${targetValue})超时`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      
      // 获取设备当前参数值
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device) {
        const currentValue = device[condition.parameter];
        
        // 如果还没有初始值记录，现在记录
        if (initialValue === null) {
          initialValue = currentValue;
          console.log(`记录初始值: ${initialValue}`);
        }
        
        // 检查是否停滞（值没有变化）
        if (lastValue !== null && currentValue === lastValue) {
          stagnantCounter++;
          // 如果值超过10次检查没有变化（约5秒），输出警告
          if (stagnantCounter >= 10 && stagnantCounter % 10 === 0) {
            console.warn(`警告: 设备${condition.deviceId}的${paramDisplayName}已停滞在${currentValue}超过${stagnantCounter/2}秒`);
          }
        } else {
          stagnantCounter = 0;
          lastValue = currentValue;
        }
        
        let conditionMet = false;
        
        // 根据比较类型检查条件
        switch(condition.comparison) {
          case 'eq': // 等于
            // 带容差的相等判断
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
            
          case 'gt': // 大于
            conditionMet = currentValue > condition.value;
            break;
            
          case 'lt': // 小于
            conditionMet = currentValue < condition.value;
            break;
            
          case 'gte': // 大于等于
            conditionMet = currentValue >= condition.value;
            break;
            
          case 'lte': // 小于等于
            conditionMet = currentValue <= condition.value;
            break;
            
          case 'approx': // 近似值（主要用于浮点数）
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
        }
        
        // 根据条件是否满足调整稳定计数器
        if(conditionMet) {
          stabilityCounter++;
          
          // 计算基于接近目标值的进度 - 达到稳定次数的百分比
          const valueProgressPercent = Math.min(Math.round((stabilityCounter / requiredStabilityCount) * 100), 99);
          
          // 取两种进度的最大值，确保进度一直在前进
          let combinedProgress = Math.max(timeProgressPercent, valueProgressPercent);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态 - 显示更积极的进度
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
          
          // 如果已经连续多次满足条件，认为条件稳定满足
          if(stabilityCounter >= requiredStabilityCount) {
            // 条件满足时，设置进度为100%
            if (conditionIndex !== undefined) {
              this.updateWaitingCondition(conditionIndex, 100);
            }
            
            console.log(`条件已稳定满足: ${deviceTypeName}(${condition.deviceId})的${paramDisplayName}已${comparisonText}${targetValue}`);
            // 记录最终值和达成时间
            const reachedInSec = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`目标值: ${targetValue}, 当前值: ${currentValue}, 容差: ±${tolerance}, 耗时: ${reachedInSec}秒`);
            
            // 直接跳出循环，提前满足条件
            return true;
          }
          
          console.log(`接近条件满足(${stabilityCounter}/${requiredStabilityCount}): 当前值: ${currentValue}, 目标值: ${targetValue}, 容差: ±${tolerance}`);
        } else {
          // 如果条件不满足，重置稳定计数器
          stabilityCounter = 0;
          
          // 对于可测量的进度（如温度、位置变化），计算完成百分比
          let valueProgress = 0;
          
          if (initialValue !== null && initialValue !== currentValue) {
            // 根据不同参数类型计算进度
            if (paramName === 'temperature' || paramName === 'currentTemp') {
              // 温度变化进度
              const direction = targetValue > initialValue ? 1 : -1; // 是加热还是冷却
              if (direction > 0) { // 加热
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentValue - initialValue) / (targetValue - initialValue) * 100)
                ));
              } else { // 冷却
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((initialValue - currentValue) / (initialValue - targetValue) * 100)
                ));
              }
            } else if (paramName === 'position') {
              // 位置移动进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalDistance = Math.abs(targetValue - initialValue);
              const currentDistance = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentDistance / totalDistance) * 100)
              ));
            } else if (paramName === 'flowRate') {
              // 流速变化进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentChange / totalChange) * 100)
              ));
            } else {
              // 其他参数的通用进度计算
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              if (totalChange > 0) {
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentChange / totalChange) * 100)
                ));
              }
            }
          }
          
          // 取两种进度的最大值
          let combinedProgress = Math.max(timeProgressPercent, valueProgress);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
        }
        
        // 记录进度 - 但降低日志频率
        const progressTime = ((Date.now() - startTime) / 1000).toFixed(1);
        if (parseInt(progressTime) % 5 === 0) { // 每5秒记录一次
          console.log(`等待进度: ${maxProgress}%, 当前值: ${currentValue}, 目标值: ${targetValue}, 已等待${progressTime}秒`);
        }
      } else {
        console.warn(`找不到设备 ${condition.deviceId} 的数据，请检查设备是否连接`);
      }
      
      // 等待检查间隔 - 根据不同设备参数类型调整
      const checkInterval = 
        (paramName === 'currentTemp' || paramName === 'temperature') ? 1000 : // 温度1秒检查一次
        (paramName === 'position') ? 500 : // 位置0.5秒检查一次
        (paramName === 'flowRate') ? 750 : // 流速0.75秒检查一次
        300; // 其他参数0.3秒检查一次
      
      await new Promise(resolve => setTimeout(resolve, checkInterval));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  // 获取参数的友好显示名称
  getParameterDisplayName(deviceType, parameter) {
    const displayNames = {
      'position': '位置',
      'speed': '速度',
      'currentTemp': '温度',
      'temperature': '温度',
      'flowRate': '流速',
      'intensity': '光强',
      'port': '端口',
      'aspiratePort': '吸取端口',
      'dispensePort': '输送端口'
    };
    
    return displayNames[parameter] || parameter;
  },
  
  // 获取设备类型的友好名称
  getDeviceTypeName(deviceType) {
    const displayNames = {
      'pump': '泵',
      'valve': '阀门',
      'chip': '加热芯片',
      'mfc': '流量控制器',
      'light': '光照控制'
    };
    
    return displayNames[deviceType] || deviceType;
  },
  
  // 获取比较符号的文本表示
  getComparisonText(comparison) {
    const displayTexts = {
      'eq': '等于',
      'gt': '大于',
      'lt': '小于',
      'gte': '大于等于',
      'lte': '小于等于',
      'approx': '约等于'
    };
    
    return displayTexts[comparison] || comparison;
  },
  async checkTimeoutCondition(condition) {
    console.log(`执行等待条件: ${condition.duration}秒`);
    
    const durationMs = condition.duration * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个等待条件用于UI显示
    const waitingCondition = {
      type: 'timeout',
      description: `等待${condition.duration}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表以显示在UI上
    const conditionIndex = this.waitingConditions.length;
    this.waitingConditions.push(waitingCondition);
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      waitingCondition.progress = progressPercent;
      waitingCondition.description = `等待中: 剩余${remainingTime}秒`;
      this.waitingConditions[conditionIndex] = { ...waitingCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`等待进度: ${progressPercent}%, 已等待${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        waitingCondition.description = `等待已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[conditionIndex] = { ...waitingCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime.value += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成等待
    waitingCondition.progress = 100;
    waitingCondition.description = `等待完成: ${condition.duration}秒`;
    this.waitingConditions[conditionIndex] = { ...waitingCondition };
    
    console.log(`等待条件满足: 完成${condition.duration}秒等待`);
    return true;
  },
  
  // 执行时间延迟 - 增强版，支持暂停和终止
  async executeDelay(seconds) {
    console.log(`执行延迟: ${seconds}秒`);
    
    const durationMs = seconds * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个延迟条件用于UI显示
    const delayCondition = {
      type: 'delay',
      description: `系统稳定: ${seconds}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表
    this.waitingConditions = [delayCondition];
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      delayCondition.progress = progressPercent;
      delayCondition.description = `系统稳定中: 剩余${remainingTime}秒`;
      this.waitingConditions[0] = { ...delayCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`延迟进度: ${progressPercent}%, 已延迟${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        delayCondition.description = `延迟已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[0] = { ...delayCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成延迟
    delayCondition.progress = 100;
    delayCondition.description = `延迟完成: ${seconds}秒`;
    this.waitingConditions[0] = { ...delayCondition };
    
    // 清空等待条件列表
    setTimeout(() => {
      this.waitingConditions = [];
    }, 500);
    
    console.log(`延迟完成: ${seconds}秒`);
  },
  
  async checkSensorValueCondition(condition) {
    console.log(`检查传感器值条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待传感器 ${condition.sensorId} 条件满足超时`);
      }
      
      // TODO: 获取传感器实时数据，可以通过WebSocket或API实现
      // 这里使用模拟值
      const sensorValue = await getSensorValue(condition.sensorId);
      
      // 根据比较类型检查条件
      let conditionMet = false;
      switch(condition.comparison) {
        case 'gt':
          conditionMet = sensorValue > condition.value;
          break;
        case 'lt':
          conditionMet = sensorValue < condition.value;
          break;
        case 'eq':
          conditionMet = Math.abs(sensorValue - condition.value) < 0.001; // 浮点数比较
          break;
        case 'gte':
          conditionMet = sensorValue >= condition.value;
          break;
        case 'lte':
          conditionMet = sensorValue <= condition.value;
          break;
      }
      
      if(conditionMet) {
        console.log(`条件满足: 传感器 ${condition.sensorId} 值 ${sensorValue} ${condition.comparison} ${condition.value}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  pauseWorkflow() {
    if(this.status === 'running') {
      this.status = 'paused';
      console.log('流程已暂停');
    }
  },
  
  resumeWorkflow() {
    if(this.status === 'paused') {
      this.status = 'running';
      console.log('流程已恢复');
    }
  },
  
  stopWorkflow() {
    this.status = 'idle';
    console.log('流程已终止');
  },

  // 从设备命令自动生成完成条件 - 增强版2.0
  generateCompletionConditions(deviceCommands) {
    const conditions = [];
    
    // 对命令进行优先级排序 - 某些命令的执行需要优先检查
    const prioritizedCommands = [...deviceCommands].sort((a, b) => {
      // 加热器设置温度的命令具有较高优先级，因为温度变化通常最慢
      if (a.deviceType === 'chip' && a.action === 'setTemp') return -1;
      if (b.deviceType === 'chip' && b.action === 'setTemp') return 1;
      
      // 泵设置位置的命令其次
      if (a.deviceType === 'pump' && a.action === 'setPosition') return -1;
      if (b.deviceType === 'pump' && b.action === 'setPosition') return 1;
      
      return 0; // 其他命令维持原顺序
    });
    
    // 为每个命令生成完成条件
    prioritizedCommands.forEach(cmd => {
      // 首先检查命令是否需要生成完成条件
      if (cmd.generateCompletionCondition === false) {
        console.log(`命令 ${cmd.deviceId}-${cmd.action} 已禁用自动生成完成条件`);
        return; // 跳过此命令
      }
      
      // 设置默认超时时间，如果命令中指定了则使用指定值
      const defaultTimeout = cmd.completionTimeout || 60;
      
      // 获取当前设备数据以供参考
      const device = globalDevices.value.get(cmd.deviceId);
      
      // 根据不同设备类型和命令生成不同的完成条件
      switch(cmd.deviceType) {
        case 'pump':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              tolerance: 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'aspirate' && cmd.parameters?.volume !== undefined) {
            // 吸取液体操作 - 需要监控位置变化
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'gte',
              value: cmd.parameters.volume * 0.95, // 至少达到设定体积的95%
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'dispense' && cmd.parameters?.volume !== undefined) {
            // 排出液体操作 - 需要监控位置变化
            const device = globalDevices.value.get(cmd.deviceId);
            const currentPosition = device?.position || 0;
            const targetPosition = Math.max(0, currentPosition - cmd.parameters.volume);
            
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: targetPosition + 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'setSpeed') {
            // 设置速度 - 监控速度是否已设置
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'speed',
              comparison: 'eq',
              value: cmd.parameters.speed,
              tolerance: 1, // 允许1%的误差
              timeout: 5 // 速度设置应该很快
            });
          } else if(cmd.action === 'empty') {
            // 清空泵 - 监控位置是否接近零
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: 10, // 视为接近空
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'initialize') {
            // 初始化 - 监控状态变为idle
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 5 // 停止应该很快
            });
          }
          break;
          
        case 'chip':
          if(cmd.action === 'setTemp' && cmd.parameters?.temperature !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              parameter: 'currentTemp',
              comparison: 'approx', // 使用更精确的近似比较
              value: cmd.parameters.temperature,
              tolerance: 2, // 允许2度的误差
              timeout: Math.max(120, defaultTimeout) // 加热需要较长时间，至少120秒
            });
          } else if(cmd.action === 'powerOn') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'heating',
              timeout: 10
            });
          } else if(cmd.action === 'powerOff') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: 10
            });
          }
          break;
          
        case 'valve':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'open') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'open',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'close') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'closed',
              timeout: defaultTimeout
            });
          }
          break;
          
        case 'mfc':
          if(cmd.action === 'setFlowRate' && cmd.parameters?.flowRate !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              parameter: 'flowRate',
              comparison: 'approx',
              value: cmd.parameters.flowRate,
              tolerance: 0.2, // 允许0.2ml/min误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'start') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'running',
              timeout: 10
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 10
            });
          }
          break;
          
        case 'light':
          if(cmd.action === 'setIntensity' && cmd.parameters?.intensity !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              parameter: 'intensity',
              comparison: 'approx',
              value: cmd.parameters.intensity,
              tolerance: 1, // 允许1%的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'on') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'on',
              timeout: 5
            });
          } else if(cmd.action === 'off') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'off',
              timeout: 5
            });
          }
          break;
      }
    });
    
    // 记录生成的完成条件
    console.log(`为${deviceCommands.length}个命令生成了${conditions.length}个完成条件`);
    conditions.forEach((condition, index) => {
      console.log(`条件${index+1}:`, JSON.stringify(condition));
    });
    
    return conditions;
  }
});

// 添加操作到历史记录
const addToHistory = (operation) => {
  // 添加新操作到历史记录
  operationHistory.value.push(operation);
  
  // 如果历史记录超过最大长度，移除最早的记录
  if (operationHistory.value.length > maxHistoryLength) {
    operationHistory.value.shift();
  }
  
  console.log(`已添加操作到历史记录，当前历史长度: ${operationHistory.value.length}`);
};

// 进入硬件结构创建模式
const enterCreateMode = () => {
  isCreateMode.value = true;
  isSidebarOpen.value = true; // 确保侧边栏打开
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 重置拖拽和连线状态
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空操作历史
  operationHistory.value = [];
  
  // 初始化编辑状态 - 设置默认值
  currentEditPath.value = {
    name: '',
    type: 'custom',
    controllerIndex: 1
  };
  console.log("进入创建模式", isDragEnabled.value);
};

// 退出创建模式
const exitCreateMode = () => {
  isCreateMode.value = false;
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 如果有选中的自定义路径，重新加载
  if (selectedPath.value && typeof selectedPath.value === 'object') {
    // 自定义路径
    loadStructureFromFile(selectedPath.value);
  }
};

// 从文件加载硬件结构
const loadStructureFromFile = async (path) => {
  try {
    isLoading.value = true;
    console.log("尝试加载硬件结构:", path);
    
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 1. 首先尝试从新的API路径获取文件内容
    const pathId = path.id || path.name; // 使用ID优先，否则使用name
    console.log("正在从API加载路径ID:", pathId);
    
    try {
      const response = await axios.get(`${baseUrl}/api/devices/path/${encodeURIComponent(pathId)}`);
      
      if (response.data.code !== 0 || !response.data.data) {
        throw new Error("API返回错误或数据为空");
      }
      
      const pathConfig = response.data.data;
      console.log("从API加载的路径数据:", pathConfig);
      
      // 确保图表已初始化
      if (!graph) {
        console.error("图表实例未初始化，无法加载路径");
        errorMessage.value = "图表实例未初始化，请刷新页面重试";
        return;
      }
      
      // 重新初始化图表以解决潜在的渲染问题
      // 1. 获取容器尺寸
      const containerEl = container.value;
      if (!containerEl) {
        errorMessage.value = "找不到图表容器";
        return;
      }
      
      const graphWidth = containerEl.clientWidth || 800;
      const graphHeight = containerEl.clientHeight || 600;
      
      // 2. 销毁旧图表
      if (graph) {
        graph.destroy();
      }
      
      // 3. 创建新图表
      console.log(`重新初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
      graph = new Graph({
        container: containerEl,
        width: graphWidth,
        height: graphHeight,
        behaviors: [
          
          {
            type: 'zoom-canvas',
            sensitivity: 1.5,
            key: 'zoom-canvas',
            enable: true
          },
          {
            type: 'click-select',
            key: 'click-select',
            enable: true
          },
          {
            type: 'drag-element',
            key: 'drag-element',
            enable: true,
            shouldBegin: (e) => {
              return isCreateMode.value && isAdmin.value;
            }
          }
        ],
        node: {
          style: {
            fill: '#91d5ff',
            stroke: '#40a9ff',
            lineWidth: 1,
            radius: 6,
            cursor: 'move'
          }
        },
        edge: {
          style: {
            stroke: '#91d5ff',
            lineWidth: 2,
            endArrow: {
              fill: '#91d5ff',
              stroke: '#91d5ff'
            }
          }
        }
      });
      
      // 重新注册事件
      graph.on('node:click', handleDeviceClick);
      
      // 处理和添加节点
      const nodesData = [];
      if (pathConfig.data && pathConfig.data.nodes && Array.isArray(pathConfig.data.nodes)) {
        for (const node of pathConfig.data.nodes) {
          if (!node.id) continue;
          
          // 创建标准节点数据
          const processedNode = {
            id: node.id,
            type: "image",
            data: {
              deviceType: node.data?.deviceType || node.id.split('-')[0] || 'unknown',
              label: node.data?.label || "设备"
            },
            style: {
              x: node.style?.x || 100 + Math.random() * 300,
              y: node.style?.y || 100 + Math.random() * 200,
              size: node.style?.size || [40, 40],
              label: node.style?.label || `设备 (${node.id})`,
              labelCfg: {
                position: "bottom",
                offset: [0, 5],
                style: {
                  fill: "#333",
                  fontSize: 12
                }
              }
            }
          };
          
          // 设置图标
          const deviceType = processedNode.data.deviceType;
          switch (deviceType) {
            case "pump": 
              processedNode.style.src = pump; // 使用JPG图片
              processedNode.style.label = node.style?.label || `泵 (${node.id})`;
              // 针对JPG格式图片调整尺寸，确保正确显示
              processedNode.style.size = [40, 40];
              break;
            case "valve": 
              processedNode.style.src = valve; // 使用JPG图片
              processedNode.style.label = node.style?.label || `阀 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "chip": 
              processedNode.style.src = chip; // 使用JPG图片
              processedNode.style.label = node.style?.label || `加热芯片 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "mfc": 
              processedNode.style.src = mfc; 
              processedNode.style.label = node.style?.label || `MFC控制器 (${node.id})`;
              break;
            case "light": 
              processedNode.style.src = light; 
              processedNode.style.label = node.style?.label || `光照控制 (${node.id})`;
              break;
            case "bottle": 
              processedNode.style.src = bottle; // 使用JPG图片
              processedNode.style.label = node.style?.label || `瓶 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            default:
              // 如果没有匹配的图标，使用通用图标
              processedNode.style.src = bottle;
          }
          
          nodesData.push(processedNode);
        }
      }
      
      console.log("处理后的节点数据:", nodesData);
      
      // 添加节点到图表
      if (nodesData.length > 0) {
        graph.addNodeData(nodesData);
      } else {
        console.warn("没有有效的节点数据");
      }
      
      // 处理和添加边
      const edgesData = [];
      if (pathConfig.data && pathConfig.data.edges && Array.isArray(pathConfig.data.edges)) {
        for (const edge of pathConfig.data.edges) {
          if (!edge.source || !edge.target) continue;
          
          // 创建标准边数据
          const processedEdge = {
            id: edge.id || `edge-${Math.random().toString(36).substr(2, 9)}`,
            source: edge.source,
            target: edge.target,
            style: {
              stroke: '#91d5ff',
              lineWidth: 2,
              endArrow: {
                fill: '#91d5ff',
                stroke: '#91d5ff'
              }
            }
          };
          
          // 复制其他属性
          if (edge.style) {
            Object.assign(processedEdge.style, edge.style);
          }
          
          edgesData.push(processedEdge);
        }
      }
      
      console.log("处理后的边数据:", edgesData);
      
      // 添加边到图表
      if (edgesData.length > 0) {
        graph.addEdgeData(edgesData);
      }
      
      // 渲染图表
      try {
        console.log("开始渲染图表...");
        
        // 延迟渲染，等待DOM更新
        setTimeout(() => {
          graph.render();
          console.log("图表渲染完成");
          
          // 自动调整视图以适应所有元素
          if (nodesData.length > 0) {
            graph.fitView();
          }
          
          // 硬件图加载完成，初始化反应路径
          onGraphLoaded();
        }, 100);
      } catch (renderError) {
        console.error("图表渲染失败:", renderError);
        errorMessage.value = `图表渲染失败: ${renderError.message}`;
      }
      
      onHardwareStructureLoaded();
      // 更新当前选中的路径
      selectedPath.value = path;
      
      // 设置控制器索引
      if (pathConfig.controllerIndex !== undefined) {
        selectedControllerIndex.value = pathConfig.controllerIndex;
      }
    } catch (apiError) {
      console.error("从API加载路径失败:", apiError);
      errorMessage.value = `加载路径失败: ${apiError.message}`;
    }
  } catch (error) {
    console.error("加载硬件结构失败:", error);
    errorMessage.value = `加载硬件结构失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};


// 向图中添加设备节点
const addDeviceToGraph = (device, iconSrc, label, x, y) => {
  if (!graph) {
    console.error("添加设备失败：图表未初始化");
    return;
  }
  
  console.log("添加设备到图中:", device, "位置:", x, y, "图标:", iconSrc);
  
  try {
    // 检查节点是否已存在
    const existingNode = graph.getNodeData().find(node => node.id === device.id);
    if (existingNode) {
      console.log(`节点 ${device.id} 已存在于图中，不重复添加`);
      
      // 更新节点外观以反映状态
      updateNodeAppearance(device.id, device.status);
      return;
    }
    
    // 要添加的节点数据
    const nodeData = {
      id: device.id,
      type: "image",
      data: {
        label: label,
        deviceType: device.type,
        nodeType: device.type,
        deviceData: device,
        // 记录图片格式信息
        imgFormat: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? 'jpg' : 'svg'
      },
      style: {
        src: iconSrc,
        x: x,
        y: y,
        // 调整图片尺寸，确保JPG图片显示正确
        size: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? [40, 40] : [40, 40],
        label: device.moduleMetadata 
          ? `${label} (${device.moduleMetadata.moduleName} #${device.moduleMetadata.moduleId})` 
          : `${label} (${device.id})`,
        labelCfg: {
          position: "bottom",
          offset: [0, 5],
          style: {
            fill: "#333",
            fontSize: 12
          }
        },
        cursor: "move",
        // 节点外观
        fill: "rgba(255, 255, 255, 0.9)",
        stroke: "#1890ff",
        lineWidth: 1,
        radius: 6,
        shadowColor: "rgba(0,0,0,0.1)",
        shadowBlur: 5
      }
    };
    
    // 打印完整节点数据用于调试
    console.log("添加节点详细数据:", JSON.stringify(nodeData, null, 2));
    console.log("isDragEnabled", isDragEnabled.value);
    // 添加节点
    graph.addNodeData([nodeData]);
    
    // 确保拖拽行为正确
    updateDragBehavior();
    
    // 如果在创建模式下，记录此操作以支持撤销
    if (isCreateMode.value) {
      addToHistory({
        type: 'addNode',
        nodeId: device.id,
        nodeData: nodeData
      });
    }
    
    // 更新节点外观以反映状态
    updateNodeAppearance(device.id, device.status);
    
    // 确保渲染更新 - 这是关键步骤
    graph.render();
    
    console.log("节点添加成功，已渲染");
  } catch (error) {
    console.error("添加设备到图中失败:", error);
    errorMessage.value = `添加设备到图中失败: ${error.message}`;
  }
};

// 保存当前硬件结构
const saveCurrentPath = async () => {
  try {
    // 检查是否输入了名称
    if (!pathName.value.trim()) {
      errorMessage.value = "请输入硬件结构名称";
      return;
    }
    
    isLoading.value = true;
    
    // 获取当前图的数据
    const nodes = graph.getNodeData();
    const edges = graph.getEdgeData();
    
    console.log("正在保存硬件结构，节点数据:", nodes);
    console.log("正在保存硬件结构，边数据:", edges);
    
    // 修改nodes，保存完整的节点信息以便正确恢复
    const simplifiedNodes = nodes.map(node => {
      const deviceType = node.data?.deviceType || (node.id.split('-')[0]);
      
      // 需要保留的关键样式属性
      const style = {
        x: node.style?.x || 0,
        y: node.style?.y || 0,
        src: node.style?.src,
        size: node.style?.size,
        label: node.style?.label,
        labelCfg: node.style?.labelCfg,
        cursor: node.style?.cursor,
        fill: node.style?.fill,
        stroke: node.style?.stroke,
        lineWidth: node.style?.lineWidth,
        radius: node.style?.radius,
        shadowColor: node.style?.shadowColor,
        shadowBlur: node.style?.shadowBlur
      };
      
      return {
        id: node.id,
        type: node.type,
        data: {
          label: node.data?.label || "",
          deviceType: deviceType,
          nodeType: node.data?.nodeType || deviceType,
          deviceData: node.data?.deviceData
        },
        style: style
      };
    });
    
    // 处理图片路径问题，防止序列化错误
    const serializedNodes = fixImageSrcForSerialization(simplifiedNodes);
    
    console.log("处理后的节点数据:", serializedNodes);
    
    // 创建路径配置对象
    const pathConfig = {
      name: pathName.value,
      description: pathDescription.value || '',
      createdBy: 'user', // 可以从用户系统获取
      type: 'custom', // 使用自定义类型
      controllerIndex: selectedControllerIndex.value || 1,
      data: {
        nodes: serializedNodes,
        edges
      }
    };
    
    console.log("正在保存硬件结构，数据:", pathConfig);
    
    // 使用服务器的完整URL
    // 在开发环境中，需要指定后端服务器地址
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 调用API保存到服务器 - 使用新的API路径
    const response = await axios.post(`${baseUrl}/api/devices/path`, pathConfig);
    
    console.log("保存路径响应:", response);
    
    if (response.data.code === 0) {
      // 保存成功
      // 1. 更新当前编辑的路径
      const savedPath = response.data.data;
      currentEditPath.value = savedPath;
      selectedPath.value = savedPath;
      
      // 2. 更新路径列表
      let updatedPaths = [...savedPaths.value];
      const existingIndex = updatedPaths.findIndex(p => p.name === savedPath.name);
      
      if (existingIndex >= 0) {
        // 更新现有路径
        updatedPaths[existingIndex] = savedPath;
      } else {
        // 添加新路径
        updatedPaths.push(savedPath);
      }
      
      // 3. 保存到本地存储
      savedPaths.value = updatedPaths;
      localStorage.setItem('savedReactionPaths', JSON.stringify(updatedPaths));
      
      // 提示用户
      alert(`硬件结构 "${pathName.value}" 已保存成功!`);
      
      // 关闭对话框
      isShowPathNameDialog.value = false;
    } else {
      errorMessage.value = response.data.msg || "保存失败，请重试";
    }
  } catch (error) {
    console.error("保存硬件结构失败:", error);
    errorMessage.value = `保存失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};



// 拖拽开始
const handleDragStart = (e, icon) => {
  draggedIcon = icon;
  e.dataTransfer.setData('text/plain', JSON.stringify({ type: icon.type }));
  e.dataTransfer.effectAllowed = 'copy';
};

// 拖拽结束
const handleDragEnd = () => {
  draggedIcon = null;
};

// 处理节点点击，用于连线
const handleNodeClick = e => {
  if (!isEdgeMode.value) return;

  // 打印关键信息而非整个事件对象，避免循环引用问题
  console.log("点击节点事件:", {
    type: e.type,
    target: e.target ? { type: e.target.type } : null,
    item: e.item ? { id: e.item.id, type: e.item.type } : null,
    itemId: e.itemId
  });

  // G6 v5中，节点ID可能在不同位置
  let nodeId = null;

  // 尝试不同路径获取节点ID
  if (e.itemId) {
    nodeId = e.itemId;
  } else if (e.item && e.item.id) {
    nodeId = e.item.id;
  } else if (e.target && e.target.get && typeof e.target.get === "function") {
    try {
      nodeId = e.target.get("id");
    } catch (err) {
      console.log("获取target.id失败:", err);
    }
  } else if (
    e.currentTarget &&
    e.currentTarget.get &&
    typeof e.currentTarget.get === "function"
  ) {
    try {
      nodeId = e.currentTarget.get("id");
    } catch (err) {
      console.log("获取currentTarget.id失败:", err);
    }
  }

  console.log("获取到的节点ID:", nodeId);

  if (!nodeId) {
    console.error("无法获取节点ID");
    // 尝试直接从原始节点数据获取ID
    if (e.item && e.item.getModel) {
      try {
        const model = e.item.getModel();
        nodeId = model.id;
        console.log("从model获取到ID:", nodeId);
      } catch (err) {
        console.log("获取model失败:", err);
      }
    }

    if (!nodeId) return;
  }

  // 若还没选中源节点，则将当前点击节点设为源节点
  if (!sourceNode.value) {
    sourceNode.value = nodeId;
    // 高亮源节点 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          fill: "#1890ff",
          stroke: "#096dd9"
        }
      }
    ]);
  } else if (sourceNode.value !== nodeId) {
    // 已选中源节点，且当前点击了不同的节点，创建连线
    const edgeId = `edge-${Date.now()}`;

    // 边数据
    const edgeData = {
      id: edgeId,
      source: sourceNode.value,
      target: nodeId,
      data: {
        label: "", // 可选: 添加边标签
        weight: 1
      },
      style: {
        stroke: "#1890ff",
        lineWidth: 2,
        endArrow: true
      }
    };

    // 添加边 - 按照最新G6文档的方式
    graph.addEdgeData([edgeData]);
    
    // 记录添加边的操作
    if (isCreateMode.value) {
      addToHistory({
        type: 'addEdge',
        edgeId: edgeId,
        edgeData: edgeData
      });
    }

    // 取消源节点的高亮 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: sourceNode.value,
        style: {
          fill: "#91d5ff", // 恢复默认颜色
          stroke: "#40a9ff"
        }
      }
    ]);

    // 重置源节点
    sourceNode.value = null;

    // 渲染更新
    graph.render();
  }
};

// 从后端获取设备信息
const fetchDeviceInfo = async (deviceId) => {
  if (!deviceId) {
    console.warn("无效的设备ID");
    return null;
  }
  
  console.log("获取设备信息:", deviceId);
  
  try {
    // 尝试从缓存获取设备类型
    let deviceType = null;
    
    // 从设备ID推断类型
    if (deviceId.includes("pump")) {
      deviceType = "pump";
    } else if (deviceId.includes("valve")) {
      deviceType = "valve";
    } else if (deviceId.includes("chip")) {
      deviceType = "chip";
    } else if (deviceId.includes("mfc")) {
      deviceType = "mfc";
    } else if (deviceId.includes("light")) {
      deviceType = "light";
    }
    
    // 首先尝试通过WebSocket获取设备信息
    if (wsConnected.value) {
      console.log("尝试通过WebSocket获取设备信息");
      const deviceInfoPromise = new Promise((resolve, reject) => {
        // 设置超时
        const timeout = setTimeout(() => {
          console.warn("WebSocket获取设备信息超时");
          resolve(null); // 超时时返回null
        }, 3000);
        
        // 创建一次性的消息监听器
        let messageHandler = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("收到WebSocket消息:", data);
            
            // 如果是设备信息响应或错误响应
            if (data.type === 'deviceInfo' && data.data && data.data.id === deviceId) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              console.log("成功获取到设备信息:", data.data);
              resolve(data.data);
            } else if (data.type === 'error' && data.data && data.data.message && data.data.message.includes(deviceId)) {
              console.warn("WebSocket返回错误:", data.data);
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              // 如果是"设备不存在"错误，尝试注册设备
              if (data.data.message.includes("不存在") && deviceType) {
                console.log(`设备 ${deviceId} 不存在`);
                // 返回默认数据
                resolve(null);
              } else {
                // 其他错误则返回null
                resolve(null);
              }
            }
          } catch (error) {
            console.error("解析WebSocket消息失败:", error);
            ws.value.removeEventListener('message', messageHandler);
            clearTimeout(timeout);
            resolve(null);
          }
        };
        
        // 添加临时消息监听
        if (ws.value) {
          ws.value.addEventListener('message', messageHandler);
        }
        
        // 发送WebSocket消息获取设备信息
        const success = sendWsMessage({
          type: 'getDeviceInfo', // 使用正确的消息类型
          payload: { id: deviceId }
        });
        
        if (!success) {
          console.warn("WebSocket消息发送失败");
          clearTimeout(timeout);
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
          resolve(null);
        }
        
        // 在超时后移除监听器
        setTimeout(() => {
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
        }, 3000);
      });
      
      const deviceInfo = await deviceInfoPromise;
      if (deviceInfo) {
        return deviceInfo;
      }
    }
    // 如果失败，使用默认值
    console.log(`无法从后端获取设备 ${deviceId} 的信息，使用默认值`);
    
    // 如果无法确定设备类型，返回null
    console.warn("无法确定设备类型，无法创建默认信息");
    return null;
  } catch (error) {
    console.error("获取设备信息失败:", error);
    return null;
  }
};

// 处理设备点击事件
const handleDeviceClick = async (e) => {
  try {
    // 连线模式下使用原来的点击逻辑
    if (isEdgeMode.value) {
      handleNodeClick(e);
      return;
    }

    // 获取节点ID
    let nodeId = null;
    if (e.itemId) {
      nodeId = e.itemId;
    } else if (e.item && e.item.id) {
      nodeId = e.item.id;
    } else if (e.target && e.target.get && typeof e.target.get === "function") {
      try {
        nodeId = e.target.get("id");
      } catch (err) {
        console.log("获取target.id失败:", err);
      }
    }

    if (!nodeId) {
      console.warn("无法获取节点ID，取消处理设备点击");
      return;
    }

    // 使用新的selectDevice函数处理设备选择
    selectDevice(nodeId);
  } catch (error) {
    console.error("处理设备点击失败:", error);
    errorMessage.value = `处理设备点击失败: ${error.message}`;
  }
};

// 更新节点外观以反映设备状态
const updateNodeAppearance = (nodeId, status) => {
  console.log('!!!!!!!!!!!!更新节点外观:', nodeId, status);
  if (!graph) return;
  
  try {
    let strokeColor = "#1890ff"; // 默认边框颜色
    let shadowColor = "rgba(0,0,0,0.1)"; // 默认阴影颜色
    
    // 根据状态设置样式
    switch (status) {
      case "running":
    case "open":
      case "heating":
        strokeColor = "#67c23a"; // 绿色
        shadowColor = "rgba(103, 194, 58, 0.3)";
      break;
      case "stopped":
      case "closed":
      case "idle":
        strokeColor = "#909399"; // 灰色
        shadowColor = "rgba(144, 147, 153, 0.3)";
      break;
      case "error":
        strokeColor = "#f56c6c"; // 红色
        shadowColor = "rgba(245, 108, 108, 0.3)";
        break;
      case "cooling":
        strokeColor = "#1890ff"; // 蓝色
        shadowColor = "rgba(24, 144, 255, 0.3)";
      break;
    }
    
    // 更新节点样式
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          stroke: strokeColor,
          shadowColor: shadowColor,
          shadowBlur: 10
        }
      }
    ]);
    graph.render();
  } catch (error) {
    console.error("更新节点外观失败:", error);
  }
};

// 控制面板显示状态
const showControlPanel = ref(false);

// 关闭控制面板
const closeControlPanel = () => {
  showControlPanel.value = false;
  selectedDevice.value = null;
  // 重置控制参数对象
  controlParams.value = {};
};

// 控制拖拽功能启用/禁用
const updateDragBehavior = () => {
  if (!graph) return;

  // 使用计算属性来决定是否启用拖拽
  const enableDrag = isDragEnabled.value;

  try {
    // 更新拖拽节点行为
    graph.updateBehavior({
      key: "drag-node",
      enable: enableDrag
    });

    // 更新节点选择行为
    graph.updateBehavior({
      key: "click-select",
      enable: enableDrag
    });
    
    // 更新鼠标样式提示
    if (container.value) {
      container.value.style.cursor = enableDrag ? "default" : "not-allowed";
    }
    
    console.log(`拖拽行为已${enableDrag ? '启用' : '禁用'}, 创建模式: ${isCreateMode.value}`);
  } catch (err) {
    console.error("更新拖拽行为失败:", err);
  }
};

// 监听拖拽启用状态变化
watch(isDragEnabled, () => {
  updateDragBehavior();
});

// 切换连线模式
const toggleEdgeMode = () => {
  isEdgeMode.value = !isEdgeMode.value;

  if (!isEdgeMode.value) {
    // 退出连线模式时，如果有高亮的节点，取消高亮
    if (sourceNode.value) {
      // 使用G6 v5中的正确方法恢复节点样式
      graph.updateNodeData([
        {
          id: sourceNode.value,
          style: {
            fill: "#91d5ff", // 恢复默认颜色
            stroke: "#40a9ff"
          }
        }
      ]);
    }
    // 清空选中的源节点
    sourceNode.value = null;
  }

  // 更新鼠标样式和拖拽行为
  if (graph) {
    if (isEdgeMode.value) {
      // 进入连线模式，修改画布样式
      container.value.style.cursor = "crosshair";

      // 禁用拖拽节点行为
      graph.updateBehavior({
        key: "drag-node",
        enable: false
      });
    } else {
      // 退出连线模式时，调用updateDragBehavior
      // 这将根据侧边栏状态和管理员状态决定是否启用拖拽
      updateDragBehavior();
    }
  }
};

// 定时刷新设备数据
let refreshInterval = null;

// 启动定时刷新
const startDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
  }
  
  refreshInterval = setInterval(async () => {
    // 如果当前有选中的设备，刷新其数据
    if (selectedDevice.value && showControlPanel.value) {
      try {
        const updatedDevice = await fetchDeviceInfo(selectedDevice.value);
        if (updatedDevice) {
          // 只更新设备状态数据，不影响控制参数
          deviceData.value = updatedDevice;
          // 同时更新节点外观
          updateNodeAppearance(selectedDevice.value, updatedDevice.status);
        }
      } catch (error) {
        console.error("刷新设备数据失败:", error);
      }
    }
  }, 3000); // 每3秒刷新一次
};

// 停止定时刷新
const stopDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
};


// WebSocket连接状态
const wsConnected = ref(false);
const ws = ref(null);

// 调整图形大小的函数
const resizeGraph = () => {
  if (!graph || !container.value) return;
  
  const width = container.value.clientWidth;
  const height = container.value.clientHeight || 600;
  
  graph.setSize([width, height]);
  graph.render();
  console.log(`调整图形大小至 ${width}x${height}`);
};

// 修改WebSocket连接成功后的处理
const handleWsOpen = () => {
  console.log('WebSocket连接已建立');
  wsConnected.value = true;
  
  // 发送验证信息
  if (localStorage.token) {
    const authMessage = {
      type: 'authenticate',
      token: localStorage.token
    };
    sendWsMessage(authMessage);
  }
  
  // 连接成功后自动获取硬件状态
  setTimeout(() => {
    sendWsMessage({
      type: 'getHardwareStatus'
    });
    
    // 同时获取所有设备列表
    sendWsMessage({
      type: 'getDevices'
    });
  }, 500);
};

// 连接WebSocket服务器
const connectWebSocket = async () => {
  try {
    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
      console.log('WebSocket已连接');
      return;
    }
    
    // 关闭之前的连接
    if (ws.value) {
      manualClose.value = true;
      ws.value.close();
    }
    
    manualClose.value = false;
    
    console.log("尝试连接WebSocket服务器...");
    // 确定WebSocket连接地址
    const baseUrl = process.env.NODE_ENV === 'development'
      ? 'ws://localhost:3000'
      : window.location.origin.replace(/^http/, 'ws');
    const wsUrl = `${baseUrl}/api/devices/realtime`;
    
    ws.value = new WebSocket(wsUrl);
    
    ws.value.onopen = handleWsOpen;
    
    ws.value.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('收到WebSocket消息:', data);
        handleWsMessage(data);
      } catch (error) {
        console.error('WebSocket消息解析错误:', error);
      }
    };
    
    ws.value.onclose = (event) => {
      console.log('WebSocket连接已关闭', event.code, event.reason);
      wsConnected.value = false;

      // 如果不是用户主动关闭，则尝试重连
      if (!manualClose.value) {
        console.log("尝试重新连接...");
        setTimeout(connectWebSocket, 5000);
      }
    };

    ws.value.onerror = (error) => {
      console.error('WebSocket错误:', error);
      wsConnected.value = false;
      errorMessage.value = '无法连接到WebSocket服务器';
    };
  } catch (error) {
    console.error('创建WebSocket实例失败:', error);
    wsConnected.value = false;
    errorMessage.value = `创建WebSocket连接失败: ${error.message}`;
  }
};


// 更新设备状态
const updateDeviceStatus = (deviceData) => {
  // 首先更新全局设备仓库
  if (deviceData.id) {
    // 如果设备已存在，合并数据；否则添加新设备
    if (globalDevices.value.has(deviceData.id)) {
      const existingDevice = globalDevices.value.get(deviceData.id);
      
      // 检查是否有该设备的待发送更改
      const deviceKey = `${deviceData.type}_${deviceData.id}`;
      const hasPendingChanges = pendingChanges.value.has(deviceKey);
      
      // 合并设备数据，但保留待发送的本地修改
      const updatedDevice = {...existingDevice, ...deviceData};
      
      // 如果有待发送更改，保留用户编辑的值
      if (hasPendingChanges) {
        const pendingParams = pendingChanges.value.get(deviceKey).params;
        Object.keys(pendingParams).forEach(key => {
          updatedDevice[key] = pendingParams[key];
        });
      }
      
      globalDevices.value.set(deviceData.id, updatedDevice);
    } else {
      globalDevices.value.set(deviceData.id, deviceData);
    }
    
    // 更新图上的设备节点状态
    if (graph) {
      const node = graph.findById(deviceData.id);
      if (node) {
        // 更新节点状态
        graph.updateItem(node, {
          status: deviceData.status,
          ...deviceData
        });
      }
    }
    
    // 如果是当前选中的设备，从全局仓库获取最新数据更新控制面板
    if (selectedDevice.value === deviceData.id) {
      const updatedDeviceData = globalDevices.value.get(deviceData.id);
      // 深拷贝确保控制面板数据独立
      deviceData.value = JSON.parse(JSON.stringify(updatedDeviceData));
    }
  }
};

// 发送WebSocket消息
const sendWsMessage = (message) => {
  if (ws.value && ws.value.readyState === WebSocket.OPEN) {
    try {
      const messageStr = JSON.stringify(message);
      ws.value.send(messageStr);
      console.log("已发送WebSocket消息:", message);
      
      // 如果是设备控制命令，记录到全局设备仓库中以保持UI一致性
      if (message.type === 'updateDeviceParameters' && message.payload) {
        const commands = Array.isArray(message.payload) ? message.payload : [message.payload];
        
        commands.forEach(command => {
          if (command.id && globalDevices.value.has(command.id)) {
            // 根据命令更新全局设备状态
            const device = globalDevices.value.get(command.id);
            const updatedDevice = {...device};
            
            // 根据命令类型预测设备状态变化
            switch (command.action) {
              case 'start':
                updatedDevice.status = 'running';
                break;
              case 'stop':
                updatedDevice.status = 'idle';
                break;
              case 'setPosition':
                if (command.parameters && command.parameters.position !== undefined) {
                  updatedDevice.position = command.parameters.position;
                }
                break;
              case 'setTemp':
                if (command.parameters) {
                  if (command.parameters.temperature !== undefined) {
                    updatedDevice.targetTemp = command.parameters.temperature;
                    updatedDevice.status = 'heating';
                  }
                  if (command.parameters.speed !== undefined) {
                    updatedDevice.heatingSpeed = command.parameters.speed;
                  }
                }
                break;
              case 'setFlowRate':
                if (command.parameters && command.parameters.flowRate !== undefined) {
                  updatedDevice.flowRate = command.parameters.flowRate;
                }
                break;
              case 'setIntensity':
                if (command.parameters && command.parameters.intensity !== undefined) {
                  updatedDevice.intensity = command.parameters.intensity;
                }
                break;
              // 可以添加更多命令类型
            }
            
            // 更新参数
            if (command.parameters) {
              // 将命令参数合并到设备数据中
              Object.assign(updatedDevice, command.parameters);
            }
            
            // 更新全局设备仓库
            globalDevices.value.set(command.id, updatedDevice);
            
            // 如果是当前选中的设备，更新控制面板
            if (selectedDevice.value === command.id) {
              deviceData.value = JSON.parse(JSON.stringify(updatedDevice));
            }
            
            // 更新设备节点外观
            updateNodeAppearance(command.id, updatedDevice.status);
          }
        });
      }
      
      return true;
    } catch (error) {
      console.error("发送WebSocket消息失败:", error);
      return false;
    }
  } else {
    console.warn("WebSocket未连接，无法发送消息，当前状态:", ws.value ? ws.value.readyState : "无WebSocket实例");
    return false;
  }
};



// 是否手动关闭WebSocket连接
const manualClose = ref(false);

// 处理WebSocket消息
const handleWsMessage = (data) => {
  if (!data || !data.type) return;
  
  
  switch (data.type) {
    case 'connection':
      console.log("WebSocket连接成功:", data.data);
      break;
      
    case 'devices':
      // 收到所有设备列表
      if (data.data && Array.isArray(data.data)) {
        // 更新全局设备仓库
        data.data.forEach(device => {
          globalDevices.value.set(device.id, device);
        });
        console.log(`全局设备仓库已更新，共 ${globalDevices.value.size} 个设备`);
        
        // 如果已有选中的路径，加载设备到图中
        if (selectedPath.value) {
          (selectedPath.value);
        }
      }
      break;
      
    case 'deviceInfo':
      // 设备信息响应 - 单个设备的详细信息
      console.log("收到设备信息:", data.data);
      if (data.data && data.data.id) {
        // 更新设备节点外观
        updateDeviceOnGraph(data.data);
        
        // 如果是当前选中设备，更新控制面板
        if (selectedDevice.value === data.data.id) {
          deviceData.value = data.data;
        }
      }
      break;
      
    case 'commandResult':
      // 命令执行结果
      console.log("命令执行结果:", data.data);
      if (data.data && data.data.success) {
        // 命令成功，根据命令类型和参数更新本地设备状态
        const command = data.data.command;
        if (command && command.id) {
          // 如果命令中包含了更新后的设备数据，直接使用
          if (data.data.deviceData) {
            updateDeviceOnGraph(data.data.deviceData);
            
            // 如果是当前选中的设备，更新控制面板
            if (selectedDevice.value === command.id) {
              deviceData.value = data.data.deviceData;
            }
          } 
          // 否则，根据命令类型预测状态变化
          else if (command.type && command.action) {
            // 获取当前设备数据的副本
            let updatedDevice = null;
            
            // 如果是当前选中的设备，从deviceData中获取
            if (selectedDevice.value === command.id) {
              updatedDevice = { ...deviceData.value };
            } 
            // 否则尝试从图中获取
            else {
              try {
                const node = graph?.getNodeData?.(command.id);
                if (node && node.data && node.data.deviceData) {
                  updatedDevice = { ...node.data.deviceData };
                }
      } catch (err) {
                console.log("获取node数据失败:", err);
              }
            }
            
            // 如果找到了设备数据，根据命令更新状态
            if (updatedDevice) {
              // 根据命令类型和动作更新设备状态
              switch (command.type) {
                case 'pump':
                  switch (command.action) {
                    case 'start':
                      updatedDevice.status = 'running';
                      break;
                    case 'stop':
                      updatedDevice.status = 'stopped';
                      break;
                    case 'setSpeed':
                      if (command.parameters && command.parameters.speed !== undefined) {
                        updatedDevice.speed = command.parameters.speed;
                        updatedDevice.flowRate = (command.parameters.speed / 100) * 5; // 假设最大流速为5mL/min
                      }
                      break;
                  }
                  break;
                  
                case 'valve':
                  switch (command.action) {
                    case 'open':
                      updatedDevice.status = 'open';
                      updatedDevice.position = 100;
                      break;
                    case 'close':
                      updatedDevice.status = 'closed';
                      updatedDevice.position = 0;
                      break;
                    case 'setPosition':
                      if (command.parameters && command.parameters.position !== undefined) {
                        updatedDevice.position = command.parameters.position;
                        if (updatedDevice.position > 0) {
                          updatedDevice.status = 'open';
                        } else {
                          updatedDevice.status = 'closed';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'chip':
                  switch (command.action) {
                    case 'powerOn':
                      updatedDevice.status = 'heating';
                      updatedDevice.power = 50; // 默认50%功率
                      break;
                    case 'powerOff':
                      updatedDevice.status = 'idle';
                      updatedDevice.power = 0;
                      break;
                    case 'setTemp':
                      if (command.parameters && command.parameters.temperature !== undefined) {
                        updatedDevice.targetTemp = command.parameters.temperature;
                        if (updatedDevice.targetTemp > updatedDevice.currentTemp) {
                          updatedDevice.status = 'heating';
                        } else if (updatedDevice.targetTemp < updatedDevice.currentTemp) {
                          updatedDevice.status = 'cooling';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'mfc':
                  switch (command.action) {
                    case 'start':
                      updatedDevice.status = 'running';
                      break;
                    case 'stop':
                      updatedDevice.status = 'stopped';
                      break;
                    case 'setFlow':
                      if (command.parameters && command.parameters.flowRate !== undefined) {
                        updatedDevice.flowRate = command.parameters.flowRate;
                        if (updatedDevice.flowRate > 0) {
                          updatedDevice.status = 'running';
                        } else {
                          updatedDevice.status = 'stopped';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'light':
                  switch (command.action) {
                    case 'on':
                      updatedDevice.status = 'on';
                      break;
                    case 'off':
                      updatedDevice.status = 'off';
                      break;
                    case 'setIntensity':
                      if (command.parameters && command.parameters.intensity !== undefined) {
                        updatedDevice.intensity = command.parameters.intensity;
                        if (updatedDevice.intensity > 0) {
                          updatedDevice.status = 'on';
                        } else {
                          updatedDevice.status = 'off';
                        }
                      }
                      break;
                  }
                  break;
              }
              
              // 更新图上的设备状态
              updateDeviceOnGraph(updatedDevice);
              
              // 如果是当前选中设备，更新控制面板
              if (selectedDevice.value === command.id) {
                deviceData.value = updatedDevice;
              }
            }
          }
        }
      }
      isLoading.value = false;
      break;
      
    case 'parameterUpdateResults':
      // 批量参数更新结果
      console.log("收到参数更新结果:", data.data);
      
      // 处理批量结果
      if (data.data) {
        // 使用后端提供的统计数据
        const { results, totalCommands, successCount, failedCount, message, actualSentCommands } = data.data;
        
        // 如果有消息字段，说明是特殊情况（如所有参数都是最新状态）
        if (message) {
          console.log(message);
          // 显示信息提示
          ElMessage.info(message);
          isLoading.value = false;
          isCommandSending.value = false;
          pendingChanges.value.clear();
          return;
        }
        
        // 处理每个设备的更新结果
        if (Array.isArray(results)) {
          const errorMessages = [];
          
          // 处理每个设备的更新结果
          results.forEach(result => {
            if (result.success) {
              // 如果包含了更新后的设备数据，直接使用
              if (result.deviceData) {
                // 更新全局设备仓库
                if (result.deviceData.id) {
                  globalDevices.value.set(result.deviceData.id, result.deviceData);
                }
                
                // 更新设备节点外观
                updateDeviceOnGraph(result.deviceData);
                
                // 如果是当前选中的设备，更新控制面板
                if (selectedDevice.value === result.deviceData.id) {
                  deviceData.value = result.deviceData;
                }
              }
              // 否则使用设备ID从全局仓库获取并预测更新
              else if (result.id) {
                // 尝试从全局设备仓库获取设备
                if (globalDevices.value.has(result.id)) {
                  const device = globalDevices.value.get(result.id);
                  
                  // 更新全局设备仓库 - 这里不做具体更改，等待后端推送最新状态
                  // 只是标记设备状态有变化
                  const updatedDevice = { ...device, _updated: true };
                  globalDevices.value.set(result.id, updatedDevice);
                  
                  // 更新设备节点外观
                  updateDeviceOnGraph(updatedDevice);
                  
                  // 如果是当前选中的设备，更新控制面板
                  if (selectedDevice.value === result.id) {
                    deviceData.value = updatedDevice;
                  }
                }
              }
            } else {
              // 更新失败，收集错误消息
              if (result.error) {
                errorMessages.push(`${result.id || '未知设备'}: ${result.error}`);
              }
            }
          });
          
          // 显示结果通知
          if (failedCount === 0) {
            // 全部成功
            if (actualSentCommands < totalCommands) {
              // 有些命令被优化掉了（参数无变化）
              ElMessage.success(`已成功更新${successCount}个设备参数，${totalCommands - actualSentCommands}个无需更新`);
            } else {
              // 所有命令都发送了
              ElMessage.success(`已成功更新${successCount}个设备参数`);
            }
          } else {
            // 有失败的情况
            console.error(`${failedCount}个参数更新失败，${successCount}个成功`);
            
            // 显示详细错误信息
            if (errorMessages.length > 0) {
              const errorMsg = errorMessages.length > 3 
                ? `${errorMessages.slice(0, 3).join('\n')}...等${errorMessages.length}个错误` 
                : errorMessages.join('\n');
              ElMessage.error(`参数更新失败: ${errorMsg}`);
              errorMessage.value = `参数更新失败: ${errorMsg}`;
            } else {
              ElMessage.error(`${failedCount}个参数更新失败，${successCount}个成功`);
              errorMessage.value = `${failedCount}个参数更新失败，${successCount}个成功`;
            }
          }
        }
      }
      
      // 重置加载和发送状态
      isLoading.value = false;
      isCommandSending.value = false;
      
      // 清空待发送参数队列
      pendingChanges.value.clear();
      
      break;
      
    case 'error':
      // 错误消息
      console.error("服务器错误:", data.data);
      errorMessage.value = data.data.message;
      isLoading.value = false;
      break;

    case 'hardwareConnection':
      // 硬件连接状态
      isHardwareConnecting.value = false;
      if (data.data.success) {
        console.log("已连接到硬件:", data.data.ipAddress || data.data.portPath);
        isHardwareConnected.value = true;
        hardwareErrorMessage.value = '';
        ElMessage.success('硬件设备连接成功');
      } else {
        const errorMsg = data.data.error || '无法连接硬件设备';
        console.error("硬件连接失败:", errorMsg);
        hardwareErrorMessage.value = errorMsg;
        isHardwareConnected.value = false;
        ElMessage.error(`硬件连接失败: ${errorMsg}`);
      }
      isLoading.value = false;
      break;
      
    case 'serverStatus':
      // 服务器状态信息
      console.log("服务器状态:", data.data);
      isHardwareConnected.value = data.data.connected;
      if (!data.data.connected) {
        hardwareIP.value = data.data.lastIpAddress || '192.168.1.14';
      }
      break;
      
    case 'hardwareStatus':
      // 硬件连接状态信息
      console.log("硬件状态:", data.data);
      isHardwareConnected.value = data.data.connected;
      isHardwareConnecting.value = false;
      
      // 如果已连接到硬件，更新UI状态
      if (data.data.connected) {
        console.log('已成功连接到硬件');
        hardwareErrorMessage.value = '';
        // 如果有IP地址信息，更新显示
        if (data.data.ip) {
          hardwareIP.value = data.data.ip;
        }
        
        // 显示成功通知（但避免频繁通知）
        if (isHardwareConnecting.value) {
          ElMessage.success('成功连接到硬件设备');
        }
      } else {
        console.warn('未连接到硬件');
        // 如果有失败原因，显示
        if (data.data.error) {
          hardwareErrorMessage.value = data.data.error;
          
          // 如果正在连接中，才显示错误通知
          if (isHardwareConnecting.value) {
            ElMessage.error(`连接硬件失败: ${data.data.error}`);
          }
        }
      }
      
      // 无论如何都结束连接状态
      isHardwareConnecting.value = false;
      break;
      
    case 'deviceStatus':
      // 来自硬件的设备状态数据
      console.log(`收到来自控制器${data.controllerId}的设备状态更新:`, data.devices);
      
      // 更新设备状态
      if (data.devices && Array.isArray(data.devices)) {
        data.devices.forEach(device => {
          updateDeviceStatus(device);
        });
      }
      break;
      
    default:
      console.warn("未知的WebSocket消息类型:", data.type);
      break;
  }
};

// 加载保存的硬件结构列表
const loadSavedPaths = async () => {
  try {
    isLoading.value = true;
    
    // 确定API基础URL
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 从后端API获取自定义硬件结构列表
    console.log("从后端API获取硬件结构列表...");
    try {
      const response = await axios.get(`${baseUrl}/api/devices/path`);
      
      if (response.data.code === 0 && response.data.data) {
        // 更新保存的路径列表
        savedPaths.value = response.data.data;
        console.log("从API加载了", savedPaths.value.length, "个保存的硬件结构");
        
        // 更新localStorage
        localStorage.setItem('savedReactionPaths', JSON.stringify(savedPaths.value));
      } else {
        console.warn("API返回错误或无效数据:", response.data);
        
        // 尝试从localStorage加载作为备用
        loadFromLocalStorage();
      }
    } catch (apiError) {
      console.error("从API加载路径列表失败:", apiError);
      errorMessage.value = `无法从服务器加载硬件结构列表: ${apiError.message}`;
      
      // 尝试从localStorage加载作为备用
      loadFromLocalStorage();
    }
  } catch (error) {
    console.error("加载保存的硬件结构列表失败:", error);
    
    // 重置为空数组，确保UI不会崩溃
    savedPaths.value = [];
  } finally {
    isLoading.value = false;
  }
};

// 从本地存储加载硬件结构列表
const loadFromLocalStorage = () => {
  // 从localStorage加载
  const savedPathsJson = localStorage.getItem('savedReactionPaths');
  if (savedPathsJson) {
    try {
      savedPaths.value = JSON.parse(savedPathsJson);
      console.log("从本地存储加载了", savedPaths.value.length, "个保存的硬件结构");
    } catch (parseError) {
      console.error("解析本地存储的路径列表失败:", parseError);
      // 如果JSON解析失败，重置为空数组
      savedPaths.value = [];
      localStorage.removeItem('savedReactionPaths');
    }
  } else {
    savedPaths.value = [];
  }
};


// 删除当前选中的路径
const deleteReactionPath = async () => {
  try {
    if (!pathToDelete.value) {
      console.error("没有选中要删除的路径");
      return;
    }
    
    isLoading.value = true;
    
    // 使用服务器的完整URL
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 调用API删除路径 - 使用新的API路径
    const pathId = pathToDelete.value.id || pathToDelete.value.name;
    const response = await axios.delete(`${baseUrl}/api/devices/path/${encodeURIComponent(pathId)}`);
    
    console.log("删除路径响应:", response);
    
    if (response.data.code === 0) {
      // 从本地路径列表中移除
      savedPaths.value = savedPaths.value.filter(p => p.name !== pathToDelete.value.name);
      
      // 更新localStorage
      localStorage.setItem('savedReactionPaths', JSON.stringify(savedPaths.value));
      
      // 如果当前选择的是被删除的路径，清空选择
      if (selectedPath.value && selectedPath.value.name === pathToDelete.value.name) {
        selectedPath.value = null;
        // 清空图
        graph?.clear();
        graph?.render();
      }
      
      alert(`硬件结构 "${pathToDelete.value.name}" 已成功删除`);
    } else {
      throw new Error(response.data.msg || '删除失败');
    }
  } catch (error) {
    console.error("删除硬件结构失败:", error);
    let errorMsg = '';
    
    if (error.response) {
      // 服务器响应了错误状态码
      errorMsg = `服务器错误 (${error.response.status}): ${error.response.data?.msg || error.message}`;
    } else if (error.request) {
      // 请求发送了但没有收到响应
      errorMsg = '没有收到服务器响应，请检查网络或服务器状态';
    } else {
      // 设置请求时发生错误
      errorMsg = error.message;
    }
    
    errorMessage.value = `删除硬件结构失败: ${errorMsg}`;
  } finally {
    isLoading.value = false;
    isShowDeletePathDialog.value = false;
    pathToDelete.value = null;
  }
};

// 组件挂载完成后初始化图表
onMounted(async () => {
  try {
    console.log("组件挂载完成");
    
    // 确保侧边栏打开
    isSidebarOpen.value = true;
    
    // 初始化G6 v5图
    const graphWidth = container.value.clientWidth;
    const graphHeight = container.value.clientHeight || 600;
    
    console.log(`初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
    console.log("isDragEnabled", isDragEnabled.value);
    
    // 创建图形实例
    graph = new Graph({
      container: container.value,
      width: graphWidth,
      height: graphHeight,
      behaviors: [
        {
          type: 'drag-canvas',
          key: 'drag-canvas',
          enable: false // 禁用画布拖拽，避免与节点拖拽冲突
        },
        {
          type: 'zoom-canvas',
          sensitivity: 1.5, // 配置灵敏度
          key: 'zoom-canvas',
          enable: true
        },
        {
          type: 'click-select',
          key: 'click-select',
          enable: true
        },
        {
          type: 'drag-element', // 节点拖拽行为
          key: 'drag-element',
          enable: true, // 始终启用节点拖拽
          shouldBegin: (e) => {
            // 只在创建模式下允许拖拽节点
            return isCreateMode.value && isAdmin.value;
          },
          shouldUpdate: (e) => {
            // 记录拖拽开始位置
            if (e.type === 'dragstart') {
              const nodeId = e.item.get('id');
              if (nodeId) {
                const nodeData = graph.getNodeData(nodeId);
                if (nodeData && nodeData.style) {
                  dragInfo.isDragging = true;
                  dragInfo.nodeId = nodeId;
                  dragInfo.startPosition = { 
                    x: parseFloat(nodeData.style.x) || 0, 
                    y: parseFloat(nodeData.style.y) || 0 
                  };
                  console.log(`拖拽开始，记录节点 ${nodeId} 初始位置:`, dragInfo.startPosition);
                }
              }
            }
            // 总是允许更新
            return true;
          },
          onEnd: (e) => {
            // 拖拽结束时记录历史
            if (dragInfo.isDragging && dragInfo.nodeId) {
              const nodeData = graph.getNodeData(dragInfo.nodeId);
              if (nodeData && nodeData.style) {
                const finalPosition = {
                  x: parseFloat(nodeData.style.x) || 0,
                  y: parseFloat(nodeData.style.y) || 0
                };
                
                // 如果位置有明显变化
                if (Math.abs(finalPosition.x - dragInfo.startPosition.x) > 1 || 
                    Math.abs(finalPosition.y - dragInfo.startPosition.y) > 1) {
                  
                  console.log(`拖拽结束，节点 ${dragInfo.nodeId} 从`, 
                    dragInfo.startPosition, 
                    "移动到", finalPosition);
                  
                  // 记录到历史
                  addToHistory({
                    type: 'moveNode',
                    nodeId: dragInfo.nodeId,
                    oldPosition: { ...dragInfo.startPosition },
                    newPosition: { ...finalPosition }
                  });
                }
                
                // 重置拖拽状态
                dragInfo.isDragging = false;
                dragInfo.nodeId = null;
              }
            }
          },
          updateEdge: true, // 拖拽时更新关联的边
          delegateStyle: {
            fillOpacity: 0.4,
            fill: '#91d5ff',
            stroke: '#1890ff'
          }
        }
      ],
    });
    
    // 注册节点点击事件
    graph.on('node:click', (e) => {
      // 原有的处理逻辑
      handleDeviceClick(e);
    });
    
    // 加载保存的硬件结构列表和现有设备
    await loadSavedPaths();
    
    // 启动设备数据刷新
    startDeviceDataRefresh();
    
    // 处理窗口大小变化 - 带防抖
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resizeGraph();
      }, 200);
    });
    
    // 延迟建立WebSocket连接，确保其他组件准备就绪
    setTimeout(() => {
      // 建立WebSocket连接
      connectWebSocket();
    }, 500);
    
    // 添加键盘快捷键监听
    window.addEventListener('keydown', handleKeyboardShortcuts);
    
    // 添加消息监听
    window.addEventListener('message', (event) => {
      try {
        console.log('收到postMessage消息:', event.data);
      } catch (error) {
        console.error('处理postMessage消息失败:', error);
        errorMessage.value = `处理消息失败: ${error.message}`;
      }
    });
    console.log("组件初始化完成");
    
    // 连接WebSocket
    await connectWebSocket();
    
    // 请求当前硬件状态
    if (wsConnected.value) {
<template>
  <div class="main-container">
    <!-- 侧边栏控制按钮 - 无论何种模式都显示 -->
    <button
      class="sidebar-toggle"
      :class="{
        'toggle-framework-collapsed': !appSidebarOpened
      }"
      @click="isSidebarOpen = !isSidebarOpen"
    >
      {{ isSidebarOpen ? "◀" : "▶" }}
    </button>

    <!-- 工具栏 - 只保留创建硬件结构功能 -->
    <div class="toolbar">
      <!-- 创建反应路径按钮 -->
          <button 
        v-if="isAdmin"
        class="tool-button" 
        :class="{ 'active': isCreateMode }"
        @click="isCreateMode ? exitCreateMode() : enterCreateMode()"
      >
        {{ isCreateMode ? '退出创建模式' : '创建硬件结构' }}
      </button>
      
      <!-- 保存反应路径按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button save-button"
        @click="openSaveDialog"
      >
        保存硬件结构
      </button>
      
      <!-- 撤销操作按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button undo-button"
        @click="undoLastOperation"
        :disabled="operationHistory.length === 0"
        title="撤销上一步操作 (Ctrl+Z)"
      >
        撤销上一步 <span v-if="operationHistory.length > 0" class="operation-count">({{ operationHistory.length }})</span>
      </button>
    </div>

    <!-- 创建模式侧边栏 - 仅在创建模式下显示 -->
    <div
      v-if="isAdmin && isCreateMode"
      class="sidebar create-mode-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>创建硬件结构</h3>
      
      <!-- 设备图标拖拽区 -->
      <div class="icons-container">
        <h4>可用设备</h4>
        <div
          v-for="(icon, index) in nodeIcons"
          :key="index"
          class="icon-item"
          draggable="true"
          :data-type="icon.type"
          @dragstart="e => handleDragStart(e, icon)"
          @dragend="handleDragEnd"
        >
          <img :src="icon.src" class="icon-image" />
          <span>{{ icon.label }}</span>
        </div>
      </div>

      <!-- 连线模式按钮 - 仅在创建模式中显示 -->
      <div class="edge-mode-container">
      <button 
          class="edge-mode-button"
          :class="{ active: isEdgeMode }"
          title="连线模式"
          @click="toggleEdgeMode"
        >
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path
              d="M3,3 L9,9 M15,15 L21,21"
              stroke="currentColor"
              stroke-width="2"
              fill="none"
            />
            <circle cx="8" cy="8" r="4" fill="currentColor" />
            <circle cx="16" cy="16" r="4" fill="currentColor" />
          </svg>
          <span>连线模式</span>
      </button>
      </div>
    </div>

    <!-- 选择反应路径侧边栏 - 在非创建模式下显示 -->
    <div
      v-if="!isCreateMode"
      class="sidebar path-selector-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>选择硬件结构</h3>
      
      <!-- 用户保存的硬件结构 -->
      <div v-if="savedPaths.length > 0" class="path-section">
        <h4>自定义结构</h4>
        <div class="path-options">
          <div 
            v-for="path in savedPaths" 
            :key="path.name"
            class="path-option custom-path"
            :class="{ 'selected': selectedPath && selectedPath.name === path.name }"
          >
            <span @click="loadStructureFromFile(path)">{{ path.name }}</span>
        <button 
              class="delete-path-btn" 
              title="删除此路径"
              @click.stop="openDeletePathDialog(path)"
            >×</button>
          </div>
        </div>
      </div>
      
      <!-- 图标说明区域 -->
      <div class="icons-legend-section">
        <h4>设备图标说明</h4>
        <div class="icons-legend">
          <div class="legend-item">
            <img :src="pump" class="legend-icon" />
            <span>泵 - 用于精确控制液体流动</span>
          </div>
          <div class="legend-item">
            <img :src="valve" class="legend-icon" />
            <span>阀门 - 控制流体通道的开关</span>
          </div>
          <div class="legend-item">
            <img :src="chip" class="legend-icon" />
            <span>加热芯片 - 控制反应温度</span>
          </div>
          <div class="legend-item">
            <img :src="bottle" class="legend-icon" />
            <span>瓶 - 存储反应物或产物</span>
          </div>
          <div class="legend-item">
            <img :src="mfc" class="legend-icon" />
            <span>MFC控制器 - 控制气体流量</span>
          </div>
          <div class="legend-item">
            <img :src="light" class="legend-icon" />
            <span>光照控制 - 提供光催化条件</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">加载中...</div>
    </div>
    
    <!-- 错误提示 -->
    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
      <button class="close-error-btn" @click="errorMessage = ''">×</button>
    </div>

    <!-- G6 画布容器 -->
    <div
      ref="container"
      class="graph-container"
      :class="{
        'graph-container-full': !isSidebarOpen,
        'graph-container-collapsed': !appSidebarOpened && isSidebarOpen,
        'drag-disabled': !isDragEnabled,
        'create-mode': isCreateMode
      }"
      @dragover.prevent="isCreateMode ? $event.preventDefault() : null"
      @drop="isCreateMode ? handleDrop($event) : null"
    />

    <!-- 设备控制面板 -->
    <div v-if="showControlPanel" class="device-control-panel">
      <div class="panel-content">
        <!-- 设备ID和状态 -->
        <div class="device-info">
          <div class="device-header">
            <div class="device-title">设备控制: {{ deviceData.id }}</div>
            <div class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
              {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
            </div>
          <button class="close-btn" @click="closeControlPanel">×</button>
          </div>
          <div class="device-status" :class="deviceData.status">
            状态: {{ translateStatus(deviceData.status) }}
          </div>
        </div>

        <!-- 泵控制 -->
        <div v-if="deviceData.type === 'pump'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前速度:</span>
              <span class="status-value">{{ deviceData.speed }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">当前位置:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">吸取端口:</span>
              <span class="status-value">{{ deviceData.aspiratePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">输送端口:</span>
              <span class="status-value">{{ deviceData.dispensePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
        </div>

        <!-- 阀门控制 -->
        <div v-if="deviceData.type === 'valve'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前孔位:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">产品收集阀:</span>
              <span class="status-value">{{ deviceData.isProductValve ? '是' : '否' }}</span>
            </div>
          </div>
        </div>

        <!-- 加热芯片控制 -->
        <div v-if="deviceData.type === 'chip'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前温度:</span>
              <span class="status-value">{{ deviceData.currentTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">目标温度:</span>
              <span class="status-value">{{ deviceData.targetTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">加热速度:</span>
              <span class="status-value">{{ deviceData.heatingSpeed }}</span>
            </div>
          </div>
        </div>

        <!-- MFC控制 -->
        <div v-if="deviceData.type === 'mfc'" class="device-controls">
<template>
  <div class="main-container">
    <!-- 侧边栏控制按钮 - 无论何种模式都显示 -->
    <button
      class="sidebar-toggle"
      :class="{
        'toggle-framework-collapsed': !appSidebarOpened
      }"
      @click="isSidebarOpen = !isSidebarOpen"
    >
      {{ isSidebarOpen ? "◀" : "▶" }}
    </button>

    <!-- 工具栏 - 只保留创建硬件结构功能 -->
    <div class="toolbar">
      <!-- 创建反应路径按钮 -->
      <button 
        v-if="isAdmin"
        class="tool-button" 
        :class="{ 'active': isCreateMode }"
        @click="isCreateMode ? exitCreateMode() : enterCreateMode()"
      >
        {{ isCreateMode ? '退出创建模式' : '创建硬件结构' }}
      </button>
      
      <!-- 保存反应路径按钮，仅在创建模式下显示 -->
      <button 
        v-if="isAdmin && isCreateMode" 
          class="tool-button save-button"
        @click="openSaveDialog"
        >
        保存硬件结构
        </button>
      
      <!-- 撤销操作按钮，仅在创建模式下显示 -->
        <button 
        v-if="isAdmin && isCreateMode" 
        class="tool-button undo-button"
        @click="undoLastOperation"
        :disabled="operationHistory.length === 0"
        title="撤销上一步操作 (Ctrl+Z)"
      >
        撤销上一步 <span v-if="operationHistory.length > 0" class="operation-count">({{ operationHistory.length }})</span>
        </button>
      </div>

    <!-- 创建模式侧边栏 - 仅在创建模式下显示 -->
    <div
      v-if="isAdmin && isCreateMode"
      class="sidebar create-mode-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>创建硬件结构</h3>
      
      <!-- 设备图标拖拽区 -->
      <div class="icons-container">
        <h4>可用设备</h4>
        <div
          v-for="(icon, index) in nodeIcons"
          :key="index"
          class="icon-item"
          draggable="true"
          :data-type="icon.type"
          @dragstart="e => handleDragStart(e, icon)"
          @dragend="handleDragEnd"
        >
          <img :src="icon.src" class="icon-image" />
          <span>{{ icon.label }}</span>
        </div>
      </div>

      <!-- 连线模式按钮 - 仅在创建模式中显示 -->
      <div class="edge-mode-container">
        <button
          class="edge-mode-button"
          :class="{ active: isEdgeMode }"
          title="连线模式"
          @click="toggleEdgeMode"
        >
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path
              d="M3,3 L9,9 M15,15 L21,21"
              stroke="currentColor"
              stroke-width="2"
              fill="none"
            />
            <circle cx="8" cy="8" r="4" fill="currentColor" />
            <circle cx="16" cy="16" r="4" fill="currentColor" />
          </svg>
          <span>连线模式</span>
        </button>
      </div>
    </div>

    <!-- 选择反应路径侧边栏 - 在非创建模式下显示 -->
    <div
      v-if="!isCreateMode"
      class="sidebar path-selector-sidebar"
      :class="{
        'sidebar-collapsed': !appSidebarOpened,
        'sidebar-hidden': !isSidebarOpen
      }"
    >
      <h3>选择硬件结构</h3>
      
      <!-- 用户保存的硬件结构 -->
      <div v-if="savedPaths.length > 0" class="path-section">
        <h4>自定义结构</h4>
        <div class="path-options">
          <div 
            v-for="path in savedPaths" 
            :key="path.name"
            class="path-option custom-path"
            :class="{ 'selected': selectedPath && selectedPath.name === path.name }"
          >
            <span @click="loadStructureFromFile(path)">{{ path.name }}</span>
            <button 
              class="delete-path-btn" 
              title="删除此路径"
              @click.stop="openDeletePathDialog(path)"
            >×</button>
          </div>
        </div>
      </div>
      
      <!-- 图标说明区域 -->
      <div class="icons-legend-section">
        <h4>设备图标说明</h4>
        <div class="icons-legend">
          <div class="legend-item">
            <img :src="pump" class="legend-icon" />
            <span>泵 - 用于精确控制液体流动</span>
          </div>
          <div class="legend-item">
            <img :src="valve" class="legend-icon" />
            <span>阀门 - 控制流体通道的开关</span>
          </div>
          <div class="legend-item">
            <img :src="chip" class="legend-icon" />
            <span>加热芯片 - 控制反应温度</span>
          </div>
          <div class="legend-item">
            <img :src="bottle" class="legend-icon" />
            <span>瓶 - 存储反应物或产物</span>
          </div>
          <div class="legend-item">
            <img :src="mfc" class="legend-icon" />
            <span>MFC控制器 - 控制气体流量</span>
          </div>
          <div class="legend-item">
            <img :src="light" class="legend-icon" />
            <span>光照控制 - 提供光催化条件</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">加载中...</div>
    </div>
    
    <!-- 错误提示 -->
    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
      <button class="close-error-btn" @click="errorMessage = ''">×</button>
    </div>

    <!-- G6 画布容器 -->
    <div
      ref="container"
      class="graph-container"
      :class="{
        'graph-container-full': !isSidebarOpen,
        'graph-container-collapsed': !appSidebarOpened && isSidebarOpen,
        'drag-disabled': !isDragEnabled,
        'create-mode': isCreateMode
      }"
      @dragover.prevent="isCreateMode ? $event.preventDefault() : null"
      @drop="isCreateMode ? handleDrop($event) : null"
    />

    <!-- 设备控制面板 -->
    <div v-if="showControlPanel" class="device-control-panel">
      <div class="panel-content">
        <!-- 设备ID和状态 -->
        <div class="device-info">
          <div class="device-header">
            <div class="device-title">设备控制: {{ deviceData.id }}</div>
            <div class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
              {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
            </div>
          <button class="close-btn" @click="closeControlPanel">×</button>
          </div>
          <div class="device-status" :class="deviceData.status">
            状态: {{ translateStatus(deviceData.status) }}
          </div>
        </div>

        <!-- 泵控制 -->
        <div v-if="deviceData.type === 'pump'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前速度:</span>
              <span class="status-value">{{ deviceData.speed }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">当前位置:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">吸取端口:</span>
              <span class="status-value">{{ deviceData.aspiratePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">输送端口:</span>
              <span class="status-value">{{ deviceData.dispensePort }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="data-row">
              <span>吸取端口:</span>
              <select 
                v-model.number="controlParams.aspiratePort" 
                @change="updateParameter(deviceData.id, 'pump', 'aspiratePort', controlParams.aspiratePort)"
                class="parameter-select"
              >
                <option value="1">端口1</option>
                <option value="2">端口2</option>
                <option value="3">端口3</option>
                <option value="4">端口4</option>
                <option value="5">端口5</option>
                <option value="6">端口6</option>
              </select>
            </div>
            
            <div class="data-row">
              <span>输送端口:</span>
              <select 
                v-model.number="controlParams.dispensePort" 
                @change="updateParameter(deviceData.id, 'pump', 'dispensePort', controlParams.dispensePort)"
                class="parameter-select"
              >
                <option value="1">端口1</option>
                <option value="2">端口2</option>
                <option value="3">端口3</option>
                <option value="4">端口4</option>
                <option value="5">端口5</option>
                <option value="6">端口6</option>
              </select>
            </div>
            
            <div class="data-row">
              <span>速度:</span>
              <input
                v-model.number="controlParams.speed"
                type="number"
                min="0"
                max="1000"
                class="parameter-input"
              />
              <button
                @click="updateParameter(deviceData.id, 'pump', 'speed', controlParams.speed)"
              >
                设置
              </button>
            </div>
            
            <div class="data-row">
              <span>位置:</span>
              <input
                v-model.number="controlParams.position"
                type="number"
                min="0"
                max="10000"
                class="parameter-input"
              />
              <button
                @click="updateParameter(deviceData.id, 'pump', 'position', controlParams.position)"
              >
                设置
              </button>
            </div>
            
            <div class="control-row">
              <button
                @click="updateParameter(deviceData.id, 'pump', 'initialize', controlParams.initialize)"
              >
                初始化
              </button>
              <button
                @click="updateParameter(deviceData.id, 'pump', 'stop', controlParams.stop)"
              >
                停止
              </button>
            </div>
          </div>
        </div>

        <!-- 阀门控制 -->
        <div v-if="deviceData.type === 'valve'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前孔位:</span>
              <span class="status-value">{{ deviceData.position }}</span>
            </div>
            <div class="status-row">
              <span class="status-label">产品收集阀:</span>
              <span class="status-value">{{ deviceData.isProductValve ? '是' : '否' }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="control-row">
              <span>孔位:</span>
              <select v-model.number="controlParams.position" class="parameter-select">
                <option v-for="n in 6" :key="n" :value="n">孔位{{ n }}</option>
              </select>
              <button
                @click="updateParameter(deviceData.id, 'valve', 'position', controlParams.position)"
              >
                设置孔位
              </button>
            </div>
            <div class="control-row">
              <span>产品收集阀:</span>
              <div class="toggle-switch">
                <input
                  type="checkbox"
                  :id="`product-toggle-${deviceData.id}`"
                  v-model="controlParams.isProductValve"
                  @change="updateParameter(deviceData.id, 'valve', 'isProductValve', controlParams.isProductValve)"
                />
                <label :for="`product-toggle-${deviceData.id}`">{{ controlParams.isProductValve ? '是' : '否' }}</label>
              </div>
              <div class="valve-info" v-if="controlParams.isProductValve">
                (反应稳定后才会切换)
              </div>
            </div>
          </div>
        </div>

        <!-- 加热芯片控制 -->
        <div v-if="deviceData.type === 'chip'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前温度:</span>
              <span class="status-value">{{ deviceData.currentTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">目标温度:</span>
              <span class="status-value">{{ deviceData.targetTemp }}°C</span>
            </div>
            <div class="status-row">
              <span class="status-label">加热速度:</span>
              <span class="status-value">{{ deviceData.heatingSpeed }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="data-row">
              <span>目标温度:</span>
              <input
                v-model.number="controlParams.targetTemp"
                type="number"
                min="0"
                max="300"
                class="parameter-input"
              />
              <span class="unit">°C</span>
            </div>
            <div class="data-row">
              <span>加热速度:</span>
              <input
                v-model.number="controlParams.heatingSpeed"
                type="number"
                min="1"
                max="10"
                class="parameter-input"
              />
              <span class="unit"></span>
            </div>
            <div class="control-row">
              <button
                @click="updateParameter(deviceData.id, 'chip', 'setTemp', controlParams.targetTemp), updateParameter(deviceData.id, 'chip', 'speed', controlParams.heatingSpeed)"
              >
                设置
              </button>
            </div>
          </div>
        </div>

        <!-- MFC控制 -->
        <div v-if="deviceData.type === 'mfc'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前流速:</span>
              <span class="status-value">{{ deviceData.flowRate }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="data-row">
              <span>流速设置:</span>
              <input
                v-model.number="controlParams.flowRate"
                type="number"
                min="0"
                max="100"
                class="parameter-input"
              />
              <span class="unit">ml/min</span>
              <button
                @click="updateParameter(deviceData.id, 'mfc', 'setFlowRate', controlParams.flowRate)"
              >
                设置流速
              </button>
            </div>
          </div>
        </div>

        <!-- 光照控制 -->
        <div v-if="deviceData.type === 'light'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">当前光强:</span>
              <span class="status-value">{{ deviceData.intensity }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="data-row">
              <span>光强设置:</span>
              <input
                v-model.number="controlParams.intensity"
                type="number"
                min="0"
                max="100"
                class="parameter-input"
              />
              <span class="unit">%</span>
              <button
                @click="updateParameter(deviceData.id, 'light', 'setIntensity', controlParams.intensity)"
              >
                设置光强
              </button>
            </div>
          </div>
        </div>

        <!-- 瓶控制 -->
        <div v-if="deviceData.type === 'bottle'" class="device-controls">
          <!-- 当前状态区域 -->
          <div class="current-status-section">
            <div class="section-title">当前状态</div>
            <div class="status-row">
              <span class="status-label">反应物:</span>
              <span class="status-value">{{ deviceData.reactant || '未设置' }}</span>
            </div>
          </div>
          
          <!-- 控制区域 -->
          <div class="control-section">
            <div class="section-title">参数调整</div>
            <div class="control-row">
              <label for="reactant">反应物:</label>
              <input
                id="reactant"
                v-model="controlParams.reactant"
                type="text"
                placeholder="输入反应物名称"
                class="reactant-input"
              />
              <button
                @click="updateBottle(deviceData.id, 'reactant', controlParams.reactant)"
              >
                设置
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 保存路径名称对话框 -->
    <div v-if="isShowPathNameDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>保存硬件结构</h3>
        <div class="dialog-form">
          <label for="pathName">名称</label>
          <input 
            id="pathName"
            v-model="pathName"
            type="text"
            placeholder="请输入硬件结构名称"
            @keyup.enter="saveCurrentPath"
          />
        </div>
        <div class="dialog-buttons">
          <button @click="isShowPathNameDialog = false">取消</button>
          <button class="primary-button" @click="saveCurrentPath">保存</button>
        </div>
      </div>
    </div>

    <!-- 删除路径确认对话框 -->
    <div v-if="isShowDeletePathDialog" class="dialog-overlay">
      <div class="dialog-content">
        <h3>删除硬件结构</h3>
        <div class="dialog-form">
          <p>确定要删除硬件结构 "{{ pathToDelete?.name }}" 吗？此操作不可恢复。</p>
          <p class="warning-text">此操作不可恢复！</p>
        </div>
        <div class="dialog-buttons">
          <button @click="isShowDeletePathDialog = false">取消</button>
          <button class="danger-button" @click="deleteReactionPath">删除</button>
        </div>
      </div>
    </div>

    <!-- WebSocket连接状态 -->
    <div class="ws-status" :class="{ 'connected': wsConnected }">
      <span v-if="wsConnected">已连接到服务器</span>
      <span v-else>未连接到服务器</span>
    </div>

    <!-- WebSocket连接状态指示器 -->
    <div class="websocket-status-container" :class="{ 'ws-connected': wsConnected, 'ws-disconnected': !wsConnected }">
      <div class="status-indicator"></div>
      <span class="status-text">{{ wsConnected ? 'WebSocket已连接' : 'WebSocket未连接' }}</span>
      <div v-if="!wsConnected" class="reconnect-controls">
        <el-tooltip effect="dark" placement="bottom">
          <template #content>
            <div>
              <p>可能的原因:</p>
              <ul>
                <li>后端服务未启动</li>
                <li>网络连接问题</li>
                <li>跨域策略限制</li>
              </ul>
              <p>排查步骤:</p>
              <ul>
                <li>确保后端服务在端口3000运行</li>
                <li>查看浏览器控制台错误信息</li>
                <li>检查浏览器网络请求</li>
              </ul>
            </div>
          </template>
          <el-button type="warning" size="small" icon="Warning">连接失败原因</el-button>
        </el-tooltip>
        <el-button type="primary" size="small" @click="reconnectWebSocket">重新连接</el-button>
      </div>
      <div v-if="wsConnected" class="connection-info">
        <span class="data-source-indicator" :class="{ 'connected': isHardwareConnected, 'disconnected': !isHardwareConnected }">
          {{ isHardwareConnected ? '已连接到硬件设备' : '硬件设备未连接' }}
        </span>
      </div>
    </div>

    <!-- 添加硬件连接控制面板 -->
    <div class="hardware-control-container">
      <el-card class="hardware-control-card">
        <template #header>
          <div class="hardware-card-header">
            <span>硬件设备连接</span>
            <el-tag :type="isHardwareConnected ? 'success' : 'danger'" size="small">
              {{ isHardwareConnected ? '已连接' : '未连接' }}
            </el-tag>
          </div>
        </template>
        <div class="hardware-card-content">
          <el-form :inline="true">
            <el-form-item label="硬件IP地址">
              <el-input v-model="hardwareIP" placeholder="例如：192.168.1.14" :disabled="isHardwareConnected"></el-input>
            </el-form-item>
            <el-form-item>
              <el-button 
                :type="isHardwareConnected ? 'danger' : 'primary'" 
                :loading="isHardwareConnecting" 
                @click="isHardwareConnected ? disconnectHardware() : connectHardware()">
                {{ isHardwareConnected ? '断开连接' : '连接硬件' }}
              </el-button>
            </el-form-item>
          </el-form>
          <div v-if="hardwareErrorMessage" class="hardware-error-message">
            <el-alert :title="hardwareErrorMessage" type="error" show-icon></el-alert>
          </div>
        </div>
      </el-card>
    </div>

    <!-- 设备选择对话框 -->
    <div v-if="showDeviceSelectionDialog" class="dialog-overlay">
      <div class="dialog-content device-selection-dialog">
        <h3>选择{{ getDeviceTypeName(dropPosition.type) }}</h3>
        
        <!-- 搜索框 -->
        <div class="search-box">
          <input 
            v-model="deviceSearchQuery" 
            type="text" 
            placeholder="搜索设备ID..."
            @input="filterDevices"
          />
        </div>
        
        <!-- 设备列表 -->
        <div class="device-list">
          <div v-if="filteredDevices.length === 0" class="no-devices">
            没有可用的{{ getDeviceTypeName(dropPosition.type) }}设备
          </div>
          
          <!-- 设备分组显示 -->
          <template v-for="(group, index) in deviceGroups" :key="index">
            <div class="device-group" v-if="group.devices.length > 0">
              <div class="group-title">{{ group.title }}</div>
              <div 
                v-for="device in group.devices" 
                :key="device.id"
                class="device-item"
                @click="selectDeviceAndAddToGraph(device)"
              >
                <div class="device-info">
                  <div class="device-id">{{ device.id }}</div>
                  <div class="device-module-id" v-if="device.moduleMetadata">
                    模块ID: {{ device.moduleMetadata.moduleId }}
                  </div>
                </div>
                <div class="device-status" :class="device.status">
                  {{ translateStatus(device.status) }}
                </div>
              </div>
            </div>
          </template>
        </div>
        
        <div class="dialog-buttons">
          <button @click="showDeviceSelectionDialog = false">取消</button>
        </div>
      </div>
    </div>

    <!-- 流程执行面板 -->
    <div v-if="isRunningWorkflow" class="workflow-execution-panel">
      <div class="execution-header">
        <h3>正在执行: {{ currentWorkflow.name }}</h3>
        <div class="execution-controls">
          <button 
            @click="pauseOrResumeWorkflow" 
            class="execution-control-btn"
            :class="{ 'pause': workflowExecutor.status === 'running', 'resume': workflowExecutor.status === 'paused' }"
          >
            {{ workflowExecutor.status === 'running' ? '暂停' : '继续' }}
          </button>
          <button @click="stopWorkflow" class="execution-control-btn stop">终止</button>
        </div>
      </div>
      
      <div class="execution-progress">
        <div class="progress-info">
          <span>步骤: {{ workflowExecutor.activeStepIndex + 1 }}/{{ currentWorkflow.steps.length }}</span>
          <span>状态: {{ translateExecutionStatus(workflowExecutor.status) }}</span>
        </div>
        
        <el-progress 
          :percentage="calculateProgress()" 
          :status="getProgressStatus()"
          :stroke-width="15"
        ></el-progress>
      </div>
      
      <div class="execution-steps">
        <div 
          v-for="(step, index) in currentWorkflow.steps" 
          :key="step.id"
          class="execution-step"
          :class="{
            'completed-step': index < workflowExecutor.activeStepIndex,
            'active-step': index === workflowExecutor.activeStepIndex,
            'pending-step': index > workflowExecutor.activeStepIndex
          }"
        >
          <div class="step-indicator">
            <div class="step-number">{{ index + 1 }}</div>
            <div class="step-status-icon">
              <i v-if="index < workflowExecutor.activeStepIndex" class="el-icon-check"></i>
              <i v-else-if="index === workflowExecutor.activeStepIndex && workflowExecutor.status === 'running'" class="el-icon-loading"></i>
              <i v-else-if="index === workflowExecutor.activeStepIndex && workflowExecutor.status === 'paused'" class="el-icon-time"></i>
            </div>
          </div>
          <div class="step-content">
            <div class="step-name">{{ step.name || '未命名步骤' }}</div>
            <div class="step-description">{{ step.description || '无描述' }}</div>
          </div>
          <!-- 添加等待状态显示 -->
          <div class="step-waiting-status" v-if="index === workflowExecutor.activeStepIndex && workflowExecutor.waitingConditions">
            <div class="waiting-title">等待条件满足:</div>
            <div 
              v-for="(condition, condIndex) in workflowExecutor.waitingConditions" 
              :key="condIndex"
              class="waiting-condition"
            >
              <div class="condition-progress">
                <el-progress 
                  :percentage="condition.progress || 0"
                  :status="condition.timeout ? 'warning' : 'primary'"
                ></el-progress>
              </div>
              <div class="condition-desc">
                等待 {{ getDeviceTypeLabel(condition.deviceType) }} {{ condition.deviceId }} 
                {{ getParameterLabel(condition.parameter) }}
                {{ getComparisonLabel(condition.comparison) }}
                {{ condition.value }}{{ getUnitForParameter(condition.parameter) }}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 流程加载对话框 -->
    <el-dialog
      title="加载反应流程"
      v-model="loadWorkflowDialog"
      width="600px"
    >
      <div class="workflow-list">
        <div v-if="savedWorkflows.length === 0" class="no-workflows">
          暂无保存的反应流程
        </div>
        
        <div 
          v-for="(workflow, index) in savedWorkflows" 
          :key="index" 
          class="workflow-item"
          @click="loadWorkflow(workflow)"
        >
          <div class="workflow-name">{{ workflow.name }}</div>
          <div class="workflow-desc">{{ workflow.description || '无描述' }}</div>
          <div class="workflow-meta">
            <span>{{ workflow.steps.length }}个步骤</span>
            <span>{{ formatDate(workflow.updatedAt || workflow.createdAt) }}</span>
          </div>
          <el-button 
            @click.stop="deleteWorkflow(workflow)" 
            type="danger" 
            size="small" 
            circle
            icon="el-icon-delete"
          ></el-button>
        </div>
      </div>
      
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="loadWorkflowDialog = false">取消</el-button>
        </span>
      </template>
    </el-dialog>

    <!-- 工作流预览对话框 -->
    <el-dialog
      title="工作流预览"
      v-model="showWorkflowPreviewDialog"
      width="800px"
      :close-on-click-modal="false"
      :close-on-press-escape="false"
    >
      <div class="workflow-preview-content">
        <div class="workflow-preview-header">
          <h3>{{ previewWorkflow?.name || '自动生成的工作流' }}</h3>
          <p class="workflow-preview-desc">{{ previewWorkflow?.description || '基于参数变更队列自动生成的工作流' }}</p>
          <div class="workflow-preview-meta">
            <span>{{ previewWorkflow?.steps?.length || 0 }}个步骤</span>
            <span>{{ formatDate(previewWorkflow?.createdAt) }}</span>
          </div>
        </div>
        
        <div class="workflow-preview-steps">
          <div 
            v-for="(step, index) in previewWorkflow?.steps || []" 
            :key="step.id" 
            class="workflow-preview-step"
          >
            <div class="preview-step-header">
              <div class="preview-step-number">{{ index + 1 }}</div>
              <div class="preview-step-name">{{ step.name }}</div>
            </div>
            <div class="preview-step-content">
              <div class="preview-step-desc">{{ step.description }}</div>
              
              <div class="preview-commands-list">
                <h4>设备命令 ({{ step.deviceCommands.length }})</h4>
                <div class="preview-commands-scroll">
                  <div v-for="(cmd, cmdIndex) in step.deviceCommands" :key="cmdIndex" class="preview-command-item">
                    <div class="preview-command-device">
                      <span class="preview-device-type">{{ translateDeviceType(cmd.deviceType) }}</span>
                      <span class="preview-device-id">{{ cmd.deviceId }}</span>
                    </div>
                    <div class="preview-command-action">
                      {{ translateActionName(cmd.action, cmd.deviceType) }}
                      <div class="preview-command-params" v-if="cmd.parameters && Object.keys(cmd.parameters).length > 0">
                        <div v-for="(value, key) in cmd.parameters" :key="key" class="preview-param">
                          {{ translateParamName(key) }}: <span class="param-value">{{ value }}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- 条件和延迟时间 -->
              <div class="preview-step-conditions" v-if="step.conditions && step.conditions.length > 0">
                <h4>执行条件 ({{ step.conditions.length }})</h4>
                <div class="preview-condition-item" v-for="(condition, condIndex) in step.conditions" :key="condIndex">
                  <div class="condition-type">{{ translateConditionType(condition.type) }}</div>
                  <div class="condition-details">
                    <div v-if="condition.type === 'deviceStatus'">
                      等待 {{ translateDeviceType(condition.deviceType) }} {{ condition.deviceId }} 
                      状态变为 {{ translateStatus(condition.status) }}
                      (超时: {{ condition.timeout || 60 }}秒)
                    </div>
                    <div v-else-if="condition.type === 'timeout'">
                      等待 {{ condition.duration }}秒
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="preview-step-delay" v-if="step.conditions && step.conditions.length > 0">
                <div class="delay-icon">🔄</div>
                <div class="delay-text">等待设备状态满足预设条件后继续</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="showWorkflowPreviewDialog = false">取消</el-button>
          <el-button type="primary" @click="executePreviewedWorkflow">执行工作流</el-button>
        </span>
      </template>
    </el-dialog>

    <!-- 反应流程编辑器界面已移除，保留必要的隐藏对话框用于后台处理 -->
    <el-dialog
      v-model="isWorkflowMode"
      title="反应流程处理"
      width="0"
      :modal="false"
      :close-on-click-modal="false"
      :show-close="false"
      :append-to-body="true"
      destroy-on-close
    ></el-dialog>

    <!-- 反应路径选择面板 - 新增 -->
    <div v-if="isShowingReactionPath" class="reaction-path-panel">
      <div class="panel-header">
        <div class="panel-title">反应路径</div>
        <button class="close-btn" @click="isShowingReactionPath = false">×</button>
      </div>
      
      <!-- 加载状态 -->
      <div v-if="isLoadingReactionPaths" class="loading-paths">
        <div class="loading-spinner"></div>
        <div class="loading-text">加载反应路径数据中...</div>
      </div>
      
      <!-- 错误信息 -->
      <div v-else-if="reactionPathsError" class="path-error">
        <div class="error-icon">!</div>
        <div class="error-text">{{ reactionPathsError }}</div>
        <button class="retry-btn" @click="loadMappingData">重试</button>
      </div>
      
      <!-- 反应路径列表 -->
      <div v-else class="reaction-paths-list">
        <div v-for="(path, index) in reactionPaths" :key="index" class="reaction-path-item" 
          :class="{'active': selectedReactionPathIndex === index}"
          @click="selectReactionPath(index)">
          <div class="path-name">{{ path.name }}</div>
          <div class="path-info">{{ path.description }}</div>
        </div>
        
        <div v-if="reactionPaths.length === 0" class="no-paths">
          暂无可用反应路径
        </div>
      </div>
      
      <div v-if="selectedReactionPathIndex !== null" class="path-actions">
        <div class="path-action-instructions">
          <div class="instruction-step">
            <div class="step-icon">1</div>
            <div class="step-text">点击各设备节点设置参数</div>
          </div>
          <div class="instruction-step">
            <div class="step-icon">2</div>
            <div class="step-text">在参数变更队列面板点击"生成工作流并执行"</div>
          </div>
        </div>
        <button class="clear-path-btn" @click="clearReactionPathHighlight">清除高亮</button>
      </div>
    </div>
    
    <!-- 增强版标准参数配置对话框 -->
    <el-dialog
      v-model="showStandardParamsDialog"
      title="反应路径参数配置"
      width="800px"
      :destroy-on-close="false"
    >
      <div class="standard-workflow-params">
        <h3>请为 "{{ reactionPaths[selectedReactionPathIndex]?.name || '未选择' }}" 反应路径设置参数</h3>
        
        <el-form label-position="top">
          <!-- 基本反应参数设置 -->
          <el-divider content-position="left">基本反应参数</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="反应温度 (°C)">
                <el-input-number v-model="standardParams.reactionTemp" :min="0" :max="300" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应时间 (分钟)">
                <el-input-number v-model="standardParams.reactionTime" :min="1" :max="600" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="反应体积 (μL)">
                <el-input-number v-model="standardParams.reactionVolume" :min="10" :max="1000" />
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 泵设置 -->
          <el-divider content-position="left">泵设置</el-divider>
          <div v-for="(pump, index) in pathPumps" :key="`pump-${pump.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ pump.id }}</h4>
              <el-switch v-model="standardParams.enabledPumps[pump.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledPumps[pump.id]">
              <el-col :span="6">
                <el-form-item label="泵速度 (%)">
                  <el-input-number v-model="standardParams.pumpSpeeds[pump.id]" :min="1" :max="100" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="抽取体积 (μL)">
                  <el-input-number v-model="standardParams.pumpVolumes[pump.id]" :min="10" :max="1000" />
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="反应物进液端口">
                  <el-select v-model="standardParams.pumpPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`in-${port}`" :label="`端口 ${port}`" :value="port" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="6">
                <el-form-item label="产品出液端口">
                  <el-select v-model="standardParams.pumpOutPorts[pump.id]">
                    <el-option v-for="port in 5" :key="`out-${port}`" :label="`端口 ${port}`" :value="port" />
                    <el-option key="waste" label="端口 6 (废液)" :value="6" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物">
                  <el-input v-model="standardParams.pumpReagents[pump.id]" placeholder="输入反应物名称" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="反应物浓度">
                  <el-input v-model="standardParams.pumpConcentrations[pump.id]" placeholder="例如: 0.1 M" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 阀门设置 -->
          <el-divider content-position="left">阀门设置</el-divider>
          <div v-for="(valve, index) in pathValves" :key="`valve-${valve.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ valve.id }}</h4>
              <div>
                <el-checkbox v-model="standardParams.valvesToProduct[valve.id]">连接产品</el-checkbox>
                <el-checkbox v-model="standardParams.valvesToWaste[valve.id]">连接废液</el-checkbox>
              </div>
            </div>
            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="初始阀门位置">
                  <el-select v-model="standardParams.valvePositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="产品收集阀门位置" v-if="standardParams.valvesToProduct[valve.id]">
                  <el-select v-model="standardParams.valveProductPositions[valve.id]">
                    <el-option v-for="pos in 8" :key="pos" :label="`位置 ${pos}`" :value="pos" />
                  </el-select>
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 加热器设置 -->
          <el-divider content-position="left">加热器设置</el-divider>
          <div v-for="(heater, index) in pathHeaters" :key="`heater-${heater.id}`" class="device-param-container">
            <div class="device-header">
              <h4>{{ heater.id }}</h4>
              <el-switch v-model="standardParams.enabledHeaters[heater.id]" active-text="启用" inactive-text="禁用" />
            </div>
            <el-row :gutter="20" v-if="standardParams.enabledHeaters[heater.id]">
              <el-col :span="12">
                <el-form-item label="反应温度 (°C)">
                  <el-input-number v-model="standardParams.heaterTemps[heater.id]" :min="25" :max="300" />
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="加热速率">
                  <el-input-number v-model="standardParams.heaterSpeeds[heater.id]" :min="1" :max="20" />
                </el-form-item>
              </el-col>
            </el-row>
          </div>
          
          <!-- 清洗设置 -->
          <el-divider content-position="left">清洗设置</el-divider>
          <el-row :gutter="20">
            <el-col :span="8">
              <el-form-item label="清洗溶液体积 (μL)">
                <el-input-number v-model="standardParams.cleaningVolume" :min="50" :max="2000" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗次数">
                <el-input-number v-model="standardParams.cleaningCycles" :min="1" :max="5" />
              </el-form-item>
            </el-col>
            <el-col :span="8">
              <el-form-item label="清洗端口">
                <el-select v-model="standardParams.cleaningPort">
                  <el-option v-for="port in 5" :key="`clean-${port}`" :label="`端口 ${port}`" :value="port" />
                </el-select>
              </el-form-item>
            </el-col>
          </el-row>
          
          <!-- 步骤说明 -->
          <el-divider content-position="left">反应步骤预览</el-divider>
          <div class="workflow-steps-preview">
            <div class="step-preview-item">
              <div class="step-number">1</div>
              <div class="step-content">
                <div class="step-title">初始化反应路径</div>
                <div class="step-desc">启动所有阀门并设置为初始位置，启动加热芯片至目标温度</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">2</div>
              <div class="step-content">
                <div class="step-title">泵润洗</div>
                <div class="step-desc">将泵排空至废液口进行润洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">3</div>
              <div class="step-content">
                <div class="step-title">抽吸反应溶液</div>
                <div class="step-desc">泵从指定端口抽取反应溶液</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">4</div>
              <div class="step-content">
                <div class="step-title">反应运行</div>
                <div class="step-desc">启动泵输出反应溶液，保持稳定反应{{standardParams.reactionTime}}分钟</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">5</div>
              <div class="step-content">
                <div class="step-title">产品收集</div>
                <div class="step-desc">打开与产品收集相连的阀门</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">6</div>
              <div class="step-content">
                <div class="step-title">废液排出</div>
                <div class="step-desc">切换连接废液口的阀门，准备系统清洗</div>
              </div>
            </div>
            <div class="step-preview-item">
              <div class="step-number">7</div>
              <div class="step-content">
                <div class="step-title">系统清洗</div>
                <div class="step-desc">泵抽取清洗溶液并冲洗管道系统，完成{{standardParams.cleaningCycles}}次循环</div>
              </div>
            </div>
          </div>
        </el-form>
      </div>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="showStandardParamsDialog = false">取消</el-button>
          <el-button type="primary" @click="confirmGenerateWorkflow">生成工作流</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, computed, watch, reactive } from "vue";
import { Graph } from "@antv/g6";
import { useAppStoreHook } from "@/store/modules/app";
import axios from "axios";
import { saveAs } from 'file-saver'; // 需要安装 file-saver 库用于保存文件
import { ElMessage,ElMessageBox } from 'element-plus';
import { useRoute, useRouter } from 'vue-router';
const router = useRouter();

// 引入图片文件
import pump from "@/assets/jpg/pump.jpg";
import valve from "@/assets/jpg/valve.jpg";
import chip from "@/assets/jpg/chip.jpg";
import mfc from "@/assets/svg/mfc.svg?url"; // 保留原有mfc图标
import light from "@/assets/svg/light.svg?url"; // 保留原有light图标
import bottle from "@/assets/jpg/bottle.jpg";


defineOptions({
  name:"MonitorStandalone"
})
const isAdmin = ref(true);
const isSidebarOpen = ref(true);
const isLoading = ref(false); // 添加加载状态
const errorMessage = ref(""); // 添加错误信息

// 添加任务编辑模式相关的状态
const isEditMode = ref(false);
const editTaskData = ref(null);
const deviceParameters = ref({});  // 存储设备参数

// 流程模式状态
const isWorkflowMode = ref(false);
const isRunningWorkflow = ref(false);
const selectedStepIndex = ref(-1);
const loadWorkflowDialog = ref(false);

// 添加标准工作流参数状态
const showStandardParamsDialog = ref(false);
const standardParams = reactive({
  valvePositions: {}, // 阀门位置设置
  valvesToProduct: {}, // 连接产品的阀门
  valvesToWaste: {}, // 连接废液的阀门
  heaterTemps: {}, // 加热器温度
  heaterSpeeds: {}, // 加热器升温速率
  pumpSpeeds: {}, // 泵速度
  pumpVolumes: {}, // 泵抽取体积 
  pumpPorts: {}, // 泵进液端口
  pumpOutPorts: {}, // 泵出液端口
  cleaningVolume: 100, // 默认清洗体积
  reactionTime: 30, // 默认反应时间(分钟)
});

// 从反应路径中提取的设备
const pathValves = ref([]);
const pathPumps = ref([]);
const pathHeaters = ref([]);

// 当前编辑的流程
const currentWorkflow = reactive({
  id: '',
  name: '',
  description: '',
  steps: [],
  createdAt: null,
  updatedAt: null
});
// 已保存的流程列表
const savedWorkflows = ref([]);

// 可用传感器列表（示例）
const availableSensors = ref([
  { id: 'temperature_sensor_1', name: '温度传感器1' },
  { id: 'pressure_sensor_1', name: '压力传感器1' },
  { id: 'ph_sensor_1', name: 'pH传感器1' }
]);

// 连线模式相关
const isEdgeMode = ref(false);
const sourceNode = ref(null);

// 拖拽是否启用的计算属性
const isDragEnabled = computed(() => {
  console.log("isDragEnabled", isAdmin.value, isCreateMode.value, isSidebarOpen.value, isEdgeMode.value);
  // 在创建模式下始终允许拖拽节点，但需要是管理员
  if (isAdmin.value && isCreateMode.value) {
    console.log("创建模式下启用拖拽");
    return true;
  }
  // 其他情况下的原始逻辑
  return false;
});

// 获取应用侧边栏状态
const pureApp = useAppStoreHook();
const appSidebarOpened = computed(() => pureApp.getSidebarStatus);

const container = ref(null);
let graph = null;
let draggedIcon = null;

// 可拖拽图标列表
const nodeIcons = ref([
  { type: "pump", src: pump, label: "泵" },
  { type: "valve", src: valve, label: "阀" },
  { type: "chip", src: chip, label: "加热芯片" },
  { type: "mfc", src: mfc, label: "MFC控制器" },
  { type: "light", src: light, label: "光照控制" },
  { type: "bottle", src: bottle, label: "瓶" }
]);

const selectedDevice = ref(null);
const deviceData = ref({}); // 当前设备状态数据（由下位机更新）
const controlParams = ref({}); // 新增：控制参数数据（用于用户调整参数）

// 创建模式状态
const isCreateMode = ref(false);
const pathName = ref(''); // 用于存储新创建的硬件结构名称
const pathDescription = ref(''); // 用于存储硬件结构描述
const isShowPathNameDialog = ref(false); // 控制显示路径名称输入对话框

// 已有的硬件结构列表
const savedPaths = ref([]);

// 当前编辑的路径信息
const currentEditPath = ref(null);

// 删除路径相关变量
const isShowDeletePathDialog = ref(false);
const pathToDelete = ref(null);

const selectedPath = ref(null);
const selectedControllerIndex = ref(1); // 设置默认控制器索引为1

// 操作历史和撤销相关状态
const operationHistory = ref([]); // 操作历史记录
const maxHistoryLength = 20; // 最大历史记录长度

// 存储用户修改的参数
const pendingChanges = ref(new Map());
// 控制参数变更队列面板显示
const showPendingChangesPanel = ref(false);

// 流程执行器
const workflowExecutor = reactive({
  currentWorkflow: null,
  activeStepIndex: -1,
  status: 'idle', // idle, running, paused, completed, error
  startTime: null,
  endTime: null,
  stepResults: new Map(), // 存储每个步骤的执行结果
  waitingConditions: [], // 当前正在等待的条件

  updateWaitingCondition(index, progress, timeout = false) {
    if(this.waitingConditions[index]) {
      this.waitingConditions[index].progress = progress;
      this.waitingConditions[index].timeout = timeout;
    }
  },
  
  async executeWorkflow(workflow) {
    this.currentWorkflow = workflow;
    this.status = 'running';
    this.activeStepIndex = 0;
    this.startTime = Date.now();
    this.stepResults.clear();
    
    try {
      while(this.activeStepIndex < workflow.steps.length && (this.status === 'running' || this.status === 'paused')) {
        // 如果暂停，等待恢复
        if(this.status === 'paused') {
          await new Promise(resolve => {
            const checkInterval = setInterval(() => {
              if(this.status === 'running') {
                clearInterval(checkInterval);
                resolve();
              } else if(this.status === 'idle') {
                clearInterval(checkInterval);
                throw new Error('流程已终止');
              }
            }, 500);
          });
        }
        
        // 执行当前步骤
        const step = workflow.steps[this.activeStepIndex];
        
        console.log(`执行步骤 ${this.activeStepIndex + 1}: ${step.name}`);
        
        try {
          await this.executeStep(step);
          this.stepResults.set(step.id, { success: true });
        } catch(error) {
          console.error(`步骤 ${step.name} 执行失败:`, error);
          this.stepResults.set(step.id, { success: false, error: error.message });
          
          // 询问用户是否继续
          try {
            await ElMessageBox.confirm(
              `步骤 "${step.name}" 执行失败: ${error.message}\n是否继续执行后续步骤？`,
              '步骤执行失败',
              {
                confirmButtonText: '继续',
                cancelButtonText: '终止流程',
                type: 'warning',
              }
            );
            // 用户选择继续
          } catch (e) {
            // 用户选择终止
            throw new Error('用户终止了流程');
          }
        }
        
        this.activeStepIndex++;
        
        // 通知更新进度
        ElMessage.success(`已完成步骤 ${this.activeStepIndex}/${workflow.steps.length}: ${step.name}`);
      }
      
      if(this.status === 'running') {
        this.status = 'completed';
        this.endTime = Date.now();
        ElMessage.success(`流程 "${workflow.name}" 已成功完成！`);
      }
    } catch(error) {
      this.status = 'error';
      this.endTime = Date.now();
      console.error("流程执行错误:", error);
      ElMessage.error(`流程执行错误: ${error.message}`);
    }
  },
  
  async executeStep(step) {
    console.log(`开始执行步骤: ${step.name}`);
    
    // 检查步骤是否有前置条件
    if(step.conditions && step.conditions.length > 0) {
      console.log(`步骤 "${step.name}" 有 ${step.conditions.length} 个前置条件，开始检查...`);
      
      // 显示等待前置条件的UI提示
      this.waitingConditions = step.conditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index
      }));
      
      try {
        await this.checkConditions(step.conditions);
        console.log(`步骤 "${step.name}" 的前置条件已满足`);
        ElMessage.success(`前置条件已满足，开始执行步骤`);
      } catch (error) {
        console.error(`步骤 "${step.name}" 的前置条件检查失败:`, error);
        ElMessage.error(`前置条件未满足: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    }
    
    // 执行设备命令
    console.log(`开始发送 ${step.deviceCommands.length} 个设备命令...`);
    const commandPromises = step.deviceCommands.map(cmd => 
      this.sendDeviceCommand(cmd)
    );
    
    // 等待命令发送完成（注意：这只是发送完成，不是设备执行完成）
    try {
      const results = await Promise.all(commandPromises);
      console.log(`所有命令已成功发送，共 ${results.length} 个命令`);
    } catch (error) {
      console.error(`命令发送过程出错:`, error);
      ElMessage.error(`命令发送失败: ${error.message}`);
      throw error;
    }
    
    // 不论是否设置了waitForCompletion，都自动生成和检查完成条件
    // 这确保每个步骤都基于实际设备状态来确定完成条件
    
    // 自动从命令中生成完成条件
    const completionConditions = this.generateCompletionConditions(step.deviceCommands);
    
    if(completionConditions.length > 0) {
      // 显示等待信息
      ElMessage.info(`等待设备达到目标状态...共 ${completionConditions.length} 个条件需要检查`);
      
      // 设置UI等待状态
      this.waitingConditions = completionConditions.map((condition, index) => ({
        ...condition,
        progress: 0,
        index,
        deviceType: condition.deviceType,
        deviceId: condition.deviceId,
        parameter: condition.parameter || '状态',
        comparison: condition.comparison || 'eq',
        value: condition.value || condition.status
      }));
      
      try {
        // 检查所有完成条件
        await this.checkConditions(completionConditions);
        ElMessage.success(`设备已达到目标状态`);
      } catch (error) {
        console.error(`完成条件检查失败:`, error);
        ElMessage.error(`等待设备达到目标状态失败: ${error.message}`);
        throw error;
      } finally {
        this.waitingConditions = [];
      }
    } else {
      console.log(`步骤 "${step.name}" 没有生成任何完成条件，将继续执行`);
      
      // 如果没有自动生成完成条件但设置了waitForCompletion，则至少等待一个短暂时间
      if(step.waitForCompletion) {
        console.log(`步骤需要等待完成但没有具体条件，添加一个短暂等待时间（3秒）...`);
        await this.executeDelay(3);
      }
    }
    
    // 只有在明确设置了延迟时间的情况下才执行额外延迟
    if(step.delayAfter > 0) {
      console.log(`执行步骤后额外延迟 ${step.delayAfter} 秒...`);
      ElMessage.info(`步骤已完成，额外等待 ${step.delayAfter} 秒以确保系统稳定...`);
      await this.executeDelay(step.delayAfter);
    }
    
    console.log(`步骤 "${step.name}" 执行完成`);
  },
  
  async sendDeviceCommand(cmd) {
    console.log(`发送设备命令:`, cmd);
    
    // 构建适合WebSocket发送的命令格式
    const wsCommand = {
      id: cmd.deviceId,
      type: cmd.deviceType,
      action: cmd.action,
      parameters: cmd.parameters || {}
    };
    
    // 发送命令给WebSocket
    return new Promise((resolve, reject) => {
      // 设置超时
      const timeout = setTimeout(() => {
        reject(new Error(`命令执行超时: ${cmd.deviceType} ${cmd.deviceId} ${cmd.action}`));
      }, 30000); // 30秒超时
      
      // 创建一次性的消息监听器
      let messageHandler = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // 如果是命令结果响应或错误响应
          if (data.type === 'commandResult' && data.data) {
            // 检查是否是对应的命令响应
            const result = data.data;
            if (result.command && result.command.id === cmd.deviceId && result.command.action === cmd.action) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              if (result.success) {
                console.log(`命令执行成功:`, result);
                resolve(result);
              } else {
                console.error(`命令执行失败:`, result);
                reject(new Error(result.error || '命令执行失败'));
              }
            }
          }
        } catch (error) {
          console.error("解析WebSocket消息失败:", error);
        }
      };
      
      // 添加临时消息监听
      if (ws.value) {
        ws.value.addEventListener('message', messageHandler);
      }
      
      // 发送WebSocket消息
      const success = sendWsMessage({
        type: 'updateDeviceParameters',
        payload: [wsCommand]
      });
      
      if (!success) {
        clearTimeout(timeout);
        if (ws.value) {
          ws.value.removeEventListener('message', messageHandler);
        }
        reject(new Error('WebSocket消息发送失败'));
      }
    });
  },
  
  async checkConditions(conditions) {
    const conditionPromises = conditions.map(async condition => {
      switch(condition.type) {
        case 'deviceStatus':
          return this.checkDeviceStatusCondition(condition);
        
        case 'timeout':
          return this.checkTimeoutCondition(condition);
          
        case 'deviceParameter': // 新增：设备参数条件类型
          return this.checkDeviceParameterCondition(condition);
          
        case 'sensorValue':
          return this.checkSensorValueCondition(condition);
          
        default:
          throw new Error(`未知的条件类型: ${condition.type}`);
      }
    });
    // 等待所有条件满足
    await Promise.all(conditionPromises);
  },

  
  async checkDeviceStatusCondition(condition) {
    console.log(`检查设备状态条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待设备 ${condition.deviceId} 状态 ${condition.status} 超时`);
      }
      
      // 获取设备当前状态
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device && device.status === condition.status) {
        console.log(`条件满足: 设备 ${condition.deviceId} 状态为 ${condition.status}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  // 检查设备参数条件 - 优化版3.0
  async checkDeviceParameterCondition(condition, conditionIndex) {
    console.log(`检查设备参数条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000;
    
    // 获取目标参数的描述，用于日志和UI显示
    const paramName = condition.parameter;
    const paramDisplayName = this.getParameterDisplayName(condition.deviceType, paramName);
    const deviceTypeName = this.getDeviceTypeName(condition.deviceType);
    const comparisonText = this.getComparisonText(condition.comparison);
    const targetValue = condition.value;
    const tolerance = condition.tolerance || 
      (paramName === 'currentTemp' || paramName === 'temperature' ? 2 : // 温度2度容差
       paramName === 'position' ? 10 : // 位置10单位容差
       paramName === 'flowRate' ? 0.2 : // 流速0.2ml/min容差
       0.05 * targetValue); // 默认5%容差
    
    // 记录初始值，用于计算进度
    let initialValue = null;
    const device = globalDevices.value.get(condition.deviceId);
    if (device) {
      initialValue = device[condition.parameter];
      console.log(`设备${condition.deviceId}的${paramDisplayName}初始值: ${initialValue}, 目标值: ${targetValue}`);
    }
    
    // 动态调整稳定计数器 - 不同参数类型需要不同的稳定性要求
    const requiredStabilityCount = 
      (paramName === 'currentTemp' || paramName === 'temperature') ? 5 : // 温度需要更多稳定检查
      (paramName === 'position') ? 3 : // 位置需要中等稳定检查
      (paramName === 'flowRate') ? 4 : // 流速需要较多稳定检查
      2; // 其他参数2次稳定即可
    
    console.log(`设备${condition.deviceId}参数${paramDisplayName}需要连续${requiredStabilityCount}次稳定才算满足条件`);
    
    // 稳定计数器
    let stabilityCounter = 0;
    
    // 显示开始等待的提示
    ElMessage.info(`等待${deviceTypeName}(${condition.deviceId})的${paramDisplayName}${comparisonText}${targetValue}...`);
    
    // 记录最后一次值，用于检测停滞
    let lastValue = null;
    let stagnantCounter = 0;
    
    // 检测最大进展值，避免倒退
    let maxProgress = 0;
    
    while(this.status === 'running') {
      // 计算进度百分比 - 时间型进度
      const elapsedTime = Date.now() - startTime;
      const timeProgressPercent = Math.min(Math.round((elapsedTime / timeoutMs) * 100), 99);
      
      // 检查是否超时
      if(elapsedTime > timeoutMs) {
        // 更新UI显示为超时状态
        if (conditionIndex !== undefined) {
          this.updateWaitingCondition(conditionIndex, 100, true);
        }
        
        const errorMsg = `等待设备 ${condition.deviceId} 的${paramDisplayName}达到目标值(${targetValue})超时`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      
      // 获取设备当前参数值
      const device = globalDevices.value.get(condition.deviceId);
      
      if(device) {
        const currentValue = device[condition.parameter];
        
        // 如果还没有初始值记录，现在记录
        if (initialValue === null) {
          initialValue = currentValue;
          console.log(`记录初始值: ${initialValue}`);
        }
        
        // 检查是否停滞（值没有变化）
        if (lastValue !== null && currentValue === lastValue) {
          stagnantCounter++;
          // 如果值超过10次检查没有变化（约5秒），输出警告
          if (stagnantCounter >= 10 && stagnantCounter % 10 === 0) {
            console.warn(`警告: 设备${condition.deviceId}的${paramDisplayName}已停滞在${currentValue}超过${stagnantCounter/2}秒`);
          }
        } else {
          stagnantCounter = 0;
          lastValue = currentValue;
        }
        
        let conditionMet = false;
        
        // 根据比较类型检查条件
        switch(condition.comparison) {
          case 'eq': // 等于
            // 带容差的相等判断
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
            
          case 'gt': // 大于
            conditionMet = currentValue > condition.value;
            break;
            
          case 'lt': // 小于
            conditionMet = currentValue < condition.value;
            break;
            
          case 'gte': // 大于等于
            conditionMet = currentValue >= condition.value;
            break;
            
          case 'lte': // 小于等于
            conditionMet = currentValue <= condition.value;
            break;
            
          case 'approx': // 近似值（主要用于浮点数）
            conditionMet = Math.abs(currentValue - condition.value) <= tolerance;
            break;
        }
        
        // 根据条件是否满足调整稳定计数器
        if(conditionMet) {
          stabilityCounter++;
          
          // 计算基于接近目标值的进度 - 达到稳定次数的百分比
          const valueProgressPercent = Math.min(Math.round((stabilityCounter / requiredStabilityCount) * 100), 99);
          
          // 取两种进度的最大值，确保进度一直在前进
          let combinedProgress = Math.max(timeProgressPercent, valueProgressPercent);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态 - 显示更积极的进度
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
          
          // 如果已经连续多次满足条件，认为条件稳定满足
          if(stabilityCounter >= requiredStabilityCount) {
            // 条件满足时，设置进度为100%
            if (conditionIndex !== undefined) {
              this.updateWaitingCondition(conditionIndex, 100);
            }
            
            console.log(`条件已稳定满足: ${deviceTypeName}(${condition.deviceId})的${paramDisplayName}已${comparisonText}${targetValue}`);
            // 记录最终值和达成时间
            const reachedInSec = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`目标值: ${targetValue}, 当前值: ${currentValue}, 容差: ±${tolerance}, 耗时: ${reachedInSec}秒`);
            
            // 直接跳出循环，提前满足条件
            return true;
          }
          
          console.log(`接近条件满足(${stabilityCounter}/${requiredStabilityCount}): 当前值: ${currentValue}, 目标值: ${targetValue}, 容差: ±${tolerance}`);
        } else {
          // 如果条件不满足，重置稳定计数器
          stabilityCounter = 0;
          
          // 对于可测量的进度（如温度、位置变化），计算完成百分比
          let valueProgress = 0;
          
          if (initialValue !== null && initialValue !== currentValue) {
            // 根据不同参数类型计算进度
            if (paramName === 'temperature' || paramName === 'currentTemp') {
              // 温度变化进度
              const direction = targetValue > initialValue ? 1 : -1; // 是加热还是冷却
              if (direction > 0) { // 加热
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentValue - initialValue) / (targetValue - initialValue) * 100)
                ));
              } else { // 冷却
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((initialValue - currentValue) / (initialValue - targetValue) * 100)
                ));
              }
            } else if (paramName === 'position') {
              // 位置移动进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalDistance = Math.abs(targetValue - initialValue);
              const currentDistance = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentDistance / totalDistance) * 100)
              ));
            } else if (paramName === 'flowRate') {
              // 流速变化进度
              const direction = targetValue > initialValue ? 1 : -1;
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              valueProgress = Math.min(90, Math.max(0, 
                Math.round((currentChange / totalChange) * 100)
              ));
            } else {
              // 其他参数的通用进度计算
              const totalChange = Math.abs(targetValue - initialValue);
              const currentChange = Math.abs(currentValue - initialValue);
              
              if (totalChange > 0) {
                valueProgress = Math.min(90, Math.max(0, 
                  Math.round((currentChange / totalChange) * 100)
                ));
              }
            }
          }
          
          // 取两种进度的最大值
          let combinedProgress = Math.max(timeProgressPercent, valueProgress);
          
          // 确保进度不会倒退
          combinedProgress = Math.max(combinedProgress, maxProgress);
          maxProgress = combinedProgress;
          
          // 更新等待条件状态
          if (conditionIndex !== undefined) {
            this.updateWaitingCondition(conditionIndex, combinedProgress);
          }
        }
        
        // 记录进度 - 但降低日志频率
        const progressTime = ((Date.now() - startTime) / 1000).toFixed(1);
        if (parseInt(progressTime) % 5 === 0) { // 每5秒记录一次
          console.log(`等待进度: ${maxProgress}%, 当前值: ${currentValue}, 目标值: ${targetValue}, 已等待${progressTime}秒`);
        }
      } else {
        console.warn(`找不到设备 ${condition.deviceId} 的数据，请检查设备是否连接`);
      }
      
      // 等待检查间隔 - 根据不同设备参数类型调整
      const checkInterval = 
        (paramName === 'currentTemp' || paramName === 'temperature') ? 1000 : // 温度1秒检查一次
        (paramName === 'position') ? 500 : // 位置0.5秒检查一次
        (paramName === 'flowRate') ? 750 : // 流速0.75秒检查一次
        300; // 其他参数0.3秒检查一次
      
      await new Promise(resolve => setTimeout(resolve, checkInterval));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  // 获取参数的友好显示名称
  getParameterDisplayName(deviceType, parameter) {
    const displayNames = {
      'position': '位置',
      'speed': '速度',
      'currentTemp': '温度',
      'temperature': '温度',
      'flowRate': '流速',
      'intensity': '光强',
      'port': '端口',
      'aspiratePort': '吸取端口',
      'dispensePort': '输送端口'
    };
    
    return displayNames[parameter] || parameter;
  },
  
  // 获取设备类型的友好名称
  getDeviceTypeName(deviceType) {
    const displayNames = {
      'pump': '泵',
      'valve': '阀门',
      'chip': '加热芯片',
      'mfc': '流量控制器',
      'light': '光照控制'
    };
    
    return displayNames[deviceType] || deviceType;
  },
  
  // 获取比较符号的文本表示
  getComparisonText(comparison) {
    const displayTexts = {
      'eq': '等于',
      'gt': '大于',
      'lt': '小于',
      'gte': '大于等于',
      'lte': '小于等于',
      'approx': '约等于'
    };
    
    return displayTexts[comparison] || comparison;
  },
  async checkTimeoutCondition(condition) {
    console.log(`执行等待条件: ${condition.duration}秒`);
    
    const durationMs = condition.duration * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个等待条件用于UI显示
    const waitingCondition = {
      type: 'timeout',
      description: `等待${condition.duration}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表以显示在UI上
    const conditionIndex = this.waitingConditions.length;
    this.waitingConditions.push(waitingCondition);
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      waitingCondition.progress = progressPercent;
      waitingCondition.description = `等待中: 剩余${remainingTime}秒`;
      this.waitingConditions[conditionIndex] = { ...waitingCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`等待进度: ${progressPercent}%, 已等待${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        waitingCondition.description = `等待已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[conditionIndex] = { ...waitingCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime.value += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成等待
    waitingCondition.progress = 100;
    waitingCondition.description = `等待完成: ${condition.duration}秒`;
    this.waitingConditions[conditionIndex] = { ...waitingCondition };
    
    console.log(`等待条件满足: 完成${condition.duration}秒等待`);
    return true;
  },
  
  // 执行时间延迟 - 增强版，支持暂停和终止
  async executeDelay(seconds) {
    console.log(`执行延迟: ${seconds}秒`);
    
    const durationMs = seconds * 1000;
    const startTime = Date.now();
    const endTime = startTime + durationMs;
    
    // 创建一个延迟条件用于UI显示
    const delayCondition = {
      type: 'delay',
      description: `系统稳定: ${seconds}秒`,
      progress: 0,
      timeout: false
    };
    
    // 添加到等待条件列表
    this.waitingConditions = [delayCondition];
    
    // 记录实际等待的时间
    let actualWaitTime = 0;
    
    while(Date.now() < endTime && this.status === 'running') {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;
      const remainingTime = Math.max(0, Math.ceil((endTime - currentTime) / 1000));
      
      // 计算进度百分比
      const progressPercent = Math.min(99, Math.round((elapsedTime / durationMs) * 100));
      
      // 更新等待条件状态
      delayCondition.progress = progressPercent;
      delayCondition.description = `系统稳定中: 剩余${remainingTime}秒`;
      this.waitingConditions[0] = { ...delayCondition };
      
      // 每整秒记录一次
      if (Math.floor(elapsedTime / 1000) > actualWaitTime) {
        actualWaitTime = Math.floor(elapsedTime / 1000);
        if (actualWaitTime % 5 === 0 || actualWaitTime === 1) { // 每5秒或第1秒记录
          console.log(`延迟进度: ${progressPercent}%, 已延迟${actualWaitTime}秒, 剩余${remainingTime}秒`);
        }
      }
      
      // 每100ms检查一次状态
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 如果状态变为暂停，等待恢复
      if(this.status === 'paused') {
        const pauseStartTime = Date.now();
        delayCondition.description = `延迟已暂停: 剩余${remainingTime}秒`;
        this.waitingConditions[0] = { ...delayCondition };
        
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if(this.status === 'running') {
              clearInterval(checkInterval);
              // 调整结束时间以考虑暂停的时间
              const pauseDuration = Date.now() - pauseStartTime;
              endTime += pauseDuration;
              resolve();
            } else if(this.status === 'idle') {
              clearInterval(checkInterval);
              throw new Error('流程已终止');
            }
          }, 200);
        });
      }
      
      // 如果状态变为停止，中断等待
      if(this.status === 'idle') {
        throw new Error('流程已终止');
      }
    }
    
    // 完成延迟
    delayCondition.progress = 100;
    delayCondition.description = `延迟完成: ${seconds}秒`;
    this.waitingConditions[0] = { ...delayCondition };
    
    // 清空等待条件列表
    setTimeout(() => {
      this.waitingConditions = [];
    }, 500);
    
    console.log(`延迟完成: ${seconds}秒`);
  },
  
  async checkSensorValueCondition(condition) {
    console.log(`检查传感器值条件:`, condition);
    
    const startTime = Date.now();
    const timeoutMs = (condition.timeout || 60) * 1000; // 默认60秒超时
    
    while(this.status === 'running') {
      // 检查是否超时
      if(Date.now() - startTime > timeoutMs) {
        throw new Error(`等待传感器 ${condition.sensorId} 条件满足超时`);
      }
      
      // TODO: 获取传感器实时数据，可以通过WebSocket或API实现
      // 这里使用模拟值
      const sensorValue = await getSensorValue(condition.sensorId);
      
      // 根据比较类型检查条件
      let conditionMet = false;
      switch(condition.comparison) {
        case 'gt':
          conditionMet = sensorValue > condition.value;
          break;
        case 'lt':
          conditionMet = sensorValue < condition.value;
          break;
        case 'eq':
          conditionMet = Math.abs(sensorValue - condition.value) < 0.001; // 浮点数比较
          break;
        case 'gte':
          conditionMet = sensorValue >= condition.value;
          break;
        case 'lte':
          conditionMet = sensorValue <= condition.value;
          break;
      }
      
      if(conditionMet) {
        console.log(`条件满足: 传感器 ${condition.sensorId} 值 ${sensorValue} ${condition.comparison} ${condition.value}`);
        return true;
      }
      
      // 每秒检查一次
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 如果状态变为暂停或停止，中断检查
      if(this.status !== 'running') {
        throw new Error('流程已暂停或终止');
      }
    }
  },
  
  pauseWorkflow() {
    if(this.status === 'running') {
      this.status = 'paused';
      console.log('流程已暂停');
    }
  },
  
  resumeWorkflow() {
    if(this.status === 'paused') {
      this.status = 'running';
      console.log('流程已恢复');
    }
  },
  
  stopWorkflow() {
    this.status = 'idle';
    console.log('流程已终止');
  },

  // 从设备命令自动生成完成条件 - 增强版2.0
  generateCompletionConditions(deviceCommands) {
    const conditions = [];
    
    // 对命令进行优先级排序 - 某些命令的执行需要优先检查
    const prioritizedCommands = [...deviceCommands].sort((a, b) => {
      // 加热器设置温度的命令具有较高优先级，因为温度变化通常最慢
      if (a.deviceType === 'chip' && a.action === 'setTemp') return -1;
      if (b.deviceType === 'chip' && b.action === 'setTemp') return 1;
      
      // 泵设置位置的命令其次
      if (a.deviceType === 'pump' && a.action === 'setPosition') return -1;
      if (b.deviceType === 'pump' && b.action === 'setPosition') return 1;
      
      return 0; // 其他命令维持原顺序
    });
    
    // 为每个命令生成完成条件
    prioritizedCommands.forEach(cmd => {
      // 首先检查命令是否需要生成完成条件
      if (cmd.generateCompletionCondition === false) {
        console.log(`命令 ${cmd.deviceId}-${cmd.action} 已禁用自动生成完成条件`);
        return; // 跳过此命令
      }
      
      // 设置默认超时时间，如果命令中指定了则使用指定值
      const defaultTimeout = cmd.completionTimeout || 60;
      
      // 获取当前设备数据以供参考
      const device = globalDevices.value.get(cmd.deviceId);
      
      // 根据不同设备类型和命令生成不同的完成条件
      switch(cmd.deviceType) {
        case 'pump':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              tolerance: 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'aspirate' && cmd.parameters?.volume !== undefined) {
            // 吸取液体操作 - 需要监控位置变化
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'gte',
              value: cmd.parameters.volume * 0.95, // 至少达到设定体积的95%
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'dispense' && cmd.parameters?.volume !== undefined) {
            // 排出液体操作 - 需要监控位置变化
            const device = globalDevices.value.get(cmd.deviceId);
            const currentPosition = device?.position || 0;
            const targetPosition = Math.max(0, currentPosition - cmd.parameters.volume);
            
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: targetPosition + 10, // 允许10单位的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'setSpeed') {
            // 设置速度 - 监控速度是否已设置
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'speed',
              comparison: 'eq',
              value: cmd.parameters.speed,
              tolerance: 1, // 允许1%的误差
              timeout: 5 // 速度设置应该很快
            });
          } else if(cmd.action === 'empty') {
            // 清空泵 - 监控位置是否接近零
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'lte',
              value: 10, // 视为接近空
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'initialize') {
            // 初始化 - 监控状态变为idle
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'pump',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 5 // 停止应该很快
            });
          }
          break;
          
        case 'chip':
          if(cmd.action === 'setTemp' && cmd.parameters?.temperature !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              parameter: 'currentTemp',
              comparison: 'approx', // 使用更精确的近似比较
              value: cmd.parameters.temperature,
              tolerance: 2, // 允许2度的误差
              timeout: Math.max(120, defaultTimeout) // 加热需要较长时间，至少120秒
            });
          } else if(cmd.action === 'powerOn') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'heating',
              timeout: 10
            });
          } else if(cmd.action === 'powerOff') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'chip',
              deviceId: cmd.deviceId,
              status: 'idle',
              timeout: 10
            });
          }
          break;
          
        case 'valve':
          if(cmd.action === 'setPosition' && cmd.parameters?.position !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              parameter: 'position',
              comparison: 'eq',
              value: cmd.parameters.position,
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'open') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'open',
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'close') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'valve',
              deviceId: cmd.deviceId,
              status: 'closed',
              timeout: defaultTimeout
            });
          }
          break;
          
        case 'mfc':
          if(cmd.action === 'setFlowRate' && cmd.parameters?.flowRate !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              parameter: 'flowRate',
              comparison: 'approx',
              value: cmd.parameters.flowRate,
              tolerance: 0.2, // 允许0.2ml/min误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'start') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'running',
              timeout: 10
            });
          } else if(cmd.action === 'stop') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'mfc',
              deviceId: cmd.deviceId,
              status: 'stopped',
              timeout: 10
            });
          }
          break;
          
        case 'light':
          if(cmd.action === 'setIntensity' && cmd.parameters?.intensity !== undefined) {
            conditions.push({
              type: 'deviceParameter',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              parameter: 'intensity',
              comparison: 'approx',
              value: cmd.parameters.intensity,
              tolerance: 1, // 允许1%的误差
              timeout: defaultTimeout
            });
          } else if(cmd.action === 'on') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'on',
              timeout: 5
            });
          } else if(cmd.action === 'off') {
            conditions.push({
              type: 'deviceStatus',
              deviceType: 'light',
              deviceId: cmd.deviceId,
              status: 'off',
              timeout: 5
            });
          }
          break;
      }
    });
    
    // 记录生成的完成条件
    console.log(`为${deviceCommands.length}个命令生成了${conditions.length}个完成条件`);
    conditions.forEach((condition, index) => {
      console.log(`条件${index+1}:`, JSON.stringify(condition));
    });
    
    return conditions;
  }
});

// 添加操作到历史记录
const addToHistory = (operation) => {
  // 添加新操作到历史记录
  operationHistory.value.push(operation);
  
  // 如果历史记录超过最大长度，移除最早的记录
  if (operationHistory.value.length > maxHistoryLength) {
    operationHistory.value.shift();
  }
  
  console.log(`已添加操作到历史记录，当前历史长度: ${operationHistory.value.length}`);
};

// 进入硬件结构创建模式
const enterCreateMode = () => {
  isCreateMode.value = true;
  isSidebarOpen.value = true; // 确保侧边栏打开
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 重置拖拽和连线状态
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空操作历史
  operationHistory.value = [];
  
  // 初始化编辑状态 - 设置默认值
  currentEditPath.value = {
    name: '',
    type: 'custom',
    controllerIndex: 1
  };
  console.log("进入创建模式", isDragEnabled.value);
};

// 退出创建模式
const exitCreateMode = () => {
  isCreateMode.value = false;
  isEdgeMode.value = false;
  sourceNode.value = null;
  
  // 清空当前图
  graph.clear();
  graph.render();
  
  // 如果有选中的自定义路径，重新加载
  if (selectedPath.value && typeof selectedPath.value === 'object') {
    // 自定义路径
    loadStructureFromFile(selectedPath.value);
  }
};

// 从文件加载硬件结构
const loadStructureFromFile = async (path) => {
  try {
    isLoading.value = true;
    console.log("尝试加载硬件结构:", path);
    
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 1. 首先尝试从新的API路径获取文件内容
    const pathId = path.id || path.name; // 使用ID优先，否则使用name
    console.log("正在从API加载路径ID:", pathId);
    
    try {
      const response = await axios.get(`${baseUrl}/api/devices/path/${encodeURIComponent(pathId)}`);
      
      if (response.data.code !== 0 || !response.data.data) {
        throw new Error("API返回错误或数据为空");
      }
      
      const pathConfig = response.data.data;
      console.log("从API加载的路径数据:", pathConfig);
      
      // 确保图表已初始化
      if (!graph) {
        console.error("图表实例未初始化，无法加载路径");
        errorMessage.value = "图表实例未初始化，请刷新页面重试";
        return;
      }
      
      // 重新初始化图表以解决潜在的渲染问题
      // 1. 获取容器尺寸
      const containerEl = container.value;
      if (!containerEl) {
        errorMessage.value = "找不到图表容器";
        return;
      }
      
      const graphWidth = containerEl.clientWidth || 800;
      const graphHeight = containerEl.clientHeight || 600;
      
      // 2. 销毁旧图表
      if (graph) {
        graph.destroy();
      }
      
      // 3. 创建新图表
      console.log(`重新初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
      graph = new Graph({
        container: containerEl,
        width: graphWidth,
        height: graphHeight,
        behaviors: [
          
          {
            type: 'zoom-canvas',
            sensitivity: 1.5,
            key: 'zoom-canvas',
            enable: true
          },
          {
            type: 'click-select',
            key: 'click-select',
            enable: true
          },
          {
            type: 'drag-element',
            key: 'drag-element',
            enable: true,
            shouldBegin: (e) => {
              return isCreateMode.value && isAdmin.value;
            }
          }
        ],
        node: {
          style: {
            fill: '#91d5ff',
            stroke: '#40a9ff',
            lineWidth: 1,
            radius: 6,
            cursor: 'move'
          }
        },
        edge: {
          style: {
            stroke: '#91d5ff',
            lineWidth: 2,
            endArrow: {
              fill: '#91d5ff',
              stroke: '#91d5ff'
            }
          }
        }
      });
      
      // 重新注册事件
      graph.on('node:click', handleDeviceClick);
      
      // 处理和添加节点
      const nodesData = [];
      if (pathConfig.data && pathConfig.data.nodes && Array.isArray(pathConfig.data.nodes)) {
        for (const node of pathConfig.data.nodes) {
          if (!node.id) continue;
          
          // 创建标准节点数据
          const processedNode = {
            id: node.id,
            type: "image",
            data: {
              deviceType: node.data?.deviceType || node.id.split('-')[0] || 'unknown',
              label: node.data?.label || "设备"
            },
            style: {
              x: node.style?.x || 100 + Math.random() * 300,
              y: node.style?.y || 100 + Math.random() * 200,
              size: node.style?.size || [40, 40],
              label: node.style?.label || `设备 (${node.id})`,
              labelCfg: {
                position: "bottom",
                offset: [0, 5],
                style: {
                  fill: "#333",
                  fontSize: 12
                }
              }
            }
          };
          
          // 设置图标
          const deviceType = processedNode.data.deviceType;
          switch (deviceType) {
            case "pump": 
              processedNode.style.src = pump; // 使用JPG图片
              processedNode.style.label = node.style?.label || `泵 (${node.id})`;
              // 针对JPG格式图片调整尺寸，确保正确显示
              processedNode.style.size = [40, 40];
              break;
            case "valve": 
              processedNode.style.src = valve; // 使用JPG图片
              processedNode.style.label = node.style?.label || `阀 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "chip": 
              processedNode.style.src = chip; // 使用JPG图片
              processedNode.style.label = node.style?.label || `加热芯片 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            case "mfc": 
              processedNode.style.src = mfc; 
              processedNode.style.label = node.style?.label || `MFC控制器 (${node.id})`;
              break;
            case "light": 
              processedNode.style.src = light; 
              processedNode.style.label = node.style?.label || `光照控制 (${node.id})`;
              break;
            case "bottle": 
              processedNode.style.src = bottle; // 使用JPG图片
              processedNode.style.label = node.style?.label || `瓶 (${node.id})`;
              processedNode.style.size = [40, 40];
              break;
            default:
              // 如果没有匹配的图标，使用通用图标
              processedNode.style.src = bottle;
          }
          
          nodesData.push(processedNode);
        }
      }
      
      console.log("处理后的节点数据:", nodesData);
      
      // 添加节点到图表
      if (nodesData.length > 0) {
        graph.addNodeData(nodesData);
      } else {
        console.warn("没有有效的节点数据");
      }
      
      // 处理和添加边
      const edgesData = [];
      if (pathConfig.data && pathConfig.data.edges && Array.isArray(pathConfig.data.edges)) {
        for (const edge of pathConfig.data.edges) {
          if (!edge.source || !edge.target) continue;
          
          // 创建标准边数据
          const processedEdge = {
            id: edge.id || `edge-${Math.random().toString(36).substr(2, 9)}`,
            source: edge.source,
            target: edge.target,
            style: {
              stroke: '#91d5ff',
              lineWidth: 2,
              endArrow: {
                fill: '#91d5ff',
                stroke: '#91d5ff'
              }
            }
          };
          
          // 复制其他属性
          if (edge.style) {
            Object.assign(processedEdge.style, edge.style);
          }
          
          edgesData.push(processedEdge);
        }
      }
      
      console.log("处理后的边数据:", edgesData);
      
      // 添加边到图表
      if (edgesData.length > 0) {
        graph.addEdgeData(edgesData);
      }
      
      // 渲染图表
      try {
        console.log("开始渲染图表...");
        
        // 延迟渲染，等待DOM更新
        setTimeout(() => {
          graph.render();
          console.log("图表渲染完成");
          
          // 自动调整视图以适应所有元素
          if (nodesData.length > 0) {
            graph.fitView();
          }
          
          // 硬件图加载完成，初始化反应路径
          onGraphLoaded();
        }, 100);
      } catch (renderError) {
        console.error("图表渲染失败:", renderError);
        errorMessage.value = `图表渲染失败: ${renderError.message}`;
      }
      
      onHardwareStructureLoaded();
      // 更新当前选中的路径
      selectedPath.value = path;
      
      // 设置控制器索引
      if (pathConfig.controllerIndex !== undefined) {
        selectedControllerIndex.value = pathConfig.controllerIndex;
      }
    } catch (apiError) {
      console.error("从API加载路径失败:", apiError);
      errorMessage.value = `加载路径失败: ${apiError.message}`;
    }
  } catch (error) {
    console.error("加载硬件结构失败:", error);
    errorMessage.value = `加载硬件结构失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};


// 向图中添加设备节点
const addDeviceToGraph = (device, iconSrc, label, x, y) => {
  if (!graph) {
    console.error("添加设备失败：图表未初始化");
    return;
  }
  
  console.log("添加设备到图中:", device, "位置:", x, y, "图标:", iconSrc);
  
  try {
    // 检查节点是否已存在
    const existingNode = graph.getNodeData().find(node => node.id === device.id);
    if (existingNode) {
      console.log(`节点 ${device.id} 已存在于图中，不重复添加`);
      
      // 更新节点外观以反映状态
      updateNodeAppearance(device.id, device.status);
      return;
    }
    
    // 要添加的节点数据
    const nodeData = {
      id: device.id,
      type: "image",
      data: {
        label: label,
        deviceType: device.type,
        nodeType: device.type,
        deviceData: device,
        // 记录图片格式信息
        imgFormat: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? 'jpg' : 'svg'
      },
      style: {
        src: iconSrc,
        x: x,
        y: y,
        // 调整图片尺寸，确保JPG图片显示正确
        size: ['pump', 'valve', 'chip', 'bottle'].includes(device.type) ? [40, 40] : [40, 40],
        label: device.moduleMetadata 
          ? `${label} (${device.moduleMetadata.moduleName} #${device.moduleMetadata.moduleId})` 
          : `${label} (${device.id})`,
        labelCfg: {
          position: "bottom",
          offset: [0, 5],
          style: {
            fill: "#333",
            fontSize: 12
          }
        },
        cursor: "move",
        // 节点外观
        fill: "rgba(255, 255, 255, 0.9)",
        stroke: "#1890ff",
        lineWidth: 1,
        radius: 6,
        shadowColor: "rgba(0,0,0,0.1)",
        shadowBlur: 5
      }
    };
    
    // 打印完整节点数据用于调试
    console.log("添加节点详细数据:", JSON.stringify(nodeData, null, 2));
    console.log("isDragEnabled", isDragEnabled.value);
    // 添加节点
    graph.addNodeData([nodeData]);
    
    // 确保拖拽行为正确
    updateDragBehavior();
    
    // 如果在创建模式下，记录此操作以支持撤销
    if (isCreateMode.value) {
      addToHistory({
        type: 'addNode',
        nodeId: device.id,
        nodeData: nodeData
      });
    }
    
    // 更新节点外观以反映状态
    updateNodeAppearance(device.id, device.status);
    
    // 确保渲染更新 - 这是关键步骤
    graph.render();
    
    console.log("节点添加成功，已渲染");
  } catch (error) {
    console.error("添加设备到图中失败:", error);
    errorMessage.value = `添加设备到图中失败: ${error.message}`;
  }
};

// 保存当前硬件结构
const saveCurrentPath = async () => {
  try {
    // 检查是否输入了名称
    if (!pathName.value.trim()) {
      errorMessage.value = "请输入硬件结构名称";
      return;
    }
    
    isLoading.value = true;
    
    // 获取当前图的数据
    const nodes = graph.getNodeData();
    const edges = graph.getEdgeData();
    
    console.log("正在保存硬件结构，节点数据:", nodes);
    console.log("正在保存硬件结构，边数据:", edges);
    
    // 修改nodes，保存完整的节点信息以便正确恢复
    const simplifiedNodes = nodes.map(node => {
      const deviceType = node.data?.deviceType || (node.id.split('-')[0]);
      
      // 需要保留的关键样式属性
      const style = {
        x: node.style?.x || 0,
        y: node.style?.y || 0,
        src: node.style?.src,
        size: node.style?.size,
        label: node.style?.label,
        labelCfg: node.style?.labelCfg,
        cursor: node.style?.cursor,
        fill: node.style?.fill,
        stroke: node.style?.stroke,
        lineWidth: node.style?.lineWidth,
        radius: node.style?.radius,
        shadowColor: node.style?.shadowColor,
        shadowBlur: node.style?.shadowBlur
      };
      
      return {
        id: node.id,
        type: node.type,
        data: {
          label: node.data?.label || "",
          deviceType: deviceType,
          nodeType: node.data?.nodeType || deviceType,
          deviceData: node.data?.deviceData
        },
        style: style
      };
    });
    
    // 处理图片路径问题，防止序列化错误
    const serializedNodes = fixImageSrcForSerialization(simplifiedNodes);
    
    console.log("处理后的节点数据:", serializedNodes);
    
    // 创建路径配置对象
    const pathConfig = {
      name: pathName.value,
      description: pathDescription.value || '',
      createdBy: 'user', // 可以从用户系统获取
      type: 'custom', // 使用自定义类型
      controllerIndex: selectedControllerIndex.value || 1,
      data: {
        nodes: serializedNodes,
        edges
      }
    };
    
    console.log("正在保存硬件结构，数据:", pathConfig);
    
    // 使用服务器的完整URL
    // 在开发环境中，需要指定后端服务器地址
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 调用API保存到服务器 - 使用新的API路径
    const response = await axios.post(`${baseUrl}/api/devices/path`, pathConfig);
    
    console.log("保存路径响应:", response);
    
    if (response.data.code === 0) {
      // 保存成功
      // 1. 更新当前编辑的路径
      const savedPath = response.data.data;
      currentEditPath.value = savedPath;
      selectedPath.value = savedPath;
      
      // 2. 更新路径列表
      let updatedPaths = [...savedPaths.value];
      const existingIndex = updatedPaths.findIndex(p => p.name === savedPath.name);
      
      if (existingIndex >= 0) {
        // 更新现有路径
        updatedPaths[existingIndex] = savedPath;
      } else {
        // 添加新路径
        updatedPaths.push(savedPath);
      }
      
      // 3. 保存到本地存储
      savedPaths.value = updatedPaths;
      localStorage.setItem('savedReactionPaths', JSON.stringify(updatedPaths));
      
      // 提示用户
      alert(`硬件结构 "${pathName.value}" 已保存成功!`);
      
      // 关闭对话框
      isShowPathNameDialog.value = false;
    } else {
      errorMessage.value = response.data.msg || "保存失败，请重试";
    }
  } catch (error) {
    console.error("保存硬件结构失败:", error);
    errorMessage.value = `保存失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};



// 拖拽开始
const handleDragStart = (e, icon) => {
  draggedIcon = icon;
  e.dataTransfer.setData('text/plain', JSON.stringify({ type: icon.type }));
  e.dataTransfer.effectAllowed = 'copy';
};

// 拖拽结束
const handleDragEnd = () => {
  draggedIcon = null;
};

// 处理节点点击，用于连线
const handleNodeClick = e => {
  if (!isEdgeMode.value) return;

  // 打印关键信息而非整个事件对象，避免循环引用问题
  console.log("点击节点事件:", {
    type: e.type,
    target: e.target ? { type: e.target.type } : null,
    item: e.item ? { id: e.item.id, type: e.item.type } : null,
    itemId: e.itemId
  });

  // G6 v5中，节点ID可能在不同位置
  let nodeId = null;

  // 尝试不同路径获取节点ID
  if (e.itemId) {
    nodeId = e.itemId;
  } else if (e.item && e.item.id) {
    nodeId = e.item.id;
  } else if (e.target && e.target.get && typeof e.target.get === "function") {
    try {
      nodeId = e.target.get("id");
    } catch (err) {
      console.log("获取target.id失败:", err);
    }
  } else if (
    e.currentTarget &&
    e.currentTarget.get &&
    typeof e.currentTarget.get === "function"
  ) {
    try {
      nodeId = e.currentTarget.get("id");
    } catch (err) {
      console.log("获取currentTarget.id失败:", err);
    }
  }

  console.log("获取到的节点ID:", nodeId);

  if (!nodeId) {
    console.error("无法获取节点ID");
    // 尝试直接从原始节点数据获取ID
    if (e.item && e.item.getModel) {
      try {
        const model = e.item.getModel();
        nodeId = model.id;
        console.log("从model获取到ID:", nodeId);
      } catch (err) {
        console.log("获取model失败:", err);
      }
    }

    if (!nodeId) return;
  }

  // 若还没选中源节点，则将当前点击节点设为源节点
  if (!sourceNode.value) {
    sourceNode.value = nodeId;
    // 高亮源节点 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          fill: "#1890ff",
          stroke: "#096dd9"
        }
      }
    ]);
  } else if (sourceNode.value !== nodeId) {
    // 已选中源节点，且当前点击了不同的节点，创建连线
    const edgeId = `edge-${Date.now()}`;

    // 边数据
    const edgeData = {
      id: edgeId,
      source: sourceNode.value,
      target: nodeId,
      data: {
        label: "", // 可选: 添加边标签
        weight: 1
      },
      style: {
        stroke: "#1890ff",
        lineWidth: 2,
        endArrow: true
      }
    };

    // 添加边 - 按照最新G6文档的方式
    graph.addEdgeData([edgeData]);
    
    // 记录添加边的操作
    if (isCreateMode.value) {
      addToHistory({
        type: 'addEdge',
        edgeId: edgeId,
        edgeData: edgeData
      });
    }

    // 取消源节点的高亮 - 使用G6 v5中的正确方法
    graph.updateNodeData([
      {
        id: sourceNode.value,
        style: {
          fill: "#91d5ff", // 恢复默认颜色
          stroke: "#40a9ff"
        }
      }
    ]);

    // 重置源节点
    sourceNode.value = null;

    // 渲染更新
    graph.render();
  }
};

// 从后端获取设备信息
const fetchDeviceInfo = async (deviceId) => {
  if (!deviceId) {
    console.warn("无效的设备ID");
    return null;
  }
  
  console.log("获取设备信息:", deviceId);
  
  try {
    // 尝试从缓存获取设备类型
    let deviceType = null;
    
    // 从设备ID推断类型
    if (deviceId.includes("pump")) {
      deviceType = "pump";
    } else if (deviceId.includes("valve")) {
      deviceType = "valve";
    } else if (deviceId.includes("chip")) {
      deviceType = "chip";
    } else if (deviceId.includes("mfc")) {
      deviceType = "mfc";
    } else if (deviceId.includes("light")) {
      deviceType = "light";
    }
    
    // 首先尝试通过WebSocket获取设备信息
    if (wsConnected.value) {
      console.log("尝试通过WebSocket获取设备信息");
      const deviceInfoPromise = new Promise((resolve, reject) => {
        // 设置超时
        const timeout = setTimeout(() => {
          console.warn("WebSocket获取设备信息超时");
          resolve(null); // 超时时返回null
        }, 3000);
        
        // 创建一次性的消息监听器
        let messageHandler = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("收到WebSocket消息:", data);
            
            // 如果是设备信息响应或错误响应
            if (data.type === 'deviceInfo' && data.data && data.data.id === deviceId) {
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              console.log("成功获取到设备信息:", data.data);
              resolve(data.data);
            } else if (data.type === 'error' && data.data && data.data.message && data.data.message.includes(deviceId)) {
              console.warn("WebSocket返回错误:", data.data);
              clearTimeout(timeout);
              ws.value.removeEventListener('message', messageHandler);
              
              // 如果是"设备不存在"错误，尝试注册设备
              if (data.data.message.includes("不存在") && deviceType) {
                console.log(`设备 ${deviceId} 不存在`);
                // 返回默认数据
                resolve(null);
              } else {
                // 其他错误则返回null
                resolve(null);
              }
            }
          } catch (error) {
            console.error("解析WebSocket消息失败:", error);
            ws.value.removeEventListener('message', messageHandler);
            clearTimeout(timeout);
            resolve(null);
          }
        };
        
        // 添加临时消息监听
        if (ws.value) {
          ws.value.addEventListener('message', messageHandler);
        }
        
        // 发送WebSocket消息获取设备信息
        const success = sendWsMessage({
          type: 'getDeviceInfo', // 使用正确的消息类型
          payload: { id: deviceId }
        });
        
        if (!success) {
          console.warn("WebSocket消息发送失败");
          clearTimeout(timeout);
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
          resolve(null);
        }
        
        // 在超时后移除监听器
        setTimeout(() => {
          if (ws.value) {
            ws.value.removeEventListener('message', messageHandler);
          }
        }, 3000);
      });
      
      const deviceInfo = await deviceInfoPromise;
      if (deviceInfo) {
        return deviceInfo;
      }
    }
    // 如果失败，使用默认值
    console.log(`无法从后端获取设备 ${deviceId} 的信息，使用默认值`);
    
    // 如果无法确定设备类型，返回null
    console.warn("无法确定设备类型，无法创建默认信息");
    return null;
  } catch (error) {
    console.error("获取设备信息失败:", error);
    return null;
  }
};

// 处理设备点击事件
const handleDeviceClick = async (e) => {
  try {
    // 连线模式下使用原来的点击逻辑
    if (isEdgeMode.value) {
      handleNodeClick(e);
      return;
    }

    // 获取节点ID
    let nodeId = null;
    if (e.itemId) {
      nodeId = e.itemId;
    } else if (e.item && e.item.id) {
      nodeId = e.item.id;
    } else if (e.target && e.target.get && typeof e.target.get === "function") {
      try {
        nodeId = e.target.get("id");
      } catch (err) {
        console.log("获取target.id失败:", err);
      }
    }

    if (!nodeId) {
      console.warn("无法获取节点ID，取消处理设备点击");
      return;
    }

    // 使用新的selectDevice函数处理设备选择
    selectDevice(nodeId);
  } catch (error) {
    console.error("处理设备点击失败:", error);
    errorMessage.value = `处理设备点击失败: ${error.message}`;
  }
};

// 更新节点外观以反映设备状态
const updateNodeAppearance = (nodeId, status) => {
  console.log('!!!!!!!!!!!!更新节点外观:', nodeId, status);
  if (!graph) return;
  
  try {
    let strokeColor = "#1890ff"; // 默认边框颜色
    let shadowColor = "rgba(0,0,0,0.1)"; // 默认阴影颜色
    
    // 根据状态设置样式
    switch (status) {
      case "running":
    case "open":
      case "heating":
        strokeColor = "#67c23a"; // 绿色
        shadowColor = "rgba(103, 194, 58, 0.3)";
      break;
      case "stopped":
      case "closed":
      case "idle":
        strokeColor = "#909399"; // 灰色
        shadowColor = "rgba(144, 147, 153, 0.3)";
      break;
      case "error":
        strokeColor = "#f56c6c"; // 红色
        shadowColor = "rgba(245, 108, 108, 0.3)";
        break;
      case "cooling":
        strokeColor = "#1890ff"; // 蓝色
        shadowColor = "rgba(24, 144, 255, 0.3)";
      break;
    }
    
    // 更新节点样式
    graph.updateNodeData([
      {
        id: nodeId,
        style: {
          stroke: strokeColor,
          shadowColor: shadowColor,
          shadowBlur: 10
        }
      }
    ]);
    graph.render();
  } catch (error) {
    console.error("更新节点外观失败:", error);
  }
};

// 控制面板显示状态
const showControlPanel = ref(false);

// 关闭控制面板
const closeControlPanel = () => {
  showControlPanel.value = false;
  selectedDevice.value = null;
  // 重置控制参数对象
  controlParams.value = {};
};

// 控制拖拽功能启用/禁用
const updateDragBehavior = () => {
  if (!graph) return;

  // 使用计算属性来决定是否启用拖拽
  const enableDrag = isDragEnabled.value;

  try {
    // 更新拖拽节点行为
    graph.updateBehavior({
      key: "drag-node",
      enable: enableDrag
    });

    // 更新节点选择行为
    graph.updateBehavior({
      key: "click-select",
      enable: enableDrag
    });
    
    // 更新鼠标样式提示
    if (container.value) {
      container.value.style.cursor = enableDrag ? "default" : "not-allowed";
    }
    
    console.log(`拖拽行为已${enableDrag ? '启用' : '禁用'}, 创建模式: ${isCreateMode.value}`);
  } catch (err) {
    console.error("更新拖拽行为失败:", err);
  }
};

// 监听拖拽启用状态变化
watch(isDragEnabled, () => {
  updateDragBehavior();
});

// 切换连线模式
const toggleEdgeMode = () => {
  isEdgeMode.value = !isEdgeMode.value;

  if (!isEdgeMode.value) {
    // 退出连线模式时，如果有高亮的节点，取消高亮
    if (sourceNode.value) {
      // 使用G6 v5中的正确方法恢复节点样式
      graph.updateNodeData([
        {
          id: sourceNode.value,
          style: {
            fill: "#91d5ff", // 恢复默认颜色
            stroke: "#40a9ff"
          }
        }
      ]);
    }
    // 清空选中的源节点
    sourceNode.value = null;
  }

  // 更新鼠标样式和拖拽行为
  if (graph) {
    if (isEdgeMode.value) {
      // 进入连线模式，修改画布样式
      container.value.style.cursor = "crosshair";

      // 禁用拖拽节点行为
      graph.updateBehavior({
        key: "drag-node",
        enable: false
      });
    } else {
      // 退出连线模式时，调用updateDragBehavior
      // 这将根据侧边栏状态和管理员状态决定是否启用拖拽
      updateDragBehavior();
    }
  }
};

// 定时刷新设备数据
let refreshInterval = null;

// 启动定时刷新
const startDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
  }
  
  refreshInterval = setInterval(async () => {
    // 如果当前有选中的设备，刷新其数据
    if (selectedDevice.value && showControlPanel.value) {
      try {
        const updatedDevice = await fetchDeviceInfo(selectedDevice.value);
        if (updatedDevice) {
          // 只更新设备状态数据，不影响控制参数
          deviceData.value = updatedDevice;
          // 同时更新节点外观
          updateNodeAppearance(selectedDevice.value, updatedDevice.status);
        }
      } catch (error) {
        console.error("刷新设备数据失败:", error);
      }
    }
  }, 3000); // 每3秒刷新一次
};

// 停止定时刷新
const stopDeviceDataRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
};


// WebSocket连接状态
const wsConnected = ref(false);
const ws = ref(null);

// 调整图形大小的函数
const resizeGraph = () => {
  if (!graph || !container.value) return;
  
  const width = container.value.clientWidth;
  const height = container.value.clientHeight || 600;
  
  graph.setSize([width, height]);
  graph.render();
  console.log(`调整图形大小至 ${width}x${height}`);
};

// 修改WebSocket连接成功后的处理
const handleWsOpen = () => {
  console.log('WebSocket连接已建立');
  wsConnected.value = true;
  
  // 发送验证信息
  if (localStorage.token) {
    const authMessage = {
      type: 'authenticate',
      token: localStorage.token
    };
    sendWsMessage(authMessage);
  }
  
  // 连接成功后自动获取硬件状态
  setTimeout(() => {
    sendWsMessage({
      type: 'getHardwareStatus'
    });
    
    // 同时获取所有设备列表
    sendWsMessage({
      type: 'getDevices'
    });
  }, 500);
};

// 连接WebSocket服务器
const connectWebSocket = async () => {
  try {
    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
      console.log('WebSocket已连接');
      return;
    }
    
    // 关闭之前的连接
    if (ws.value) {
      manualClose.value = true;
      ws.value.close();
    }
    
    manualClose.value = false;
    
    console.log("尝试连接WebSocket服务器...");
    // 确定WebSocket连接地址
    const baseUrl = process.env.NODE_ENV === 'development'
      ? 'ws://localhost:3000'
      : window.location.origin.replace(/^http/, 'ws');
    const wsUrl = `${baseUrl}/api/devices/realtime`;
    
    ws.value = new WebSocket(wsUrl);
    
    ws.value.onopen = handleWsOpen;
    
    ws.value.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('收到WebSocket消息:', data);
        handleWsMessage(data);
      } catch (error) {
        console.error('WebSocket消息解析错误:', error);
      }
    };
    
    ws.value.onclose = (event) => {
      console.log('WebSocket连接已关闭', event.code, event.reason);
      wsConnected.value = false;

      // 如果不是用户主动关闭，则尝试重连
      if (!manualClose.value) {
        console.log("尝试重新连接...");
        setTimeout(connectWebSocket, 5000);
      }
    };

    ws.value.onerror = (error) => {
      console.error('WebSocket错误:', error);
      wsConnected.value = false;
      errorMessage.value = '无法连接到WebSocket服务器';
    };
  } catch (error) {
    console.error('创建WebSocket实例失败:', error);
    wsConnected.value = false;
    errorMessage.value = `创建WebSocket连接失败: ${error.message}`;
  }
};


// 更新设备状态
const updateDeviceStatus = (deviceData) => {
  // 首先更新全局设备仓库
  if (deviceData.id) {
    // 如果设备已存在，合并数据；否则添加新设备
    if (globalDevices.value.has(deviceData.id)) {
      const existingDevice = globalDevices.value.get(deviceData.id);
      
      // 检查是否有该设备的待发送更改
      const deviceKey = `${deviceData.type}_${deviceData.id}`;
      const hasPendingChanges = pendingChanges.value.has(deviceKey);
      
      // 合并设备数据，但保留待发送的本地修改
      const updatedDevice = {...existingDevice, ...deviceData};
      
      // 如果有待发送更改，保留用户编辑的值
      if (hasPendingChanges) {
        const pendingParams = pendingChanges.value.get(deviceKey).params;
        Object.keys(pendingParams).forEach(key => {
          updatedDevice[key] = pendingParams[key];
        });
      }
      
      globalDevices.value.set(deviceData.id, updatedDevice);
    } else {
      globalDevices.value.set(deviceData.id, deviceData);
    }
    
    // 更新图上的设备节点状态
    if (graph) {
      const node = graph.findById(deviceData.id);
      if (node) {
        // 更新节点状态
        graph.updateItem(node, {
          status: deviceData.status,
          ...deviceData
        });
      }
    }
    
    // 如果是当前选中的设备，从全局仓库获取最新数据更新控制面板
    if (selectedDevice.value === deviceData.id) {
      const updatedDeviceData = globalDevices.value.get(deviceData.id);
      // 深拷贝确保控制面板数据独立
      deviceData.value = JSON.parse(JSON.stringify(updatedDeviceData));
    }
  }
};

// 发送WebSocket消息
const sendWsMessage = (message) => {
  if (ws.value && ws.value.readyState === WebSocket.OPEN) {
    try {
      const messageStr = JSON.stringify(message);
      ws.value.send(messageStr);
      console.log("已发送WebSocket消息:", message);
      
      // 如果是设备控制命令，记录到全局设备仓库中以保持UI一致性
      if (message.type === 'updateDeviceParameters' && message.payload) {
        const commands = Array.isArray(message.payload) ? message.payload : [message.payload];
        
        commands.forEach(command => {
          if (command.id && globalDevices.value.has(command.id)) {
            // 根据命令更新全局设备状态
            const device = globalDevices.value.get(command.id);
            const updatedDevice = {...device};
            
            // 根据命令类型预测设备状态变化
            switch (command.action) {
              case 'start':
                updatedDevice.status = 'running';
                break;
              case 'stop':
                updatedDevice.status = 'idle';
                break;
              case 'setPosition':
                if (command.parameters && command.parameters.position !== undefined) {
                  updatedDevice.position = command.parameters.position;
                }
                break;
              case 'setTemp':
                if (command.parameters) {
                  if (command.parameters.temperature !== undefined) {
                    updatedDevice.targetTemp = command.parameters.temperature;
                    updatedDevice.status = 'heating';
                  }
                  if (command.parameters.speed !== undefined) {
                    updatedDevice.heatingSpeed = command.parameters.speed;
                  }
                }
                break;
              case 'setFlowRate':
                if (command.parameters && command.parameters.flowRate !== undefined) {
                  updatedDevice.flowRate = command.parameters.flowRate;
                }
                break;
              case 'setIntensity':
                if (command.parameters && command.parameters.intensity !== undefined) {
                  updatedDevice.intensity = command.parameters.intensity;
                }
                break;
              // 可以添加更多命令类型
            }
            
            // 更新参数
            if (command.parameters) {
              // 将命令参数合并到设备数据中
              Object.assign(updatedDevice, command.parameters);
            }
            
            // 更新全局设备仓库
            globalDevices.value.set(command.id, updatedDevice);
            
            // 如果是当前选中的设备，更新控制面板
            if (selectedDevice.value === command.id) {
              deviceData.value = JSON.parse(JSON.stringify(updatedDevice));
            }
            
            // 更新设备节点外观
            updateNodeAppearance(command.id, updatedDevice.status);
          }
        });
      }
      
      return true;
    } catch (error) {
      console.error("发送WebSocket消息失败:", error);
      return false;
    }
  } else {
    console.warn("WebSocket未连接，无法发送消息，当前状态:", ws.value ? ws.value.readyState : "无WebSocket实例");
    return false;
  }
};



// 是否手动关闭WebSocket连接
const manualClose = ref(false);

// 处理WebSocket消息
const handleWsMessage = (data) => {
  if (!data || !data.type) return;
  
  
  switch (data.type) {
    case 'connection':
      console.log("WebSocket连接成功:", data.data);
      break;
      
    case 'devices':
      // 收到所有设备列表
      if (data.data && Array.isArray(data.data)) {
        // 更新全局设备仓库
        data.data.forEach(device => {
          globalDevices.value.set(device.id, device);
        });
        console.log(`全局设备仓库已更新，共 ${globalDevices.value.size} 个设备`);
        
        // 如果已有选中的路径，加载设备到图中
        if (selectedPath.value) {
          (selectedPath.value);
        }
      }
      break;
      
    case 'deviceInfo':
      // 设备信息响应 - 单个设备的详细信息
      console.log("收到设备信息:", data.data);
      if (data.data && data.data.id) {
        // 更新设备节点外观
        updateDeviceOnGraph(data.data);
        
        // 如果是当前选中设备，更新控制面板
        if (selectedDevice.value === data.data.id) {
          deviceData.value = data.data;
        }
      }
      break;
      
    case 'commandResult':
      // 命令执行结果
      console.log("命令执行结果:", data.data);
      if (data.data && data.data.success) {
        // 命令成功，根据命令类型和参数更新本地设备状态
        const command = data.data.command;
        if (command && command.id) {
          // 如果命令中包含了更新后的设备数据，直接使用
          if (data.data.deviceData) {
            updateDeviceOnGraph(data.data.deviceData);
            
            // 如果是当前选中的设备，更新控制面板
            if (selectedDevice.value === command.id) {
              deviceData.value = data.data.deviceData;
            }
          } 
          // 否则，根据命令类型预测状态变化
          else if (command.type && command.action) {
            // 获取当前设备数据的副本
            let updatedDevice = null;
            
            // 如果是当前选中的设备，从deviceData中获取
            if (selectedDevice.value === command.id) {
              updatedDevice = { ...deviceData.value };
            } 
            // 否则尝试从图中获取
            else {
              try {
                const node = graph?.getNodeData?.(command.id);
                if (node && node.data && node.data.deviceData) {
                  updatedDevice = { ...node.data.deviceData };
                }
      } catch (err) {
                console.log("获取node数据失败:", err);
              }
            }
            
            // 如果找到了设备数据，根据命令更新状态
            if (updatedDevice) {
              // 根据命令类型和动作更新设备状态
              switch (command.type) {
                case 'pump':
                  switch (command.action) {
                    case 'start':
                      updatedDevice.status = 'running';
                      break;
                    case 'stop':
                      updatedDevice.status = 'stopped';
                      break;
                    case 'setSpeed':
                      if (command.parameters && command.parameters.speed !== undefined) {
                        updatedDevice.speed = command.parameters.speed;
                        updatedDevice.flowRate = (command.parameters.speed / 100) * 5; // 假设最大流速为5mL/min
                      }
                      break;
                  }
                  break;
                  
                case 'valve':
                  switch (command.action) {
                    case 'open':
                      updatedDevice.status = 'open';
                      updatedDevice.position = 100;
                      break;
                    case 'close':
                      updatedDevice.status = 'closed';
                      updatedDevice.position = 0;
                      break;
                    case 'setPosition':
                      if (command.parameters && command.parameters.position !== undefined) {
                        updatedDevice.position = command.parameters.position;
                        if (updatedDevice.position > 0) {
                          updatedDevice.status = 'open';
                        } else {
                          updatedDevice.status = 'closed';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'chip':
                  switch (command.action) {
                    case 'powerOn':
                      updatedDevice.status = 'heating';
                      updatedDevice.power = 50; // 默认50%功率
                      break;
                    case 'powerOff':
                      updatedDevice.status = 'idle';
                      updatedDevice.power = 0;
                      break;
                    case 'setTemp':
                      if (command.parameters && command.parameters.temperature !== undefined) {
                        updatedDevice.targetTemp = command.parameters.temperature;
                        if (updatedDevice.targetTemp > updatedDevice.currentTemp) {
                          updatedDevice.status = 'heating';
                        } else if (updatedDevice.targetTemp < updatedDevice.currentTemp) {
                          updatedDevice.status = 'cooling';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'mfc':
                  switch (command.action) {
                    case 'start':
                      updatedDevice.status = 'running';
                      break;
                    case 'stop':
                      updatedDevice.status = 'stopped';
                      break;
                    case 'setFlow':
                      if (command.parameters && command.parameters.flowRate !== undefined) {
                        updatedDevice.flowRate = command.parameters.flowRate;
                        if (updatedDevice.flowRate > 0) {
                          updatedDevice.status = 'running';
                        } else {
                          updatedDevice.status = 'stopped';
                        }
                      }
                      break;
                  }
                  break;
                  
                case 'light':
                  switch (command.action) {
                    case 'on':
                      updatedDevice.status = 'on';
                      break;
                    case 'off':
                      updatedDevice.status = 'off';
                      break;
                    case 'setIntensity':
                      if (command.parameters && command.parameters.intensity !== undefined) {
                        updatedDevice.intensity = command.parameters.intensity;
                        if (updatedDevice.intensity > 0) {
                          updatedDevice.status = 'on';
                        } else {
                          updatedDevice.status = 'off';
                        }
                      }
                      break;
                  }
                  break;
              }
              
              // 更新图上的设备状态
              updateDeviceOnGraph(updatedDevice);
              
              // 如果是当前选中设备，更新控制面板
              if (selectedDevice.value === command.id) {
                deviceData.value = updatedDevice;
              }
            }
          }
        }
      }
      isLoading.value = false;
      break;
      
    case 'parameterUpdateResults':
      // 批量参数更新结果
      console.log("收到参数更新结果:", data.data);
      
      // 处理批量结果
      if (data.data) {
        // 使用后端提供的统计数据
        const { results, totalCommands, successCount, failedCount, message, actualSentCommands } = data.data;
        
        // 如果有消息字段，说明是特殊情况（如所有参数都是最新状态）
        if (message) {
          console.log(message);
          // 显示信息提示
          ElMessage.info(message);
          isLoading.value = false;
          isCommandSending.value = false;
          pendingChanges.value.clear();
          return;
        }
        
        // 处理每个设备的更新结果
        if (Array.isArray(results)) {
          const errorMessages = [];
          
          // 处理每个设备的更新结果
          results.forEach(result => {
            if (result.success) {
              // 如果包含了更新后的设备数据，直接使用
              if (result.deviceData) {
                // 更新全局设备仓库
                if (result.deviceData.id) {
                  globalDevices.value.set(result.deviceData.id, result.deviceData);
                }
                
                // 更新设备节点外观
                updateDeviceOnGraph(result.deviceData);
                
                // 如果是当前选中的设备，更新控制面板
                if (selectedDevice.value === result.deviceData.id) {
                  deviceData.value = result.deviceData;
                }
              }
              // 否则使用设备ID从全局仓库获取并预测更新
              else if (result.id) {
                // 尝试从全局设备仓库获取设备
                if (globalDevices.value.has(result.id)) {
                  const device = globalDevices.value.get(result.id);
                  
                  // 更新全局设备仓库 - 这里不做具体更改，等待后端推送最新状态
                  // 只是标记设备状态有变化
                  const updatedDevice = { ...device, _updated: true };
                  globalDevices.value.set(result.id, updatedDevice);
                  
                  // 更新设备节点外观
                  updateDeviceOnGraph(updatedDevice);
                  
                  // 如果是当前选中的设备，更新控制面板
                  if (selectedDevice.value === result.id) {
                    deviceData.value = updatedDevice;
                  }
                }
              }
            } else {
              // 更新失败，收集错误消息
              if (result.error) {
                errorMessages.push(`${result.id || '未知设备'}: ${result.error}`);
              }
            }
          });
          
          // 显示结果通知
          if (failedCount === 0) {
            // 全部成功
            if (actualSentCommands < totalCommands) {
              // 有些命令被优化掉了（参数无变化）
              ElMessage.success(`已成功更新${successCount}个设备参数，${totalCommands - actualSentCommands}个无需更新`);
            } else {
              // 所有命令都发送了
              ElMessage.success(`已成功更新${successCount}个设备参数`);
            }
          } else {
            // 有失败的情况
            console.error(`${failedCount}个参数更新失败，${successCount}个成功`);
            
            // 显示详细错误信息
            if (errorMessages.length > 0) {
              const errorMsg = errorMessages.length > 3 
                ? `${errorMessages.slice(0, 3).join('\n')}...等${errorMessages.length}个错误` 
                : errorMessages.join('\n');
              ElMessage.error(`参数更新失败: ${errorMsg}`);
              errorMessage.value = `参数更新失败: ${errorMsg}`;
            } else {
              ElMessage.error(`${failedCount}个参数更新失败，${successCount}个成功`);
              errorMessage.value = `${failedCount}个参数更新失败，${successCount}个成功`;
            }
          }
        }
      }
      
      // 重置加载和发送状态
      isLoading.value = false;
      isCommandSending.value = false;
      
      // 清空待发送参数队列
      pendingChanges.value.clear();
      
      break;
      
    case 'error':
      // 错误消息
      console.error("服务器错误:", data.data);
      errorMessage.value = data.data.message;
      isLoading.value = false;
      break;

    case 'hardwareConnection':
      // 硬件连接状态
      isHardwareConnecting.value = false;
      if (data.data.success) {
        console.log("已连接到硬件:", data.data.ipAddress || data.data.portPath);
        isHardwareConnected.value = true;
        hardwareErrorMessage.value = '';
        ElMessage.success('硬件设备连接成功');
      } else {
        const errorMsg = data.data.error || '无法连接硬件设备';
        console.error("硬件连接失败:", errorMsg);
        hardwareErrorMessage.value = errorMsg;
        isHardwareConnected.value = false;
        ElMessage.error(`硬件连接失败: ${errorMsg}`);
      }
      isLoading.value = false;
      break;
      
    case 'serverStatus':
      // 服务器状态信息
      console.log("服务器状态:", data.data);
      isHardwareConnected.value = data.data.connected;
      if (!data.data.connected) {
        hardwareIP.value = data.data.lastIpAddress || '192.168.1.14';
      }
      break;
      
    case 'hardwareStatus':
      // 硬件连接状态信息
      console.log("硬件状态:", data.data);
      isHardwareConnected.value = data.data.connected;
      isHardwareConnecting.value = false;
      
      // 如果已连接到硬件，更新UI状态
      if (data.data.connected) {
        console.log('已成功连接到硬件');
        hardwareErrorMessage.value = '';
        // 如果有IP地址信息，更新显示
        if (data.data.ip) {
          hardwareIP.value = data.data.ip;
        }
        
        // 显示成功通知（但避免频繁通知）
        if (isHardwareConnecting.value) {
          ElMessage.success('成功连接到硬件设备');
        }
      } else {
        console.warn('未连接到硬件');
        // 如果有失败原因，显示
        if (data.data.error) {
          hardwareErrorMessage.value = data.data.error;
          
          // 如果正在连接中，才显示错误通知
          if (isHardwareConnecting.value) {
            ElMessage.error(`连接硬件失败: ${data.data.error}`);
          }
        }
      }
      
      // 无论如何都结束连接状态
      isHardwareConnecting.value = false;
      break;
      
    case 'deviceStatus':
      // 来自硬件的设备状态数据
      console.log(`收到来自控制器${data.controllerId}的设备状态更新:`, data.devices);
      
      // 更新设备状态
      if (data.devices && Array.isArray(data.devices)) {
        data.devices.forEach(device => {
          updateDeviceStatus(device);
        });
      }
      break;
      
    default:
      console.warn("未知的WebSocket消息类型:", data.type);
      break;
  }
};

// 加载保存的硬件结构列表
const loadSavedPaths = async () => {
  try {
    isLoading.value = true;
    
    // 确定API基础URL
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 从后端API获取自定义硬件结构列表
    console.log("从后端API获取硬件结构列表...");
    try {
      const response = await axios.get(`${baseUrl}/api/devices/path`);
      
      if (response.data.code === 0 && response.data.data) {
        // 更新保存的路径列表
        savedPaths.value = response.data.data;
        console.log("从API加载了", savedPaths.value.length, "个保存的硬件结构");
        
        // 更新localStorage
        localStorage.setItem('savedReactionPaths', JSON.stringify(savedPaths.value));
      } else {
        console.warn("API返回错误或无效数据:", response.data);
        
        // 尝试从localStorage加载作为备用
        loadFromLocalStorage();
      }
    } catch (apiError) {
      console.error("从API加载路径列表失败:", apiError);
      errorMessage.value = `无法从服务器加载硬件结构列表: ${apiError.message}`;
      
      // 尝试从localStorage加载作为备用
      loadFromLocalStorage();
    }
  } catch (error) {
    console.error("加载保存的硬件结构列表失败:", error);
    
    // 重置为空数组，确保UI不会崩溃
    savedPaths.value = [];
  } finally {
    isLoading.value = false;
  }
};

// 从本地存储加载硬件结构列表
const loadFromLocalStorage = () => {
  // 从localStorage加载
  const savedPathsJson = localStorage.getItem('savedReactionPaths');
  if (savedPathsJson) {
    try {
      savedPaths.value = JSON.parse(savedPathsJson);
      console.log("从本地存储加载了", savedPaths.value.length, "个保存的硬件结构");
    } catch (parseError) {
      console.error("解析本地存储的路径列表失败:", parseError);
      // 如果JSON解析失败，重置为空数组
      savedPaths.value = [];
      localStorage.removeItem('savedReactionPaths');
    }
  } else {
    savedPaths.value = [];
  }
};


// 删除当前选中的路径
const deleteReactionPath = async () => {
  try {
    if (!pathToDelete.value) {
      console.error("没有选中要删除的路径");
      return;
    }
    
    isLoading.value = true;
    
    // 使用服务器的完整URL
    let baseUrl = '';
    if (process.env.NODE_ENV === 'development') {
      baseUrl = 'http://localhost:3000'; // 开发环境下的后端地址
    }
    
    // 调用API删除路径 - 使用新的API路径
    const pathId = pathToDelete.value.id || pathToDelete.value.name;
    const response = await axios.delete(`${baseUrl}/api/devices/path/${encodeURIComponent(pathId)}`);
    
    console.log("删除路径响应:", response);
    
    if (response.data.code === 0) {
      // 从本地路径列表中移除
      savedPaths.value = savedPaths.value.filter(p => p.name !== pathToDelete.value.name);
      
      // 更新localStorage
      localStorage.setItem('savedReactionPaths', JSON.stringify(savedPaths.value));
      
      // 如果当前选择的是被删除的路径，清空选择
      if (selectedPath.value && selectedPath.value.name === pathToDelete.value.name) {
        selectedPath.value = null;
        // 清空图
        graph?.clear();
        graph?.render();
      }
      
      alert(`硬件结构 "${pathToDelete.value.name}" 已成功删除`);
    } else {
      throw new Error(response.data.msg || '删除失败');
    }
  } catch (error) {
    console.error("删除硬件结构失败:", error);
    let errorMsg = '';
    
    if (error.response) {
      // 服务器响应了错误状态码
      errorMsg = `服务器错误 (${error.response.status}): ${error.response.data?.msg || error.message}`;
    } else if (error.request) {
      // 请求发送了但没有收到响应
      errorMsg = '没有收到服务器响应，请检查网络或服务器状态';
    } else {
      // 设置请求时发生错误
      errorMsg = error.message;
    }
    
    errorMessage.value = `删除硬件结构失败: ${errorMsg}`;
  } finally {
    isLoading.value = false;
    isShowDeletePathDialog.value = false;
    pathToDelete.value = null;
  }
};

// 组件挂载完成后初始化图表
onMounted(async () => {
  try {
    console.log("组件挂载完成");
    
    // 确保侧边栏打开
    isSidebarOpen.value = true;
    
    // 初始化G6 v5图
    const graphWidth = container.value.clientWidth;
    const graphHeight = container.value.clientHeight || 600;
    
    console.log(`初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
    console.log("isDragEnabled", isDragEnabled.value);
    
    // 创建图形实例
    graph = new Graph({
      container: container.value,
      width: graphWidth,
      height: graphHeight,
      behaviors: [
        {
          type: 'drag-canvas',
          key: 'drag-canvas',
          enable: false // 禁用画布拖拽，避免与节点拖拽冲突
        },
        {
          type: 'zoom-canvas',
          sensitivity: 1.5, // 配置灵敏度
          key: 'zoom-canvas',
          enable: true
        },
        {
          type: 'click-select',
          key: 'click-select',
          enable: true
        },
        {
          type: 'drag-element', // 节点拖拽行为
          key: 'drag-element',
          enable: true, // 始终启用节点拖拽
          shouldBegin: (e) => {
            // 只在创建模式下允许拖拽节点
            return isCreateMode.value && isAdmin.value;
          },
          shouldUpdate: (e) => {
            // 记录拖拽开始位置
            if (e.type === 'dragstart') {
              const nodeId = e.item.get('id');
              if (nodeId) {
                const nodeData = graph.getNodeData(nodeId);
                if (nodeData && nodeData.style) {
                  dragInfo.isDragging = true;
                  dragInfo.nodeId = nodeId;
                  dragInfo.startPosition = { 
                    x: parseFloat(nodeData.style.x) || 0, 
                    y: parseFloat(nodeData.style.y) || 0 
                  };
                  console.log(`拖拽开始，记录节点 ${nodeId} 初始位置:`, dragInfo.startPosition);
                }
              }
            }
            // 总是允许更新
            return true;
          },
          onEnd: (e) => {
            // 拖拽结束时记录历史
            if (dragInfo.isDragging && dragInfo.nodeId) {
              const nodeData = graph.getNodeData(dragInfo.nodeId);
              if (nodeData && nodeData.style) {
                const finalPosition = {
                  x: parseFloat(nodeData.style.x) || 0,
                  y: parseFloat(nodeData.style.y) || 0
                };
                
                // 如果位置有明显变化
                if (Math.abs(finalPosition.x - dragInfo.startPosition.x) > 1 || 
                    Math.abs(finalPosition.y - dragInfo.startPosition.y) > 1) {
                  
                  console.log(`拖拽结束，节点 ${dragInfo.nodeId} 从`, 
                    dragInfo.startPosition, 
                    "移动到", finalPosition);
                  
                  // 记录到历史
                  addToHistory({
                    type: 'moveNode',
                    nodeId: dragInfo.nodeId,
                    oldPosition: { ...dragInfo.startPosition },
                    newPosition: { ...finalPosition }
                  });
                }
                
                // 重置拖拽状态
                dragInfo.isDragging = false;
                dragInfo.nodeId = null;
              }
            }
          },
          updateEdge: true, // 拖拽时更新关联的边
          delegateStyle: {
            fillOpacity: 0.4,
            fill: '#91d5ff',
            stroke: '#1890ff'
          }
        }
      ],
    });
    
    // 注册节点点击事件
    graph.on('node:click', (e) => {
      // 原有的处理逻辑
      handleDeviceClick(e);
    });
    
    // 加载保存的硬件结构列表和现有设备
    await loadSavedPaths();
    
    // 启动设备数据刷新
    startDeviceDataRefresh();
    
    // 处理窗口大小变化 - 带防抖
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resizeGraph();
      }, 200);
    });
    
    // 延迟建立WebSocket连接，确保其他组件准备就绪
    setTimeout(() => {
      // 建立WebSocket连接
      connectWebSocket();
    }, 500);
    
    // 添加键盘快捷键监听
    window.addEventListener('keydown', handleKeyboardShortcuts);
    
    // 添加消息监听
    window.addEventListener('message', (event) => {
      try {
        console.log('收到postMessage消息:', event.data);
      } catch (error) {
        console.error('处理postMessage消息失败:', error);
        errorMessage.value = `处理消息失败: ${error.message}`;
      }
    });
    console.log("组件初始化完成");
    
    // 确保pendingChanges已正确初始化
    if (!pendingChanges.value) {
      pendingChanges.value = new Map();
    }
    
    // 连接WebSocket
    await connectWebSocket();
    
    // 请求当前硬件状态
    if (wsConnected.value) {
      // 延迟一点请求当前状态，确保WebSocket连接已完全建立
      setTimeout(() => {
        sendWsMessage({
          type: 'getHardwareStatus'
        });
      }, 1000);
    }
    
  } catch (error) {
    console.error("组件挂载出错:", error);
    errorMessage.value = `初始化出错: ${error.message}`;
  }
});

onBeforeUnmount(() => {
  console.log("销毁G6");
  // 停止定时刷新
  stopDeviceDataRefresh();
  // 销毁图表
  graph?.destroy();

  // 关闭WebSocket连接
  if (ws.value) {
    ws.value.close();
  }
  
 
  // 断开WebSocket连接
  disconnectWebSocket();
  
  // 移除键盘快捷键监听
  window.removeEventListener('keydown', handleKeyboardShortcuts);
});

// 监听控制面板的显示状态，控制刷新
watch(showControlPanel, (newVal) => {
  if (!newVal) {
    // 面板关闭时，停止刷新
    stopDeviceDataRefresh();
  } else {
    // 面板打开时，启动刷新
    startDeviceDataRefresh();
  }
});

// 监听流程执行状态变化
watch(() => workflowExecutor.status, (newStatus, oldStatus) => {
  if (newStatus === 'completed' && oldStatus === 'running') {
    ElMessage.success(`流程 "${currentWorkflow.name}" 已成功完成！`);
    
    // 延迟关闭执行面板
    setTimeout(() => {
      isRunningWorkflow.value = false;
    }, 2000);
  } else if (newStatus === 'error') {
    ElMessage.error(`流程执行出错`);
  }
});
// 监听WebSocket连接状态变化
watch(wsConnected, (newValue) => {
  if (newValue && isRunningWorkflow.value) {
    // WebSocket重新连接后，如果正在执行流程，提示用户
    ElMessage.warning('WebSocket连接已恢复，但流程执行可能已中断，建议重新执行流程');
  }
});

// 放置处理
const handleDrop = (e) => {
  if (!isCreateMode.value) return;
  
  e.preventDefault();
  
  if (!draggedIcon) {
    errorMessage.value = "拖拽数据为空，请重新拖拽设备图标";
    return;
  }
  
  // 计算放置位置
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // 打开设备选择对话框
  openDeviceSelectionDialog(x, y, draggedIcon.type);
};

// 选择设备并添加到图中
const selectDeviceAndAddToGraph = (device) => {
  const { x, y } = dropPosition.value;
  
  // 根据设备类型获取图标
  let iconSrc = null;
  let label = "";
  
  switch (device.type) {
    case "pump": iconSrc = pump; label = "泵"; break;
    case "valve": iconSrc = valve; label = "阀"; break;
    case "chip": iconSrc = chip; label = "加热芯片"; break;
    case "mfc": iconSrc = mfc; label = "MFC控制器"; break;
    case "light": iconSrc = light; label = "光照控制"; break;
    case "bottle": iconSrc = bottle; label = "瓶"; break;
  }
  
  // 打印图标信息以帮助调试
  console.log(`设备类型 ${device.type} 的图标:`, iconSrc);
  
  // 添加到图中
  addDeviceToGraph(device, iconSrc, label, x, y);
  
  // 关闭对话框
  showDeviceSelectionDialog.value = false;
};


// 存储用户修改的参数
const updateParameter = (deviceId, deviceType, paramName, value) => {
  let uniqueDeviceKey = `${deviceType}_${deviceId}`;
  
  // 确保pendingChanges是一个有效的响应式Map对象
  if (!pendingChanges.value) {
    pendingChanges.value = new Map();
  }
  
  if (!pendingChanges.value.has(uniqueDeviceKey)) {
    pendingChanges.value.set(uniqueDeviceKey, {
      deviceId: deviceId,
      deviceType: deviceType,
      params: {}
    });
    console.log(`为设备${uniqueDeviceKey}创建新的参数变更对象`);
  }
  
  const deviceChanges = pendingChanges.value.get(uniqueDeviceKey);
  deviceChanges.params[paramName] = value;
  console.log(`设备 ${deviceId} 的参数 ${paramName} 已更新为 ${value}`);
  console.log("当前待发送变更数量:", pendingChanges.value.size);
  console.log("pendingChanges详情:", JSON.stringify(Array.from(pendingChanges.value.entries()), null, 2)); 
  
  // 更新后强制界面刷新
  pendingChanges.value = new Map(pendingChanges.value);
  
  // 自动显示参数变更队列面板
  showPendingChangesPanel.value = true;
};
const updateBottle = (deviceId, paramName, value) => {
  deviceData.value.bottle[paramName] = value;
}
// 显示工作流预览对话框状态
const showWorkflowPreviewDialog = ref(false);
const previewWorkflow = ref(null);

// 从参数变更队列生成并执行工作流
const generateWorkflowFromPendingChanges = async () => {
  try {
    if (!pendingChanges.value || pendingChanges.value.size === 0) {
      ElMessage.warning('没有待发送的参数更新');
      return;
    }
    
    // 获取当前选择的反应路径名称
    let workflowName = '自动生成的工作流';
    if (selectedReactionPathIndex.value !== null && reactionPaths.value[selectedReactionPathIndex.value]) {
      workflowName = `${reactionPaths.value[selectedReactionPathIndex.value].name} 自动工作流`;
    }
    
    // 创建新工作流
    const autoWorkflow = {
      id: `auto_${Date.now()}`,
      name: workflowName,
      description: '基于参数变更队列自动生成的工作流',
      steps: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // 从pendingChanges创建设备列表
    const devices = {
      pumps: [],
      valves: [],
      heaters: [],
      mfcs: [],
      lights: [],
    };
    
    // 整理所有设备和参数
    for (const [deviceKey, changes] of pendingChanges.value.entries()) {
      const [deviceType, deviceId] = deviceKey.split('_');
      
      if (!changes.params) continue;
      
      const device = {
        id: deviceId,
        type: deviceType,
        parameters: changes.params
      };
      
      // 按设备类型分类
      switch (deviceType) {
        case 'pump':
          devices.pumps.push(device);
          break;
        case 'valve':
          devices.valves.push(device);
          break;
        case 'chip':
          devices.heaters.push(device);
          break;
        case 'mfc':
          devices.mfcs.push(device);
          break;
        case 'light':
          devices.lights.push(device);
          break;
      }
    }
    
    // 步骤1: 初始化反应路径
    autoWorkflow.steps.push(createInitializationStep(devices));
    
    // 步骤2: 泵润洗
    if (devices.pumps.length > 0) {
      autoWorkflow.steps.push(createPumpRinseStep(devices));
    }
    
    // 步骤3: 抽吸反应溶液
    if (devices.pumps.length > 0) {
      autoWorkflow.steps.push(createReagentAspirationStep(devices));
    }
    
    // 步骤4: 反应运行
    autoWorkflow.steps.push(createReactionRunStep(devices));
    
    // 步骤5: 反应稳定后切换产品收集阀门
    if (devices.valves.length > 0) {
      const stabilizedValveStep = createStabilizedValveStep(devices);
      if (stabilizedValveStep) {
        autoWorkflow.steps.push(stabilizedValveStep);
      }
    }
    
    // 步骤6: 废液排出
    if (devices.valves.length > 0) {
      autoWorkflow.steps.push(createWasteDisposalStep(devices));
    }
    
    // 步骤7: 系统清洗
    autoWorkflow.steps.push(createSystemCleaningStep(devices));
    
    // 设置预览工作流并显示预览对话框
    previewWorkflow.value = autoWorkflow;
    showWorkflowPreviewDialog.value = true;
    
  } catch (error) {
    console.error('生成工作流失败:', error);
    ElMessage.error(`生成工作流失败: ${error.message}`);
  }
};

// 执行预览的工作流
const executePreviewedWorkflow = async () => {
  try {
    if (!previewWorkflow.value) {
      ElMessage.warning('没有可执行的工作流');
      return;
    }
    
    // 设置当前工作流
    Object.assign(currentWorkflow, previewWorkflow.value);
    
    // 关闭预览对话框
    showWorkflowPreviewDialog.value = false;
    
    // 显示执行面板并开始执行
    isRunningWorkflow.value = true;
    await workflowExecutor.executeWorkflow(currentWorkflow);
    
    // 清空参数变更队列
    pendingChanges.value.clear();
    showPendingChangesPanel.value = false;
    
  } catch (error) {
    console.error('执行工作流失败:', error);
    ElMessage.error(`执行工作流失败: ${error.message}`);
  }
};

// 创建初始化步骤
const createInitializationStep = (devices) => {
  const commands = [];
  
  // 1. 阀门初始化命令 - 仅对非产品收集阀进行初始化设置
  devices.valves.forEach(valve => {
    // 只初始化非产品收集阀，产品收集阀会在反应稳定后设置
    if (valve.parameters.position !== undefined && !valve.parameters.isProductValve) {
      commands.push({
        deviceId: valve.id,
        deviceType: 'valve',
        action: 'setPosition',
        parameters: {
          position: valve.parameters.position
        }
      });
    }
  });
  
  // 2. 加热器初始化命令
  devices.heaters.forEach(heater => {
    const params = {};
    if (heater.parameters.targetTemp !== undefined) {
      params.temperature = heater.parameters.targetTemp;
    } else if (heater.parameters.setTemp !== undefined) {
      params.temperature = heater.parameters.setTemp;
    }
    
    if (heater.parameters.heatingSpeed !== undefined) {
      params.speed = heater.parameters.heatingSpeed;
    } else if (heater.parameters.speed !== undefined) {
      params.speed = heater.parameters.speed;
    }
    
    if (Object.keys(params).length > 0) {
      commands.push({
        deviceId: heater.id,
        deviceType: 'chip',
        action: 'setTemp',
        parameters: params
      });
    }
  });
  
  // 3. 从吸取端口吸取溶液 (不发送泵初始化命令)
  devices.pumps.forEach(pump => {
    // 设置泵端口到吸取端口
    if (pump.parameters.aspiratePort !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: pump.parameters.aspiratePort // 使用吸取端口
        }
      });
      
      // 设置泵速度
      if (pump.parameters.speed !== undefined) {
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'setSpeed',
          parameters: {
            speed: pump.parameters.speed
          }
        });
      }
      
      // 从吸取端口吸取溶液
      if (pump.parameters.position !== undefined) {
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'aspirate',
          parameters: {
            volume: pump.parameters.position
          }
        });
      }
    }
  });
  
  // 4. MFC初始化命令
  devices.mfcs.forEach(mfc => {
    if (mfc.parameters.flowRate !== undefined || mfc.parameters.setFlowRate !== undefined) {
      commands.push({
        deviceId: mfc.id,
        deviceType: 'mfc',
        action: 'setFlowRate',
        parameters: {
          flowRate: mfc.parameters.flowRate || mfc.parameters.setFlowRate || 0
        }
      });
    }
  });
  
  // 5. 光照控制命令
  devices.lights.forEach(light => {
    if (light.parameters.intensity !== undefined || light.parameters.setIntensity !== undefined) {
      commands.push({
        deviceId: light.id,
        deviceType: 'light',
        action: 'setIntensity',
        parameters: {
          intensity: light.parameters.intensity || light.parameters.setIntensity || 0
        }
      });
    }
  });
  
  // 构建等待条件列表
  const conditions = [];
  
  // 对于每个加热器，添加温度达标条件
  devices.heaters.forEach(heater => {
    if (heater.parameters.targetTemp !== undefined || heater.parameters.setTemp !== undefined) {
      const targetTemp = heater.parameters.targetTemp || heater.parameters.setTemp;
      conditions.push({
        type: 'deviceParameter',
        deviceType: 'chip',
        deviceId: heater.id,
        parameter: 'currentTemp',
        comparison: 'approx',
        value: targetTemp,
        tolerance: 2,
        timeout: 180
      });
    }
  });
  
  return {
    id: `step-${Date.now()}-init`,
    name: '初始化反应路径',
    description: '设置阀门到初始位置，启动加热器至目标温度，初始化所有泵',
    deviceCommands: commands,
    conditions: conditions.length > 0 ? conditions : undefined,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 创建泵润洗步骤
const createPumpRinseStep = (devices) => {
  const commands = [];
  
  devices.pumps.forEach(pump => {
    // 设置泵端口到废液口 - 固定使用6号端口作为废液口
    commands.push({
      deviceId: pump.id,
      deviceType: 'pump',
      action: 'setPort',
      parameters: {
        port: 6 // 固定使用6号端口作为废液口
      }
    });
    
    // 设置泵速度
    if (pump.parameters.speed !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: pump.parameters.speed
        }
      });
    }
    
    // 排空泵内溶液
    commands.push({
      deviceId: pump.id,
      deviceType: 'pump',
      action: 'empty',
      parameters: {}
    });
    
    // 润洗完成后，设置泵端口到用户指定的输送端口
    if (pump.parameters.dispensePort !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: pump.parameters.dispensePort // 使用用户配置的输送端口
        }
      });
    }
  });
  
  return {
    id: `step-${Date.now()}-rinse`,
    name: '泵润洗',
    description: '将泵排空至废液口进行润洗，清除可能存在的残留物',
    deviceCommands: commands,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 创建抽吸反应溶液步骤
const createReagentAspirationStep = (devices) => {
  const commands = [];
  
  devices.pumps.forEach(pump => {
    // 设置泵端口到反应物端口 - 对于抽吸操作，使用吸取端口
    if (pump.parameters.aspiratePort !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: pump.parameters.aspiratePort // 使用吸取端口
        }
      });
    }
    
    // 设置泵速度
    if (pump.parameters.speed !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: pump.parameters.speed
        }
      });
    }
    
    // 抽吸反应溶液
    if (pump.parameters.position !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'aspirate',
        parameters: {
          volume: pump.parameters.position
        }
      });
    }
  });
  
  // 构建泵位置条件
  const pumpConditions = devices.pumps.map(pump => {
    if (pump.parameters.position !== undefined) {
      return {
        type: 'deviceParameter',
        deviceType: 'pump',
        deviceId: pump.id,
        parameter: 'position',
        comparison: 'approx',
        value: pump.parameters.position,
        tolerance: 5, // 允许5单位误差
        timeout: 60
      };
    }
    return null;
  }).filter(Boolean);

  return {
    id: `step-${Date.now()}-aspirate`,
    name: '抽吸反应溶液',
    description: '从指定端口抽取反应所需的溶液',
    deviceCommands: commands,
    conditions: pumpConditions.length > 0 ? pumpConditions : undefined,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 创建反应运行步骤
const createReactionRunStep = (devices) => {
  const commands = [];
  
  // 设置泵出液端口
  devices.pumps.forEach(pump => {
    // 设置泵端口到输送端口 - 对于分发操作，使用输送端口
    if (pump.parameters.dispensePort !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: pump.parameters.dispensePort // 使用输送端口
        }
      });
    }
    
    // 如果指定了流速速度，则添加相应命令
    if (pump.parameters.flowRate !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: pump.parameters.flowRate * 10 // 假设流速与速度的映射关系
        }
      });
    }
    
    // 将泵内溶液全部推出去
    if (pump.parameters.position !== undefined) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'dispense',
        parameters: {
          volume: pump.parameters.position // 排出全部溶液体积
        }
      });
    } else {
      // 如果没有设置具体体积，则使用排空命令
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'empty',
        parameters: {}
      });
    }
  });
  
  // 监控加热器温度的条件
  const conditions = [];
  devices.heaters.forEach(heater => {
    if (heater.parameters.targetTemp !== undefined || heater.parameters.setTemp !== undefined) {
      const targetTemp = heater.parameters.targetTemp || heater.parameters.setTemp;
      conditions.push({
        type: 'deviceStatus',
        deviceType: 'chip',
        deviceId: heater.id,
        status: 'heating',
        statusParameter: 'currentTemp',
        comparison: 'gte', // 大于等于
        value: targetTemp * 0.95, // 允许5%的误差
        timeout: 120 // 2分钟超时
      });
    }
  });
  
  // 计算反应时间，默认30分钟
  const reactionTime = 30; 
  
  return {
    id: `step-${Date.now()}-reaction`,
    name: '反应运行',
    description: `将泵内溶液推出并保持${reactionTime}分钟，使反应溶液在加热条件下完成反应`,
    deviceCommands: commands,
    conditions: conditions.length > 0 ? conditions : undefined,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 创建反应稳定后阀门切换步骤 - 只针对产品收集阀
const createStabilizedValveStep = (devices) => {
  const commands = [];
  const productValve = devices.valves.find(valve => valve.parameters.isProductValve);
  
  // 如果找到连接产品收集口的阀门，设置它到产品收集位置
  if (productValve && productValve.parameters.position !== undefined) {
    commands.push({
      deviceId: productValve.id,
      deviceType: 'valve',
      action: 'setPosition',
      parameters: {
        position: productValve.parameters.position // 使用用户设置的位置
      }
    });
    
    return {
      id: `step-${Date.now()}-valve-switch`,
      name: '反应稳定后切换产品收集阀',
      description: '反应稳定后，将连接产品收集口的阀门切换到指定位置，保证反应产物的收集',
      deviceCommands: commands,
      waitForCompletion: true,
      delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
    };
  }
  
  // 如果没有标记的阀门，返回null
  return null;
};

// 产品收集步骤已被移除，因为普通阀门在初始化时已经设置好，
// 只有产品收集阀在反应稳定后才会设置

// 创建废液排出步骤
const createWasteDisposalStep = (devices) => {
  // 将所有阀门设置到位置1（假设位置1是排放废液的位置）
  const commands = devices.valves.map(valve => ({
    deviceId: valve.id,
    deviceType: 'valve',
    action: 'setPosition',
    parameters: {
      position: 1 // 假设位置1是排放废液的位置
    }
  }));
  
  return {
    id: `step-${Date.now()}-waste`,
    name: '废液排出',
    description: '打开与废液收集相连的阀门，准备系统清洗',
    deviceCommands: commands,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 创建系统清洗步骤
const createSystemCleaningStep = (devices) => {
  const commands = [];
  const cleaningCycles = 2; // 默认清洗2个循环
  const cleaningVolume = 100; // 默认100μL清洗液
  
  // 为每个清洗循环创建命令
  for (let cycle = 1; cycle <= cleaningCycles; cycle++) {
    devices.pumps.forEach(pump => {
      // 设置泵端口到清洗液位置（使用吸取端口或默认端口1）
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: 1 // 固定使用端口1作为清洗液
        }
      });
      
      // 抽吸清洗液
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'aspirate',
        parameters: {
          volume: cleaningVolume
        }
      });
      
      // 设置泵端口到废液位置
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          port: 6 // 固定使用端口6作为废液位置
        }
      });
      
      // 排出清洗液
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'dispense',
        parameters: {
          volume: cleaningVolume * 0.95 // 排出95%确保充分排空
        }
      });
    });
  }
  
  // 关闭加热器
  devices.heaters.forEach(heater => {
    commands.push({
      deviceId: heater.id,
      deviceType: 'chip',
      action: 'setTemp',
      parameters: {
        temperature: 25, // 回到室温
        speed: 5 // 低速冷却
      }
    });
  });
  
  return {
    id: `step-${Date.now()}-cleaning`,
    name: '系统清洗',
    description: `执行${cleaningCycles}次清洗循环，确保管路清洁，并关闭加热器`,
    deviceCommands: commands,
    waitForCompletion: true,
    delayAfter: 0 // 不需要固定延迟，系统会自动基于设备状态判断
  };
};

// 发送所有待发送的参数变更
const sendAllParameterChanges = async () => {
  if (pendingChanges.value.size === 0 || isCommandSending.value) {
    return false;
  }
  
  isCommandSending.value = true;
  
  try {
    const updateCommands = [];
    
    // 遍历所有待更新的设备
    for (const [deviceKey, changes] of pendingChanges.value.entries()) {
      // 从键中获取设备类型
      const [deviceType, deviceId] = deviceKey.split('_');
      
      if (!changes.params || Object.keys(changes.params).length === 0) {
        console.error(`跳过设备 ${deviceKey} 的参数更新：没有更改`);
        continue;
      }
      
      // 根据设备类型构建不同的命令
      switch (deviceType) {
        case 'pump':
          updateCommands.push({
            id: deviceId,
            type: 'pump',
            action: 'updateParameters',
            parameters: {
              ...(changes.params.setSpeed !== undefined && { speed: changes.params.setSpeed }),
              ...(changes.params.aspiratePort !== undefined && { aspiratePort: changes.params.aspiratePort }),
              ...(changes.params.dispensePort !== undefined && { dispensePort: changes.params.dispensePort }),
              ...(changes.params.position !== undefined && { position: changes.params.position })
            }
          });
          break;
          
        case 'valve':
          updateCommands.push({
            deviceId: deviceId,
            deviceType: 'valve',
            action: 'setPosition',
            parameters: { position: changes.params.position }
          });
          break;
          
        case 'chip':
          updateCommands.push({
            id: deviceId,
            type: 'chip',
            action: 'setTemp',
            parameters: {
              ...(changes.params.setTemp !== undefined && { temperature: changes.params.setTemp }),
              ...(changes.params.speed !== undefined && { speed: changes.params.speed })
            }
          });
          break;
        case 'mfc':
          updateCommands.push({
            id: deviceId,
            type: 'mfc',
            action: 'setFlowRate',
            parameters: { flowRate: changes.params.setFlowRate }
          });
          break;
        case 'light':
          updateCommands.push({
            id: deviceId,
            type: 'light',
            action: 'setIntensity',
            parameters: { intensity: changes.params.setIntensity }
          });
          break;
        default:
          console.warn(`未知的设备类型: ${deviceType}`);
          break;
      }
    }
    
    // 如果有命令需要发送
    if (updateCommands.length > 0) {
      if (wsConnected.value) {
        // 判断是否已连接硬件
        if (!isHardwareConnected.value) {
          errorMessage.value = "硬件未连接，无法发送命令";
          isCommandSending.value = false;
          return false;
        }
        
        // 通过WebSocket发送
        sendWsMessage({
          type: 'updateDeviceParameters',
          payload: updateCommands
        });
        
        // 清空待发送变更
        pendingChanges.value.clear();
        
        // 显示成功消息
        if (updateCommands.length === 1) {
          console.log(`已发送 ${updateCommands[0].id} 的参数更新`);
        } else {
          console.log(`已发送 ${updateCommands.length} 个设备的参数更新`);
        }
      } else {
        console.log("未连接到服务器，无法发送参数更新");
        errorMessage.value = "未连接到服务器，无法发送参数更新";
        isCommandSending.value = false;
        return false;
      }
    }
    
    return true;
  } catch (error) {
    console.error("发送参数更新失败:", error);
    errorMessage.value = `发送参数更新失败: ${error.message}`;
    return false;
  } finally {
    isCommandSending.value = false;
  }
};



// 翻译设备状态为中文
const translateStatus = (status) => {
  const statusMap = {
    running: '运行中',
    stopped: '已停止',
    idle: '空闲',
    open: '已打开',
    closed: '已关闭',
    heating: '加热中',
    cooling: '冷却中',
    on: '已开启',
    off: '已关闭',
    error: '错误'
  };
  
  return statusMap[status] || status;
};

// 断开WebSocket连接
const disconnectWebSocket = () => {
  if (ws.value) {
    manualClose.value = true; // 标记为手动关闭
    ws.value.close();
    ws.value = null;
  }
  wsConnected.value = false;
};

// 尝试重新连接WebSocket
const reconnectWebSocket = () => {
  // 如果已有连接，先断开
  if (ws.value) {
    disconnectWebSocket();
  }
  
  // 等待一小段时间后重新连接
  setTimeout(() => {
    connectWebSocket();
  }, 500);
};



// 更新图中的设备节点
const updateDeviceOnGraph = (device) => {
  if (!graph) return;
  
  // 更新节点外观
  updateNodeAppearance(device.id, device.status);
  
  // 如果是当前选中的设备，更新控制面板数据
  if (device.id === selectedDevice.value) {
    deviceData.value = device;
  }
};

// 打开保存对话框
const openSaveDialog = () => {
  isShowPathNameDialog.value = true;
  pathName.value = currentEditPath.value?.name || '';
  pathDescription.value = currentEditPath.value?.description || '';
};

// 打开删除路径确认对话框
const openDeletePathDialog = (path) => {
  pathToDelete.value = path;
  isShowDeletePathDialog.value = true;
};

// 全局设备仓库
const globalDevices = ref(new Map()); // 存储所有已连接的实际设备
const showDeviceSelectionDialog = ref(false); // 是否显示设备选择对话框
const dropPosition = ref({ x: 0, y: 0, type: '' }); // 拖拽放置位置
const deviceSearchQuery = ref(''); // 设备搜索查询
const filteredDevicesCache = ref([]); // 过滤后的设备缓存

// 根据类型筛选的设备列表
const filteredDevices = computed(() => {
  return filteredDevicesCache.value;
});

// 设备分组
const deviceGroups = computed(() => {
  // 先按模块名称分组
  const moduleGroups = {};
  
  // 对已过滤的设备进行分组
  filteredDevices.value.forEach(device => {
    // 判断设备是否有模块数据
    if (device.moduleMetadata && device.moduleMetadata.moduleName) {
      const moduleName = device.moduleMetadata.moduleName;
      if (!moduleGroups[moduleName]) {
        moduleGroups[moduleName] = [];
      }
      moduleGroups[moduleName].push(device);
    } else {
      // 没有模块数据的设备，按控制器分组
      const groupId = `控制器 ${device.controllerIndex || 1}`;
      if (!moduleGroups[groupId]) {
        moduleGroups[groupId] = [];
      }
      moduleGroups[groupId].push(device);
    }
  });
  
  // 转换为数组形式
  return Object.keys(moduleGroups).map(moduleName => {
    return {
      title: moduleName,
      devices: moduleGroups[moduleName]
    };
  });
});

// 过滤设备
const filterDevices = () => {
  const query = deviceSearchQuery.value.toLowerCase();
  const type = dropPosition.value.type;
  
  // 先按类型过滤
  let devices = Array.from(globalDevices.value.values())
    .filter(device => device.type === type);
  
  // 再按搜索词过滤
  if (query) {
    devices = devices.filter(device => 
      device.id.toLowerCase().includes(query)
    );
  }
  
  // 过滤掉当前图中已存在的设备
  devices = devices.filter(device => {
    return !graph?.getNodeData().some(node => node.id === device.id);
  });
  
  // 更新缓存
  filteredDevicesCache.value = devices;
};

// 打开设备选择对话框
const openDeviceSelectionDialog = (x, y, type) => {
  dropPosition.value = { x, y, type };
  deviceSearchQuery.value = ''; // 清空搜索
  filterDevices(); // 初始化过滤结果
  showDeviceSelectionDialog.value = true;
};


// 获取设备类型名称
const getDeviceTypeName = (type) => {
  const typeNames = {
    pump: "泵",
    valve: "阀",
    chip: "加热芯片",
    mfc: "MFC控制器",
    light: "光照控制",
    bottle: "瓶"
  };
  return typeNames[type] || type;
};


// 撤销上一步操作
const undoLastOperation = () => {
  if (operationHistory.value.length === 0) {
    console.log("没有可撤销的操作");
    return;
  }
  
  const lastOperation = operationHistory.value.pop();
  console.log("撤销操作:", lastOperation);
  
  if (!lastOperation) return;
  
  // 根据操作类型执行撤销
  switch (lastOperation.type) {
    case 'addNode':
      // 移除节点
      if (lastOperation.nodeId) {
        graph.removeNodeData([lastOperation.nodeId]);
        console.log(`已移除节点: ${lastOperation.nodeId}`);
      }
      break;
      
    case 'addEdge':
      // 移除边
      if (lastOperation.edgeId) {
        graph.removeEdgeData([lastOperation.edgeId]);
        console.log(`已移除边: ${lastOperation.edgeId}`);
      }
      break;
      
    case 'removeNode':
      // 恢复节点
      if (lastOperation.nodeData) {
        graph.addNodeData([lastOperation.nodeData]);
        console.log(`已恢复节点: ${lastOperation.nodeData.id}`);
      }
      break;
      
    case 'removeEdge':
      // 恢复边
      if (lastOperation.edgeData) {
        graph.addEdgeData([lastOperation.edgeData]);
        console.log(`已恢复边: ${lastOperation.edgeData.id}`);
      }
      break;
      
    case 'moveNode':
      // 恢复节点位置 - 用最直接的方法
      if (lastOperation.nodeId && lastOperation.oldPosition) {
        try {
          console.log(`准备恢复节点 ${lastOperation.nodeId} 位置到:`, lastOperation.oldPosition);
          
          // 尝试简单直接的方法 - 使用removeNodeData和addNodeData
          // 先获取完整的节点数据
          const nodeData = graph.getNodeData(lastOperation.nodeId);
          if (nodeData) {
            // 删除旧节点
            graph.removeNodeData([lastOperation.nodeId]);
            
            // 创建一个新的节点数据，但使用旧位置
            const newNodeData = JSON.parse(JSON.stringify(nodeData)); // 深拷贝
            
            // 确保style对象存在并设置位置
            newNodeData.style = newNodeData.style || {};
            newNodeData.style.x = parseFloat(lastOperation.oldPosition.x);
            newNodeData.style.y = parseFloat(lastOperation.oldPosition.y);
            
            // 添加新节点并立即渲染
            console.log("添加恢复位置的节点:", newNodeData);
            graph.addNodeData([newNodeData]);
            graph.render();
            
            console.log(`已恢复节点位置: ${lastOperation.nodeId} 到 (${lastOperation.oldPosition.x}, ${lastOperation.oldPosition.y})`);
          } else {
            console.warn(`找不到节点 ${lastOperation.nodeId} 的数据`);
          }
        } catch (error) {
          console.error("恢复节点位置失败:", error);
        }
      } else {
        console.warn("缺少恢复节点位置所需的信息");
      }
      break;
      
    default:
      console.warn(`未知的操作类型: ${lastOperation.type}`);
  }
  
  // 确保渲染更新
  graph.render();
};

// 键盘快捷键处理函数
const handleKeyboardShortcuts = (e) => {
  // 如果不是创建模式，忽略快捷键
  if (!isCreateMode.value) return;
  
  // Ctrl+Z 或 Cmd+Z (Mac) 撤销操作
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault(); // 阻止浏览器默认撤销
    undoLastOperation();
  }
};

// 添加键盘事件监听
window.addEventListener('keydown', handleKeyboardShortcuts);

// 组件卸载时移除键盘事件监听
onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyboardShortcuts);
});

// 处理图片路径序列化问题的辅助函数
const fixImageSrcForSerialization = (nodes) => {
  return nodes.map(node => {
    const nodeCopy = { ...node };
    
    // 如果节点有src属性并且是动态导入的图片对象
    if (nodeCopy.style && nodeCopy.style.src) {
      // 动态导入的图片会是一个对象，直接序列化会有问题
      // 这里我们标记图片类型，在加载时重新添加
      const src = nodeCopy.style.src;
      let imgType = "";
      
      // 判断图片类型，支持jpg格式
      if (src === pump || (typeof src === 'string' && src.includes('pump'))) {
        imgType = 'pump';
      } else if (src === valve || (typeof src === 'string' && src.includes('valve'))) {
        imgType = 'valve';
      } else if (src === chip || (typeof src === 'string' && src.includes('chip'))) {
        imgType = 'chip';
      } else if (src === mfc || (typeof src === 'string' && src.includes('mfc'))) {
        imgType = 'mfc';
      } else if (src === light || (typeof src === 'string' && src.includes('light'))) {
        imgType = 'light';
      } else if (src === bottle || (typeof src === 'string' && src.includes('bottle'))) {
        imgType = 'bottle';
      }
      
      // 记录图片类型及格式信息
      if (imgType) {
        // 删除原始src，并添加标记
        nodeCopy.data = nodeCopy.data || {};
        nodeCopy.data.imgType = imgType;
        
        // 添加图片格式信息(jpg或svg)，以便正确加载
        if (['pump', 'valve', 'chip', 'bottle'].includes(imgType)) {
          nodeCopy.data.imgFormat = 'jpg';
        } else {
          nodeCopy.data.imgFormat = 'svg';
        }
        
        nodeCopy.style = { ...nodeCopy.style };
        delete nodeCopy.style.src;
      }
    }
    return nodeCopy;
  });
};



// 记录当前拖拽状态
const dragInfo = reactive({
  isDragging: false,
  nodeId: null,
  startPosition: { x: 0, y: 0 },
  lastKnownPosition: { x: 0, y: 0 }
});



const isCommandSending = ref(false);


// 翻译设备类型为中文
const translateDeviceType = (type) => {
  const typeMap = {
    'pump': '泵',
    'valve': '阀门',
    'chip': '加热芯片',
    'mfc': '流量控制',
    'light': '光照',
  };
  
  return typeMap[type] || type;
};

// 翻译参数名称
const translateParameterName = (param, deviceType) => {
  // 根据设备类型和参数名组合判断
  if (deviceType === 'Pump' && param === 'position') {
    return '位置';
  } else if (deviceType === 'Valve' && param === 'position') {
    return '孔位';
  }
  
  const paramMap = {
    // 泵参数
    speed: '速度',
    position: '位置', // 默认情况
    port: '端口',
    initialize: '初始化',
    stop: '停止',
    
    // 加热芯片参数
    speed: '加热速度',
    setTemp: '设置温度',
    
    // MFC参数
    setFlowRate: '设置流速',
    
    // 光照控制参数
    setIntensity: '设置光强',
  };
  
  return paramMap[param] || param;
};

// 选择设备
const selectDevice = (deviceId) => {
  console.log('选择设备:', deviceId);
  
  // 更新选中的设备
  selectedDevice.value = deviceId;
  
  // 从全局设备仓库获取最新设备数据
  if (globalDevices.value.has(deviceId)) {
    // 深拷贝确保控制面板数据独立
    const device = globalDevices.value.get(deviceId);
    const deviceCopy = JSON.parse(JSON.stringify(device));
    
    // 如果有待发送的参数变更，优先显示这些变更值
    const deviceType = device.type;
    const deviceKey = `${deviceType}_${deviceId}`;
    
    if (pendingChanges.value.has(deviceKey)) {
      const pendingParams = pendingChanges.value.get(deviceKey).params;
      // 合并待发送的参数变更
      Object.assign(deviceCopy, pendingParams);
    }
    
    deviceData.value = deviceCopy;
    
    // 初始化控制参数对象
    controlParams.value = {};
    
    // 根据设备类型设置默认控制参数
    if (deviceType === 'pump') {
      // 初始化泵的吸取和输送端口参数
      controlParams.value.aspiratePort = deviceCopy.aspiratePort || 1;
      controlParams.value.dispensePort = deviceCopy.dispensePort || 6;
      controlParams.value.speed = deviceCopy.speed || 0;
      controlParams.value.position = deviceCopy.position || 0;
    } else if (deviceType === 'valve') {
      controlParams.value.position = deviceCopy.position || 1;
      controlParams.value.isProductValve = deviceCopy.isProductValve || false;
    } else if (deviceType === 'chip') {
      controlParams.value.targetTemp = deviceCopy.targetTemp || 25;
      controlParams.value.heatingSpeed = deviceCopy.heatingSpeed || 1;
    } else if (deviceType === 'mfc') {
      controlParams.value.flowRate = deviceCopy.flowRate || 0;
    } else if (deviceType === 'light') {
      controlParams.value.intensity = deviceCopy.intensity || 0;
    }
    
  } else {
    // 如果全局仓库中没有该设备数据，创建一个模拟数据
    console.log('没有该设备数据', deviceId);
  }
  
  // 显示控制面板
  showControlPanel.value = true;
};

// 硬件连接状态
const isHardwareConnected = ref(false);

// 硬件连接相关状态
const isHardwareConnecting = ref(false);
const hardwareIP = ref('192.168.1.14'); // 默认硬件IP
const hardwareErrorMessage = ref('');

// 连接硬件设备
const connectHardware = async () => {
  try {
    if (!wsConnected.value) {
      hardwareErrorMessage.value = '后端WebSocket未连接，请先连接WebSocket服务';
      return;
    }
    
    isHardwareConnecting.value = true;
    hardwareErrorMessage.value = '';
    
    // 发送连接硬件的WebSocket消息
    sendWsMessage({
      type: 'connectHardware',
      payload: {
        ipAddress: hardwareIP.value
      }
    });
    
    // 等待连接结果（实际结果会通过WebSocket消息返回）
    console.log(`尝试连接硬件设备: ${hardwareIP.value}`);
    
    // 添加一个连接超时机制
    setTimeout(() => {
      if (isHardwareConnecting.value) {
        isHardwareConnecting.value = false;
        hardwareErrorMessage.value = '连接硬件超时，请检查硬件IP地址和连接状态';
      }
    }, 10000); // 10秒超时
  } catch (error) {
    console.error('连接硬件失败:', error);
    hardwareErrorMessage.value = `连接硬件失败: ${error.message}`;
    isHardwareConnecting.value = false;
  }
};

// 断开硬件连接
const disconnectHardware = () => {
  try {
    if (!wsConnected.value) {
      hardwareErrorMessage.value = '后端WebSocket未连接，无法断开硬件';
      return;
    }
    
    isHardwareConnecting.value = true;
    hardwareErrorMessage.value = '';
    
    // 发送断开硬件的WebSocket消息
    sendWsMessage({
      type: 'disconnectHardware',
      payload: {}
    });
    
    console.log('尝试断开硬件设备连接');
    
    // 断开连接的状态会通过WebSocket消息更新
    setTimeout(() => {
      if (isHardwareConnecting.value) {
        isHardwareConnecting.value = false;
      }
    }, 5000); // 5秒超时
  } catch (error) {
    console.error('断开硬件连接失败:', error);
    hardwareErrorMessage.value = `断开硬件连接失败: ${error.message}`;
    isHardwareConnecting.value = false;
  }
};

// 组件挂载完成后初始化图表
onMounted(async () => {
  try {
    console.log("组件挂载完成");
    
    // 确保侧边栏打开
    isSidebarOpen.value = true;
    
    // 初始化G6 v5图
    graph = new G6.Graph({
      container: 'graph-container',
      width: 800,
      height: 600,
      layout: {
        type: 'force',
        preventOverlap: true,
        nodeSize: 40,
        edgeStrength: 0.1,
        collideStrength: 0.5,
        alphaDecay: 0.01,
        linkDistance: 100,
        nodeSpacing: 10,
        onTick: () => {
          // 在每一帧中更新节点位置
          const nodes = graph.getNodes();
          nodes.forEach(node => {
            const model = node.getModel();
            if (model.x !== undefined && model.y !== undefined) {
              node.updatePosition({ x: model.x, y: model.y });
            }
          });
        }
      },
      defaultNode: {
        type: 'circle',
        size: 40,
        style: {
          fill: '#fff',
          stroke: '#000',
          lineWidth: 2
        },
        labelCfg: {
          style: {
            fill: '#000',
            fontSize: 12
          }
        }
      },
      defaultEdge: {
        type: 'line',
        style: {
          stroke: '#000',
          lineWidth: 2
        }
      }
    });
    
    // 注册节点点击事件
    graph.on('node:click', (e) => {
      // 原有的处理逻辑
      handleDeviceClick(e);
    });
    
    // 加载保存的硬件结构列表和现有设备
    await loadSavedPaths();
    
    // 启动设备数据刷新
    startDeviceDataRefresh();
    
    // 处理窗口大小变化 - 带防抖
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resizeGraph();
      }, 200);
    });
    
    // 延迟建立WebSocket连接，确保其他组件准备就绪
    setTimeout(() => {
      connectWebSocket();
    }, 1000);
    
    // 添加消息监听
    window.addEventListener('message', (event) => {
      try {
        console.log('收到postMessage消息:', event.data);
  } catch (error) {
        console.error('处理postMessage消息失败:', error);
        errorMessage.value = `处理消息失败: ${error.message}`;
      }
    });
  } catch (error) {
    console.error("组件挂载出错:", error);
    errorMessage.value = `初始化出错: ${error.message}`;
  }
});
// 确认生成工作流
const confirmGenerateWorkflow = () => {
  // 创建一个新的工作流
  createNewWorkflow();
  
  // 设置工作流名称和描述
  currentWorkflow.name = `${selectedPath.value?.name || '未命名路径'} 标准工作流`;
  currentWorkflow.description = `基于反应路径 "${selectedPath.value?.name || '未命名路径'}" 自动生成的标准微流控工作流`;
  
  // 构建标准工作流步骤
  buildStandardWorkflowSteps();
  
  // 关闭参数配置对话框
  showStandardParamsDialog.value = false;
  
  // 打开工作流编辑器（如果当前不在工作流模式）
  if (!isWorkflowMode.value) {
    isWorkflowMode.value = true;
  }
  
  ElMessage.success('已成功生成标准微流控工作流');
};

// 构建标准工作流步骤 - 改进版
const buildStandardWorkflowSteps = () => {
  // 步骤1: 初始化反应路径 - 设置阀门和加热器
  addImprovedInitializationStep();
  
  // 步骤2: 泵润洗 - 排空泵至废液口
  addImprovedPumpRinseStep();
  
  // 步骤3: 抽吸反应溶液
  addImprovedReagentAspirationStep();
  
  // 步骤4: 反应运行
  addImprovedReactionRunStep();
  
  // 步骤5: 产品收集 - 打开与收集产品相连的阀门
  addImprovedProductCollectionStep();
  
  // 步骤6: 废液排出 - 打开与废液相连的阀门
  addImprovedWasteDisposalStep();
  
  // 步骤7: 系统清洗 - 抽吸清洁溶液并冲洗管道
  addImprovedSystemCleaningStep();
  
  // 为所有步骤修改：移除延迟参数并确保启用完成条件检查
  currentWorkflow.steps.forEach(step => {
    // 设置等待完成标志
    step.waitForCompletion = true;
    
    // 对每个设备命令启用自动生成完成条件
    step.deviceCommands.forEach(cmd => {
      cmd.generateCompletionCondition = true;
      
      // 设置合理的超时时间
      // 对于加热芯片设置更长的超时时间
      if (cmd.deviceType === 'chip' && cmd.action === 'setTemp') {
        cmd.completionTimeout = 300; // 5分钟
      } else if (cmd.deviceType === 'pump') {
        cmd.completionTimeout = 180; // 3分钟
      } else {
        cmd.completionTimeout = 60; // 1分钟
      }
    });
    
    // 仅保留少量延迟，主要依靠设备状态判断
    if (step.delayAfter > 20) {
      step.delayAfter = 5; // 大的延迟改为5秒
    } else if (step.delayAfter > 0) {
      step.delayAfter = Math.min(step.delayAfter, 3); // 小的延迟最多3秒
    }
  });
  
  console.log("已优化所有步骤，使用设备状态检测替代固定延迟");
};

// 步骤1: 初始化反应路径
const addImprovedInitializationStep = () => {
  const commands = [];
  
  // 1. 阀门初始化命令 (所有非产品/废液阀门)
  pathValves.value.forEach(valve => {
    // 跳过连接产品或废液的阀门
    if (!standardParams.valvesToProduct[valve.id] && !standardParams.valvesToWaste[valve.id]) {
      commands.push({
        deviceId: valve.id,
        deviceType: 'valve',
        action: 'setPosition',
        parameters: {
          position: standardParams.valvePositions[valve.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 30
      });
    }
  });
  
  // 2. 加热器初始化命令
  pathHeaters.value.forEach(heater => {
    if (standardParams.enabledHeaters[heater.id]) {
      commands.push({
        deviceId: heater.id,
        deviceType: 'chip',
        action: 'setTemp',
        parameters: {
          temperature: standardParams.heaterTemps[heater.id],
          speed: standardParams.heaterSpeeds[heater.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 300 // 5分钟超时，加热需要较长时间
      });
    }
  });
  
  // 3. 泵初始化命令
  pathPumps.value.forEach(pump => {
    if (standardParams.enabledPumps[pump.id]) {
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'initialize',
        parameters: {},
        generateCompletionCondition: true,
        completionTimeout: 60 // 1分钟超时
      });
    }
  });
  
  // 添加步骤
  currentWorkflow.steps.push({
    id: `step-${Date.now()}-1`,
    name: '初始化反应路径',
    description: '设置阀门到初始位置，启动加热器至目标温度，初始化所有泵',
    deviceCommands: commands,
    waitForCompletion: true,
    delayAfter: 10 // 10秒延迟确保初始化完成
  });
};

// 步骤2: 泵润洗
const addImprovedPumpRinseStep = () => {
  const commands = [];
  
  pathPumps.value.forEach(pump => {
    if (standardParams.enabledPumps[pump.id]) {
      // 设置泵端口到废液口
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          aspiratePort: standardParams.pumpAspiratePorts[pump.id],
          dispensePort: 6 // 固定使用6号端口作为废液口
        },
        generateCompletionCondition: true,
        completionTimeout: 10
      });
      
      // 设置泵速度
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: standardParams.pumpSpeeds[pump.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 5
      });
      
      // 排空泵内溶液
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'empty',
        parameters: {},
        generateCompletionCondition: true,
        completionTimeout: 120 // 2分钟超时
      });
      
      // 设置泵端口到用户指定的输送端口
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          aspiratePort: standardParams.pumpAspiratePorts[pump.id],
          dispensePort: standardParams.pumpDispensePorts[pump.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 10
      });
    }
  });
  
  if (commands.length > 0) {
    // 添加设备状态检查条件
    const conditions = [];
    
    // 为每个泵添加一个位置接近零的检查条件
    pathPumps.value.forEach(pump => {
      if (standardParams.enabledPumps[pump.id]) {
        conditions.push({
          type: 'deviceParameter',
          deviceType: 'pump',
          deviceId: pump.id,
          parameter: 'position',
          comparison: 'lte', // 小于等于
          value: 10, // 位置接近0，允许10的误差
          timeout: 180 // 3分钟超时
        });
      }
    });
    
    currentWorkflow.steps.push({
      id: `step-${Date.now()}-2`,
      name: '泵润洗',
      description: '将泵排空至废液口进行润洗，清除可能存在的残留物',
      deviceCommands: commands,
      waitForCompletion: true,
      conditions: conditions.length > 0 ? conditions : undefined,
      delayAfter: 3 // 3秒短延迟确保系统稳定
    });
  }
};

// 步骤3: 抽吸反应溶液
const addImprovedReagentAspirationStep = () => {
  const commands = [];
  
  pathPumps.value.forEach(pump => {
    if (standardParams.enabledPumps[pump.id]) {
      // 设置泵端口到反应物端口
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          aspiratePort: standardParams.pumpAspiratePorts[pump.id],
          dispensePort: standardParams.pumpDispensePorts[pump.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 10
      });
      
      // 设置泵速度
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: standardParams.pumpSpeeds[pump.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 5
      });
      
      // 抽吸反应溶液
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'aspirate',
        parameters: {
          volume: standardParams.pumpVolumes[pump.id]
        },
        generateCompletionCondition: true,
        completionTimeout: 180 // 3分钟超时
      });
      
      // 如果设置了反应物，记录在备注中
      const reagentInfo = standardParams.pumpReagents[pump.id] 
        ? `${standardParams.pumpReagents[pump.id]}` 
        + (standardParams.pumpConcentrations[pump.id] ? ` (${standardParams.pumpConcentrations[pump.id]})` : '')
        : "反应溶液";
      
      commands[commands.length - 1].note = `抽吸 ${reagentInfo}`;
    }
  });
  
  if (commands.length > 0) {
    // 创建泵位置检查条件
    const positionConditions = [];
    
    // 为每个泵添加检查条件，确保体积已经抽吸到位
    pathPumps.value.forEach(pump => {
      if (standardParams.enabledPumps[pump.id]) {
        const targetVolume = standardParams.pumpVolumes[pump.id];
        positionConditions.push({
          type: 'deviceParameter',
          deviceType: 'pump',
          deviceId: pump.id,
          parameter: 'position',
          comparison: 'gte', // 大于等于
          value: targetVolume * 0.95, // 至少达到95%的目标体积
          timeout: 180 // 3分钟超时
        });
      }
    });
    
    currentWorkflow.steps.push({
      id: `step-${Date.now()}-3`,
      name: '抽吸反应溶液',
      description: '从指定端口抽取反应所需的溶液',
      deviceCommands: commands,
      waitForCompletion: true,
      conditions: positionConditions,
      delayAfter: 3 // 3秒短延迟
    });
  }
};

// 步骤4: 反应运行
const addImprovedReactionRunStep = () => {
  const commands = [];
  
  // 设置泵出液端口
  pathPumps.value.forEach(pump => {
    if (standardParams.enabledPumps[pump.id]) {
      // 设置出液端口
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setPort',
        parameters: {
          aspiratePort: standardParams.pumpAspiratePorts[pump.id],
          dispensePort: standardParams.pumpDispensePorts[pump.id]
        }
      });
      
      // 设置泵速度
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'setSpeed',
        parameters: {
          speed: standardParams.pumpSpeeds[pump.id]
        }
      });
      
      // 排出溶液到反应系统
      commands.push({
        deviceId: pump.id,
        deviceType: 'pump',
        action: 'dispense',
        parameters: {
          // 排出90%的体积，留10%确保不会吸入空气
          volume: standardParams.pumpVolumes[pump.id] * 0.9 
        },
        // 启用自动生成完成条件
        generateCompletionCondition: true,
        completionTimeout: 180 // 3分钟超时
      });
    }
  });
  
  // 添加反应时间等待步骤
  currentWorkflow.steps.push({
    id: `step-${Date.now()}-4`,
    name: '反应溶液输送',
    description: `将反应溶液输送到反应器中`,
    deviceCommands: commands,
    waitForCompletion: true,
    delayAfter: 3 // 3秒稳定等待
  });
  
  // 创建反应持续步骤
  const reactionCommands = [];
  // 可以添加轻微搅动或其他反应过程中需要的辅助命令
  
  // 温度监控条件
  const conditions = [];
  
  // 检查加热器是否达到目标温度
  pathHeaters.value.forEach(heater => {
    if (standardParams.enabledHeaters[heater.id]) {
      conditions.push({
        type: 'deviceParameter',
        deviceType: 'chip',
        deviceId: heater.id,
        parameter: 'currentTemp',
        comparison: 'gte', // 大于等于
        value: standardParams.heaterTemps[heater.id] * 0.95, // 允许5%的误差
        tolerance: 2, // 允许2度误差
        timeout: 300 // 5分钟超时
      });
    }
  });
  
  // 添加反应等待步骤
  currentWorkflow.steps.push({
    id: `step-${Date.now()}-4b`,
    name: '反应进行中',
    description: `反应溶液在加热条件下反应${standardParams.reactionTime}分钟`,
    deviceCommands: reactionCommands,
    waitForCompletion: true,
    // 使用温度条件和超时条件
    conditions: [
      ...conditions,
      {
        type: 'timeout',
        duration: standardParams.reactionTime * 60, // 转换为秒
        description: `反应持续${standardParams.reactionTime}分钟`
      }
    ],
    delayAfter: 0 // 无需额外延迟
  });
};

// 步骤5: 产品收集
const addImprovedProductCollectionStep = () => {
  const commands = [];
  
  // 找出标记为产品收集的阀门
  const productValves = pathValves.value.filter(valve => 
    standardParams.valvesToProduct[valve.id]
  );
  
  productValves.forEach(valve => {
    commands.push({
      deviceId: valve.id,
      deviceType: 'valve',
      action: 'setPosition',
      parameters: {
        position: standardParams.valveProductPositions[valve.id] || 2
      },
      generateCompletionCondition: true,
      completionTimeout: 30 // 30秒超时
    });
  });
  
  if (commands.length > 0) {
    // 创建阀门位置检查条件
    const valveConditions = [];
    
    // 为每个阀门添加位置检查
    productValves.forEach(valve => {
      valveConditions.push({
        type: 'deviceParameter',
        deviceType: 'valve',
        deviceId: valve.id,
        parameter: 'position',
        comparison: 'eq',
        value: standardParams.valveProductPositions[valve.id] || 2,
        timeout: 30 // 30秒超时
      });
    });
    
    currentWorkflow.steps.push({
      id: `step-${Date.now()}-5`,
      name: '产品收集',
      description: '打开与产品收集相连的阀门，将合成产物导向收集容器',
      deviceCommands: commands,
      waitForCompletion: true,
      conditions: valveConditions,
      delayAfter: 3 // 减少延迟
    });
  } else {
    // 如果没有指定产品阀门，添加提示步骤
    currentWorkflow.steps.push({
      id: `step-${Date.now()}-5`,
      name: '产品收集',
      description: '注意：未设置产品收集阀门，请手动操作收集产品',
      deviceCommands: [],
      waitForCompletion: true,
      delayAfter: 5 // 减少延迟
    });
  }
};

// 步骤6: 废液排出
const addImprovedWasteDisposalStep = () => {
  const commands = [];
  
  // 找出标记为废液的阀门
  const wasteValves = pathValves.value.filter(valve => 
    standardParams.valvesToWaste[valve.id]
  );
  
  wasteValves.forEach(valve => {
    commands.push({
      deviceId: valve.id,
      deviceType: 'valve',
      action: 'setPosition',
      parameters: {
        position: standardParams.valvePositions[valve.id] // 使用初始位置
      },
      generateCompletionCondition: true,
      completionTimeout: 30 // 30秒超时
    });
  });
  
  if (commands.length > 0) {
    // 阀门位置检查条件
    const valveConditions = [];
    
    // 为每个阀门添加位置检查
    wasteValves.forEach(valve => {
      valveConditions.push({
        type: 'deviceParameter',
        deviceType: 'valve',
        deviceId: valve.id,
        parameter: 'position',
        comparison: 'eq',
        value: standardParams.valvePositions[valve.id],
        timeout: 30 // 30秒超时
      });
    });
    
    currentWorkflow.steps.push({
      id: `step-${Date.now()}-6`,
      name: '废液排出',
      description: '打开与废液收集相连的阀门，准备系统清洗',
      deviceCommands: commands,
      waitForCompletion: true,
      conditions: valveConditions,
      delayAfter: 3 // 3秒短延迟
    });
  }
};

// 步骤7: 系统清洗
const addImprovedSystemCleaningStep = () => {
  const commands = [];
  
  // 为每个清洗循环创建命令
  for (let cycle = 1; cycle <= standardParams.cleaningCycles; cycle++) {
    pathPumps.value.forEach(pump => {
      if (standardParams.enabledPumps[pump.id]) {
        // 设置泵端口到清洗液位置
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'setPort',
          parameters: {
            aspiratePort: 1, // 固定使用1号端口作为清洗液端口
            dispensePort: 6 // 固定使用6号端口作为废液口
          },
          generateCompletionCondition: true,
          completionTimeout: 10,
          note: `清洗循环 ${cycle}/${standardParams.cleaningCycles}: 设置端口`
        });
        
        // 抽吸清洗液
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'aspirate',
          parameters: {
            volume: standardParams.cleaningVolume
          },
          generateCompletionCondition: true,
          completionTimeout: 60,
          note: `清洗循环 ${cycle}/${standardParams.cleaningCycles}: 抽吸清洗液`
        });
        
        // 设置泵端口到废液位置
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'setPort',
          parameters: {
            aspiratePort: standardParams.pumpAspiratePorts[pump.id],
            dispensePort: 6 // 固定使用6号端口作为废液口
          },
          generateCompletionCondition: true,
          completionTimeout: 10,
          note: `清洗循环 ${cycle}/${standardParams.cleaningCycles}: 设置废液端口`
        });
        
        // 排出清洗液
        commands.push({
          deviceId: pump.id,
          deviceType: 'pump',
          action: 'dispense',
          parameters: {
            volume: standardParams.cleaningVolume * 0.95 // 排出95%确保充分排空
          },
          generateCompletionCondition: true,
          completionTimeout: 60,
          note: `清洗循环 ${cycle}/${standardParams.cleaningCycles}: 排出清洗液`
        });
      }
    });
  }
  
  // 最后关闭加热器
  pathHeaters.value.forEach(heater => {
    if (standardParams.enabledHeaters[heater.id]) {
      commands.push({
        deviceId: heater.id,
        deviceType: 'chip',
        action: 'setTemp',
        parameters: {
          temperature: 25, // 回到室温
          speed: 5 // 低速冷却
        },
        generateCompletionCondition: true,
        completionTimeout: 180 // 3分钟超时，冷却过程较慢
      });
    }
  });
  
  // 创建条件检查
  const cleaningConditions = [];
  
  // 添加泵位置检查（所有泵应该接近空）
  pathPumps.value.forEach(pump => {
    if (standardParams.enabledPumps[pump.id]) {
      cleaningConditions.push({
        type: 'deviceParameter',
        deviceType: 'pump',
        deviceId: pump.id,
        parameter: 'position',
        comparison: 'lte', // 小于等于
        value: 10, // 位置接近0，表示排空
        timeout: 180 // 3分钟超时
      });
    }
  });
  
  // 添加温度检查条件（加热器应冷却到接近室温）
  pathHeaters.value.forEach(heater => {
    if (standardParams.enabledHeaters[heater.id]) {
      cleaningConditions.push({
        type: 'deviceParameter',
        deviceType: 'chip',
        deviceId: heater.id,
        parameter: 'currentTemp',
        comparison: 'lte', // 小于等于
        value: 35, // 低于35度即可
        timeout: 300 // 5分钟超时
      });
    }
  });
  
  currentWorkflow.steps.push({
    id: `step-${Date.now()}-7`,
    name: '系统清洗',
    description: `执行 ${standardParams.cleaningCycles} 次清洗循环，确保管路清洁，并关闭加热器`,
    deviceCommands: commands,
    waitForCompletion: true,
    conditions: cleaningConditions,
    delayAfter: 3 // 减少固定延迟
  });
};
// 暂停或继续流程
const pauseOrResumeWorkflow = () => {
  if (workflowExecutor.status === 'running') {
    workflowExecutor.pauseWorkflow();
    ElMessage.info('流程已暂停');
  } else if (workflowExecutor.status === 'paused') {
    workflowExecutor.resumeWorkflow();
    ElMessage.success('流程已继续执行');
  }
};

// 停止流程
const stopWorkflow = async () => {
  try {
    await ElMessageBox.confirm(
      '确定要终止当前流程吗？此操作不可恢复。',
      '终止确认',
      {
        confirmButtonText: '终止',
        cancelButtonText: '取消',
        type: 'warning',
      }
    );
    
    // 用户确认终止
    workflowExecutor.stopWorkflow();
    ElMessage.warning('流程已终止');
    
    // 重置UI状态
    setTimeout(() => {
      isRunningWorkflow.value = false;
    }, 1000);
    
  } catch (error) {
    if (error !== 'cancel') {
      console.error('终止流程失败:', error);
      ElMessage.error(`终止失败: ${error.message}`);
    }
  }
};
// 计算执行进度百分比
const calculateProgress = () => {
  if (!currentWorkflow || !currentWorkflow.steps || currentWorkflow.steps.length === 0) {
    return 0;
  }
  
  return Math.round((workflowExecutor.activeStepIndex / currentWorkflow.steps.length) * 100);
};

// 获取进度状态
const getProgressStatus = () => {
  switch (workflowExecutor.status) {
    case 'completed':
      return 'success';
    case 'error':
      return 'exception';
    case 'paused':
      return 'warning';
    default:
      return '';
  }
};
// 翻译执行状态
const translateExecutionStatus = (status) => {
  const statusMap = {
    'idle': '空闲',
    'running': '运行中',
    'paused': '已暂停',
    'completed': '已完成',
    'error': '出错'
  };
  
  return statusMap[status] || status;
};

// 格式化日期
const formatDate = (dateString) => {
  if (!dateString) return '';
  
  const date = new Date(dateString);
  return date.toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
};

// 模拟获取传感器值
const getSensorValue = async (sensorId) => {
  // 这里应该实现真实的传感器数据获取逻辑
  // 目前使用随机值模拟
  return Math.random() * 100;
};

// 简化的流程编辑函数
const openWorkflowDialog = () => {
  // 清空当前流程
  createNewWorkflow();
  
  // 直接从参数生成工作流
  if (pendingChanges.value && pendingChanges.value.size > 0) {
    generateWorkflowFromPendingChanges();
  } else {
    ElMessage.info('请先设置设备参数以生成工作流');
  }
};

// 反应路径选择面板 - 新增
const isShowingReactionPath = ref(false);
const selectedReactionPathIndex = ref(null);

// 反应路径示例数据 - 修改为从graph_mapping.json加载
const reactionPaths = ref([]);
// 添加反应路径加载状态和错误信息
const isLoadingReactionPaths = ref(false);
const reactionPathsError = ref('');

// 加载graph_mapping.json中的反应路径数据
const loadMappingData = async () => {
  try {
    isLoadingReactionPaths.value = true;
    reactionPathsError.value = '';
    
    // 不再从后端获取mapping数据，直接加载默认路径
    console.log('反应路径映射服务已移除，使用默认反应路径数据');
    loadDefaultReactionPaths();
  } catch (error) {
    console.error('加载反应路径数据失败:', error);
    reactionPathsError.value = `加载反应路径数据失败: ${error.message}`;
    
    // 加载默认的反应路径数据作为备用
    loadDefaultReactionPaths();
  } finally {
    isLoadingReactionPaths.value = false;
  }
};

// 加载默认的反应路径数据作为备用
const loadDefaultReactionPaths = () => {
  reactionPaths.value = [
    {
      id: 'reaction-path-1',
      name: '醇类氧化反应路径',
      description: '使用催化剂将醇类氧化为醛或酮',
      nodes: ['pump-1', 'valve-1', 'chip-1', 'bottle-1', 'valve-2'],
      edges: [],
      color: '#FF5733' // 路径颜色
    },
    {
      id: 'reaction-path-2',
      name: '加氢反应路径',
      description: '在催化剂存在下将不饱和有机化合物加氢',
      nodes: ['pump-2', 'valve-3', 'mfc-1', 'chip-2', 'bottle-2'],
      edges: [],
      color: '#33A1FF' // 路径颜色
    },
    {
      id: 'reaction-path-3',
      name: '酯化反应路径',
      description: '羧酸与醇反应生成酯和水',
      nodes: ['pump-1', 'pump-3', 'valve-1', 'valve-4', 'chip-1', 'bottle-3'],
      edges: [],
      color: '#33FF57' // 路径颜色
    }
  ];
  console.log('已加载默认反应路径数据');
};

// 切换反应路径面板显示状态
const toggleReactionPathPanel = () => {
  isShowingReactionPath.value = !isShowingReactionPath.value;
  
  if (isShowingReactionPath.value) {
    // 打开面板时，如果反应路径为空，尝试加载反应路径数据
    if (reactionPaths.value.length === 0) {
      loadMappingData();
    }
    
    // 更新反应路径数据
    if (graph && graph.getNodeData().length > 0) {
      updateReactionPathEdges();
    } else {
      console.log("图表尚未初始化或没有节点数据，等待硬件结构加载");
      ElMessage.info('请先选择硬件结构，以便查看反应路径');
    }
  } else {
    // 关闭面板时重置选择
    clearReactionPathHighlight();
  }
};

// 修改反应路径面板的模板，添加加载状态和错误信息
const updateReactionPathPanel = () => {
  // 这里可以动态更新反应路径面板的内容
  // 由于Vue的响应式特性，只需更新reactionPaths.value即可
  console.log('反应路径面板已更新');
};

// 添加hardwareLoaded事件处理函数，在硬件结构加载后主动更新反应路径
const onHardwareStructureLoaded = () => {
  // 延迟执行，确保图表渲染完成
  setTimeout(() => {
    if (graph && graph.getNodeData().length > 0) {
      console.log("硬件结构已加载，更新反应路径数据");
      
      // 如果反应路径为空且未处于加载状态，尝试加载反应路径数据
      if (reactionPaths.value.length === 0 && !isLoadingReactionPaths.value) {
        loadMappingData();
      } else {
        updateReactionPathEdges();
      }
      
      // 如果反应路径面板已打开并选择了路径，重新应用高亮
      if (isShowingReactionPath.value && selectedReactionPathIndex.value !== null) {
        selectReactionPath(selectedReactionPathIndex.value);
      }
    }
  }, 500);
};


// 解析URL参数中的编辑数据
const parseEditDataFromUrl = () => {
  const route = useRoute();
  
  // 检查URL是否包含编辑模式参数
  if (route.query.editMode === 'true' && route.query.editData) {
    try {
      // 解析传递的数据
      const editData = JSON.parse(route.query.editData);
      console.log('Received edit data:', editData);
      
      // 设置编辑模式
      isEditMode.value = true;
      editTaskData.value = editData;
      
      // 初始化设备参数对象
      if (editData.matchedPath && Array.isArray(editData.matchedPath)) {
        editData.matchedPath.forEach(deviceId => {
          deviceParameters.value[deviceId] = {
            id: deviceId,
            // 根据设备类型设置默认参数
            parameters: getDefaultParametersForDevice(deviceId)
          };
        });
      }
      
      // 如果有反应时间，设置为默认值
      if (editData.reactTime) {
        deviceParameters.value.reactTime = editData.reactTime;
      }
      
      return true;
    } catch (error) {
      console.error('Failed to parse edit data:', error);
      ElMessage.error('解析编辑数据失败');
    }
  }
  
  return false;
};

// 根据设备类型获取默认参数
const getDefaultParametersForDevice = (deviceId) => {
  // 从设备ID提取类型 (例如 "pump-1" -> "pump")
  const deviceType = deviceId.split('-')[0];
  
  switch (deviceType) {
    case 'pump':
      return {
        speed: 100,  // 默认速度
        flowRate: 5.0,  // 默认流速
        direction: 'forward'  // 默认方向
      };
    case 'valve':
      return {
        position: 1  // 默认位置
      };
    case 'chip':
      return {
        temperature: 25.0,  // 默认温度 (摄氏度)
        heatingRate: 5.0  // 默认加热速率
      };
    case 'mfc':
      return {
        flowRate: 10.0  // 默认气体流速
      };
    case 'bottle':
      return {
        volume: 100.0  // 默认容量 (mL)
      };
    default:
      return {};
  }
};

// 添加保存参数并返回任务界面的方法
const saveParametersAndReturn = () => {
  if (!isEditMode.value || !editTaskData.value) {
    ElMessage.warning('未处于编辑模式或缺少任务数据');
    return;
  }
  
  try {
    // 创建要返回的参数对象
    const returnData = {
      taskId: editTaskData.value.taskId,
      taskKey: editTaskData.value.taskKey,
      matchIndex: editTaskData.value.matchIndex,
      parameters: deviceParameters.value,
      reactTime: deviceParameters.value.reactTime || editTaskData.value.reactTime
    };
    
    // 直接使用postMessage发送数据给父窗口
    window.parent.postMessage({
      type: 'TASK_EDIT_RETURN',
      data: JSON.stringify(returnData)
    }, '*');  // 在生产环境中应该限制目标源
    
    // 显示成功消息
    ElMessage.success('参数已保存并发送至任务界面');
    
    // 延迟关闭当前iframe
    setTimeout(() => {
      // 告诉父窗口关闭iframe
      window.parent.postMessage({
        type: 'CLOSE_EDIT_DIALOG',
        success: true
      }, '*');
    }, 1000);
  } catch (error) {
    console.error('保存参数失败:', error);
    ElMessage.error('保存参数失败');
  }
};

// 取消编辑并返回
const cancelEditAndReturn = () => {
  // 发送取消消息给父窗口
  window.parent.postMessage({
    type: 'TASK_EDIT_CANCEL'
  }, '*');
  
  // 显示消息
  ElMessage.info('已取消编辑');
};

// 添加加载编辑数据的反应路径方法
const loadEditPathData = async () => {
  try {
    if (!editTaskData.value || !editTaskData.value.matchData) {
      ElMessage.warning('缺少编辑数据，无法加载反应路径');
      return;
    }
    
    // 根据匹配数据加载路径
    const pathData = editTaskData.value.matchData;
    
    // 创建反应路径对象
    const editReactionPath = {
      id: `edit-path-${Date.now()}`,
      name: `${editTaskData.value.taskName} (${editTaskData.value.taskKey})`,
      description: `编辑反应路径: ${editTaskData.value.product || '未知产物'}`,
      nodes: editTaskData.value.matchedPath || [],
      edges: [],
      color: '#4285F4', // 编辑模式使用的颜色
      originalMatch: pathData
    };
    
    // 设置反应路径数据
    reactionPaths.value = [editReactionPath];
    
    // 如果图表已加载，立即更新边数据
    if (graph && graph.getNodeData().length > 0) {
      updateReactionPathEdges();
      
      // 突出显示反应路径
      selectReactionPath(0);
      
      // 显示编辑模式提示
      ElMessage.info(`正在编辑反应路径: ${editReactionPath.name}`);
    } else {
      // 加载适当的硬件结构以显示反应路径
      console.log("尝试加载匹配的硬件结构...");
      
      // 这里可以添加加载特定硬件结构的逻辑
      // 例如，根据matchedPath中的设备推断应该加载哪个硬件结构
    }
  } catch (error) {
    console.error('加载编辑数据的反应路径失败:', error);
    ElMessage.error('加载编辑数据的反应路径失败');
  }
};

// 添加打开设备参数面板的方法
const openDeviceParameterPanel = (deviceId) => {
  // 检查设备是否在参数列表中
  if (!deviceParameters.value[deviceId]) {
    deviceParameters.value[deviceId] = {
      id: deviceId,
      parameters: getDefaultParametersForDevice(deviceId)
    };
  }
  
  // 显示设备参数设置面板
  // 这里可以使用现有的设备控制面板逻辑，只需修改为编辑参数模式
  showDeviceParameterEditPanel(deviceId);
};

// 显示设备参数编辑面板
const showDeviceParameterEditPanel = (deviceId) => {
  // 获取设备数据
  const device = graph.findById(deviceId);
  if (!device) {
    ElMessage.warning(`找不到设备: ${deviceId}`);
    return;
  }
  
  const model = device.getModel();
  
  // 设置当前设备数据
  deviceData.value = {
    id: deviceId,
    type: getDeviceTypeFromId(deviceId),
    // 复制现有参数或使用默认值
    ...deviceParameters.value[deviceId]?.parameters
  };
  
  // 显示控制面板
  showControlPanel.value = true;
};

// 从设备ID获取设备类型
const getDeviceTypeFromId = (deviceId) => {
  const parts = deviceId.split('-');
  return parts[0];
};

// 组件挂载完成后初始化图表
onMounted(async () => {
  try {
    console.log("组件挂载完成");
    
    // 确保侧边栏打开
    isSidebarOpen.value = true;
    
    // 初始化G6 v5图
    const graphWidth = container.value.clientWidth;
    const graphHeight = container.value.clientHeight || 600;
    
    console.log(`初始化图形，尺寸: ${graphWidth}x${graphHeight}`);
    console.log("isDragEnabled", isDragEnabled.value);
    
    // 创建图形实例
    graph = new Graph({
      container: container.value,
      width: graphWidth,
      height: graphHeight,
      behaviors: [
        // ... existing behaviors ...
      ],
    });
    
    // 注册节点点击事件
    graph.on('node:click', (e) => {
      // 原有的处理逻辑
      handleDeviceClick(e);
    });
    
    // 加载保存的硬件结构列表和现有设备
    await loadSavedPaths();
    
    // 启动设备数据刷新
    startDeviceDataRefresh();
    
    // 处理窗口大小变化 - 带防抖
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resizeGraph();
      }, 200);
    });
    
    // 延迟建立WebSocket连接，确保其他组件准备就绪
    setTimeout(() => {
      connectWebSocket();
    }, 1000);
    
    // 添加消息监听
    window.addEventListener('message', (event) => {
      try {
        console.log('收到postMessage消息:', event.data);
      } catch (error) {
        console.error('处理postMessage消息失败:', error);
        errorMessage.value = `处理消息失败: ${error.message}`;
      }
    });
  } catch (error) {
    console.error("组件挂载出错:", error);
    errorMessage.value = `初始化出错: ${error.message}`;
  }
});

// 修改反应路径面板的HTML模板
// 根据当前图上的节点和边计算反应路径的边
const updateReactionPathEdges = () => {
  if (!graph) return;
  
  // 获取所有图上的边
  const allEdges = graph.getEdgeData();
  console.log("图上的所有边:", allEdges);
  
  // 获取所有图上的节点
  const allNodes = graph.getNodeData();
  const existingNodeIds = allNodes.map(node => node.id);
  
  // 遍历反应路径，找出每个路径所需的边
  reactionPaths.value.forEach(path => {
    // 先过滤不存在的节点
    path.nodes = path.nodes.filter(nodeId => existingNodeIds.includes(nodeId));
    
    const pathNodes = path.nodes;
    const pathEdges = [];
    
    // 查找连接路径中任意两个节点的边
    allEdges.forEach(edge => {
      if (pathNodes.includes(edge.source) && pathNodes.includes(edge.target)) {
        pathEdges.push(edge.id);
      }
    });
    
    // 更新路径的边
    path.edges = pathEdges;
    console.log(`反应路径 ${path.name} 的边:`, pathEdges);
  });
};

// 硬件图完全加载后调用
const initReactionPathsForGraph = () => {
  if (!graph) return;
  
  console.log("初始化反应路径数据");
  
  const nodes = graph.getNodeData();
  const edges = graph.getEdgeData();
  
  if (nodes.length > 0) {
    // 预处理反应路径数据
    preprocessReactionPaths(nodes, edges);
    
    // 更新右侧面板
    if (isShowingReactionPath.value && selectedReactionPathIndex.value !== null) {
      selectReactionPath(selectedReactionPathIndex.value);
    }
  }
};

// 在成功后调用
const onGraphLoaded = () => {
  console.log("硬件图加载完成，初始化反应路径");
  
  // 延迟执行，确保图已完全渲染
  setTimeout(() => {
    initReactionPathsForGraph();
  }, 500);
};

// 选择反应路径
const selectReactionPath = (index) => {
  try {
    // 先清除上一次的高亮
    clearReactionPathHighlight(false);
    
    selectedReactionPathIndex.value = index;
    const path = reactionPaths.value[index];
    
    if (!path || !graph) {
      console.warn("无效的反应路径或图表未初始化");
      return;
    }
    
    console.log(`选择反应路径: ${path.name}`);
    
    updateReactionPathEdges();
    
    if (path.edges.length === 0) {
      ElMessage.warning("反应路径边为空，请先选择硬件结构");
    }
    
    // 首先重置所有边的样式，确保完全清除先前的高亮效果
    const allEdges = graph.getEdgeData();
    graph.updateEdgeData(allEdges.map(edge => ({
      id: edge.id,
      style: {
        stroke: '#91d5ff',
        lineWidth: 2,
        opacity: 1,
        shadowBlur: 0,
        shadowColor: null,
        animates: [],
        endArrow: {
          fill: '#91d5ff',
          stroke: '#91d5ff'
        }
      },
      keyShape: {
        stroke: '#91d5ff',
        lineWidth: 2,
        opacity: 1
      }
    })));
    
    // 高亮路径中的节点
    const nodeUpdates = path.nodes.map(nodeId => ({
      id: nodeId,
      style: {
        lineWidth: 2,
        stroke: path.color,
        shadowColor: path.color,
        shadowBlur: 10,
        // 添加动画类名
        animates: [
          {
            iterations: Infinity, // 无限循环
            attribute: 'shadowBlur', // 要动画的属性
            duration: 1500, // 动画时长 (ms)
            easing: 'ease-in-out', // 缓动函数
            keyframes: [
              { value: 10, time: 0 },
              { value: 15, time: 0.5 },
              { value: 10, time: 1 }
            ]
          }
        ]
      }
    }));
    
    if (nodeUpdates.length > 0) {
      graph.updateNodeData(nodeUpdates);
    }
    
    // 高亮路径中的边
    const edgeUpdates = path.edges.map(edgeId => ({
      id: edgeId,
      style: {
        stroke: path.color,
        lineWidth: 5,  // 增加线宽
        opacity: 1,    // 完全不透明
        endArrow: {
          fill: path.color,
          stroke: path.color,
          lineWidth: 3
        },
        // 添加强烈的发光效果
        shadowColor: path.color,
        shadowBlur: 12,
        // 使用边缘发光动画
        animates: [
          {
            iterations: Infinity,
            attribute: 'shadowBlur',
            duration: 1500,
            easing: 'ease-in-out',
            keyframes: [
              { value: 8, time: 0 },
              { value: 15, time: 0.5 },
              { value: 8, time: 1 }
            ]
          }
        ]
      },
      // 直接修改keyShape，确保颜色被正确应用
      keyShape: {
        stroke: path.color,
        lineWidth: 5,
        opacity: 1
      }
    }));
    
    // 清除原有边的显示（通过将其设为几乎透明）
    const allEdgeIds = graph.getEdgeData().map(edge => edge.id);
    const nonPathEdges = allEdgeIds.filter(id => !path.edges.includes(id));
    
    const fadeEdgeUpdates = nonPathEdges.map(edgeId => ({
      id: edgeId,
      style: {
        opacity: 0.5,
        stroke: '#cccccc',
        lineWidth: 1,
        shadowBlur: 0,
        shadowColor: null,
        animates: []
      },
      keyShape: {
        opacity: 0.5,
        stroke: '#cccccc',
        lineWidth: 1
      }
    }));
    
    // 先更新需要隐藏的边
    if (fadeEdgeUpdates.length > 0) {
      graph.updateEdgeData(fadeEdgeUpdates);
    }
    
    // 再更新高亮的边
    if (edgeUpdates.length > 0) {
      graph.updateEdgeData(edgeUpdates);
    }
    
    // 渲染更新
    graph.render();
    
    // 自动找到合适的查看范围
    const pathNodeIds = path.nodes;
    if (pathNodeIds.length > 0) {
      // 使用G6 v5正确的方法来聚焦元素
      graph.fitView({
        padding: 20, // 设置边距
        nodes: pathNodeIds, // 指定要聚焦的节点
        duration: 500, // 动画时长
        easing: 'ease' // 动画缓动函数
      });
    }
    
    ElMessage.success(`已显示 ${path.name} 反应路径`);
  } catch (error) {
    console.error("选择反应路径出错:", error);
    ElMessage.error(`高亮反应路径失败: ${error.message}`);
  }
};

// 清除反应路径高亮
const clearReactionPathHighlight = (resetSelection = true) => {
  try {
    if (!graph) return;
    
    console.log("清除反应路径高亮");
    
    // 恢复所有节点的默认样式
    const nodes = graph.getNodeData();
    const nodeUpdates = nodes.map(node => {
      // 根据设备状态设置正确的颜色
      let strokeColor = "#1890ff"; // 默认边框颜色
      let shadowColor = "rgba(0,0,0,0.1)"; // 默认阴影颜色
      
      // 如果可以从全局设备仓库获取设备状态，则使用对应状态颜色
      if (globalDevices.value.has(node.id)) {
        const deviceStatus = globalDevices.value.get(node.id).status;
        
        switch (deviceStatus) {
          case "running":
          case "open":
          case "heating":
            strokeColor = "#67c23a"; // 绿色
            shadowColor = "rgba(103, 194, 58, 0.3)";
            break;
          case "stopped":
          case "closed":
          case "idle":
            strokeColor = "#909399"; // 灰色
            shadowColor = "rgba(144, 147, 153, 0.3)";
            break;
          case "error":
            strokeColor = "#f56c6c"; // 红色
            shadowColor = "rgba(245, 108, 108, 0.3)";
            break;
          case "cooling":
            strokeColor = "#1890ff"; // 蓝色
            shadowColor = "rgba(24, 144, 255, 0.3)";
            break;
        }
      }
      
      return {
        id: node.id,
        style: {
          lineWidth: 1,
          stroke: strokeColor,
          shadowColor: shadowColor,
          shadowBlur: 5,
          // 移除动画效果
          animates: []
        }
      };
    });
    
    // 恢复所有边的默认样式
    const edges = graph.getEdgeData();
    const edgeUpdates = edges.map(edge => ({
      id: edge.id,
      style: {
        stroke: '#91d5ff',
        lineWidth: 2,
        opacity: 1,
        shadowBlur: 0,
        shadowColor: null,
        endArrow: {
          fill: '#91d5ff',
          stroke: '#91d5ff'
        },
        // 移除动画
        animates: []
      },
      // 重要：添加keyShape重置，彻底清除前一个路径的颜色设置
      keyShape: {
        stroke: '#91d5ff',
        lineWidth: 2,
        opacity: 1
      }
    }));
    
    // 更新节点和边的样式
    if (nodeUpdates.length > 0) {
      graph.updateNodeData(nodeUpdates);
    }
    
    if (edgeUpdates.length > 0) {
      graph.updateEdgeData(edgeUpdates);
    }
    
    graph.render();
    
    // 重置选择状态
    if (resetSelection) {
      selectedReactionPathIndex.value = null;
    }
    
    ElMessage.info('已清除反应路径高亮');
  } catch (error) {
    console.error("清除反应路径高亮出错:", error);
    ElMessage.error(`清除反应路径高亮失败: ${error.message}`);
  }
};

// 加载硬件图后，预处理反应路径
const preprocessReactionPaths = (nodes, edges) => {
  if (!nodes || !edges) return;
  
  console.log("预处理反应路径数据");
  
  // 根据硬件图中的实际节点过滤反应路径
  const existingNodeIds = nodes.map(node => node.id);
  
  reactionPaths.value.forEach(path => {
    // 过滤掉不存在的节点
    path.nodes = path.nodes.filter(nodeId => existingNodeIds.includes(nodeId));
    
    // 计算这个路径使用的边
    const pathEdges = [];
    edges.forEach(edge => {
      if (path.nodes.includes(edge.source) && path.nodes.includes(edge.target)) {
        pathEdges.push(edge.id);
      }
    });
    
    path.edges = pathEdges;
    console.log(`预处理后的反应路径 ${path.name}: ${path.nodes.length}个节点, ${path.edges.length}个边`);
  });
};
// 获取设备类型显示标签
const getDeviceTypeLabel = (type) => {
  const labels = {
    'pump': '泵',
    'valve': '阀门',
    'chip': '加热芯片',
    'mfc': 'MFC控制器',
    'light': '光照控制',
    'bottle': '瓶'
  };
  return labels[type] || type;
};

// 获取参数显示标签
const getParameterLabel = (param) => {
  const labels = {
    'position': '位置',
    'speed': '速度',
    'currentTemp': '当前温度',
    'targetTemp': '目标温度',
    'flowRate': '流速',
    'intensity': '光强'
  };
  return labels[param] || param;
};

// 获取比较操作符显示标签
const getComparisonLabel = (comparison) => {
  const labels = {
    'eq': '等于',
    'gt': '大于',
    'lt': '小于',
    'gte': '大于等于',
    'lte': '小于等于',
    'approx': '约等于'
  };
  return labels[comparison] || comparison;
};

// 获取参数单位
const getUnitForParameter = (param) => {
  const units = {
    'position': '',
    'speed': '%',
    'currentTemp': '°C',
    'targetTemp': '°C',
    'flowRate': 'ml/min',
    'intensity': '%'
  };
  return units[param] || '';
};

// 从匹配数据加载图形
const loadGraphFromMatchData = (matchData) => {
  try {
    if (!matchData) {
      errorMessage.value = '缺少匹配数据，无法加载反应路径';
      return;
    }
    
    isLoading.value = true;
    
    console.log('从匹配数据加载图形:', matchData);
    
    // 解析匹配数据，转换为G6可用的节点和边数据
    let nodes = [];
    let links = [];
    
    // 检查匹配数据格式并提取节点和连接信息
    if (matchData.nodes && Array.isArray(matchData.nodes)) {
      nodes = matchData.nodes;
      links = matchData.links || [];
    } else if (typeof matchData === 'object') {
      // 尝试从H_with_map中提取节点和边
      const graphData = {
        nodes: [],
        links: []
      };
      
      // 提取节点
      for (const key in matchData) {
        if (key === 'nodes' && Array.isArray(matchData.nodes)) {
          graphData.nodes = matchData.nodes;
        }
        if (key === 'links' && Array.isArray(matchData.links)) {
          graphData.links = matchData.links;
        }
      }
      
      nodes = graphData.nodes;
      links = graphData.links;
    }
    
    // 如果找不到节点数据，报错并退出
    if (!nodes.length) {
      errorMessage.value = '无法解析匹配数据中的节点信息';
      isLoading.value = false;
      return;
    }
    
    // 创建图形对象
    if (graph) {
      graph.clear();
    }
    
    // 处理节点数据
    const nodesData = nodes.map(node => {
      const deviceType = node.data?.deviceType || node.id.split('-')[0] || 'unknown';
      
      // 根据设备类型设置图标
      let iconSrc;
      switch (deviceType) {
        case 'pump': iconSrc = pump; break;
        case 'valve': iconSrc = valve; break;
        case 'chip': iconSrc = chip; break;
        case 'mfc': iconSrc = mfc; break;
        case 'light': iconSrc = light; break;
        case 'bottle': iconSrc = bottle; break;
        default: iconSrc = bottle;
      }
      
      return {
        id: node.id,
        type: 'image',
        data: {
          deviceType: deviceType,
          label: node.data?.label || `设备 ${node.id}`
        },
        style: {
          x: node.style?.x || 100 + Math.random() * 300,
          y: node.style?.y || 100 + Math.random() * 200,
          size: node.style?.size || [40, 40],
          src: iconSrc,
          label: node.style?.label || `设备 (${node.id})`,
          labelCfg: {
            position: 'bottom',
            offset: [0, 5],
            style: {
              fill: '#333',
              fontSize: 12
            }
          }
        }
      };
    });
    
    // 处理边数据
    const edgesData = links.map(link => {
      return {
        id: `edge-${link.source}-${link.target}`,
        source: link.source,
        target: link.target,
        style: {
          stroke: link.style?.stroke || '#91d5ff',
          lineWidth: 2,
          endArrow: {
            fill: link.style?.stroke || '#91d5ff',
            stroke: link.style?.stroke || '#91d5ff'
          }
        }
      };
    });
    
    // 添加节点和边数据到图形
    graph.addNodeData(nodesData);
    graph.addEdgeData(edgesData);
    
    // 渲染图形
    graph.render();
    
    // 高亮匹配路径
    if (editTaskData.value && editTaskData.value.matchedPath) {
      const pathNodes = editTaskData.value.matchedPath;
      
      // 高亮路径中的节点
      const nodeUpdates = pathNodes.map(nodeId => ({
        id: nodeId,
        style: {
          lineWidth: 2,
          stroke: '#4285F4',
          shadowColor: '#4285F4',
          shadowBlur: 10
        }
      }));
      
      if (nodeUpdates.length > 0) {
        graph.updateNodeData(nodeUpdates);
      }
      
      // 高亮路径中的边
      const pathEdges = [];
      edgesData.forEach(edge => {
        if (pathNodes.includes(edge.source) && pathNodes.includes(edge.target)) {
          pathEdges.push(edge.id);
        }
      });
      
      const edgeUpdates = pathEdges.map(edgeId => ({
        id: edgeId,
        style: {
          stroke: '#4285F4',
          lineWidth: 3,
          endArrow: {
            fill: '#4285F4',
            stroke: '#4285F4'
          }
        }
      }));
      
      if (edgeUpdates.length > 0) {
        graph.updateEdgeData(edgeUpdates);
      }
      
      // 设置视图自适应
      graph.fitView({
        padding: [20, 40, 20, 40],
        animate: true
      });
    }
    
    // 编辑模式信息提示
    ElMessage.success(`已加载任务 ${editTaskData.value.taskName} 的反应路径，请点击设备调整参数`);
    
  } catch (error) {
    console.error('加载匹配数据失败:', error);
    errorMessage.value = `加载匹配数据失败: ${error.message}`;
  } finally {
    isLoading.value = false;
  }
};

// 监听硬件图加载完成
watch(() => selectedPath.value, (newPath) => {
  if (newPath) {
    console.log("硬件图路径变更，更新反应路径数据");
    
    // 延迟执行，确保图已加载完成
    setTimeout(() => {
      if (graph) {
        const nodes = graph.getNodeData();
        const edges = graph.getEdgeData();
        
        // 预处理路径数据
        preprocessReactionPaths(nodes, edges);
        
        // 如果有选中的反应路径，重新应用高亮
        if (selectedReactionPathIndex.value !== null) {
          selectReactionPath(selectedReactionPathIndex.value);
        }
      }
    }, 500);
  }
});
</script>

<style scoped>
/* 控制面板分区样式 */
.reaction-path-button {
  position: relative;
  background-color: #722ed1;
  color: white;
  border-color: #722ed1;
}

.reaction-path-button::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.3), rgba(255,255,255,0.1));
  background-size: 300% 100%;
  border-radius: 4px;
  z-index: 1;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  animation: shimmer 2s infinite;
}

.reaction-path-button.active::after {
  opacity: 1;
}

@keyframes shimmer {
  0% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
.device-controls {
  display: flex;
  flex-direction: column;
  gap: 15px;
  width: 100%;
}

.current-status-section, .control-section {
  padding: 12px;
  border-radius: 6px;
  background-color: #f9f9f9;
  border: 1px solid #e8e8e8;
}

.current-status-section {
  background-color: #f0f7ff;
  border-color: #d0e6ff;
}

.control-section {
  background-color: #f6ffed;
  border-color: #d9f7be;
}

.section-title {
  font-weight: bold;
  font-size: 14px;
  padding-bottom: 8px;
  margin-bottom: 10px;
  border-bottom: 1px solid #ddd;
}

.status-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
}

.status-label {
  color: #666;
  font-weight: 500;
}

.status-value {
  font-weight: bold;
  color: #1890ff;
}

@media screen and (min-width: 768px) {
  .device-controls {
    flex-direction: row;
  }
  
  .current-status-section, .control-section {
    flex: 1;
  }
}
.main-container {
  position: relative;
  height: 100vh;
  overflow: hidden;
}

/* 工具栏样式 */
.toolbar {
  position: fixed;
  top: 90px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  padding: 10px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgb(0 0 0 / 10%);
}

/* 连线模式底部容器 */
.edge-mode-container {
  position: absolute;
  right: 0;
  bottom: 20px;
  left: 0;
  padding: 0 20px;
  padding-top: 15px;
  background: white;
  border-top: 1px solid #f0f0f0;
}

.edge-mode-button {
  display: flex;
  align-items: center;
  width: 100%;
  padding: 10px 15px;
  color: #666;
  cursor: pointer;
  background: #f5f5f5;
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  box-shadow: 0 2px 5px rgb(0 0 0 / 5%);
  transition: all 0.3s;
}

.edge-mode-button:hover {
  color: #1890ff;
  background: #f0f0f0;
  transform: translateY(-2px);
}

.edge-mode-button.active {
  color: #1890ff;
  background: #e6f7ff;
  border-color: #91d5ff;
}

.edge-mode-button svg {
  margin-right: 8px;
}

.tool-button {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 5px;
  color: #666;
  cursor: pointer;
  background: #f5f5f5;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  transition: all 0.3s;
}

.tool-button:hover {
  color: #1890ff;
  background: #f0f0f0;
}

.tool-button.active {
  color: #1890ff;
  background: #e6f7ff;
  border-color: #91d5ff;
}

.tool-button svg {
  margin-right: 5px;
}

.sidebar-toggle {
  position: fixed;
  top: 50%;
  left: 200px;
  z-index: 1000;
  padding: 10px;
  cursor: pointer;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgb(0 0 0 / 10%);
  transition: left 0.3s;
}

/* 当框架侧边栏折叠时，按钮位置调整 */
.toggle-framework-collapsed {
  left: 54px;
}

.sidebar {
  position: fixed;
  top: 83px;
  bottom: 0;
  left: 200px;
  z-index: 999;
  display: flex;
  flex-direction: column;
  width: 200px;
  padding: 20px;
  overflow-y: auto;
  background: white;
  box-shadow: 2px 0 10px rgb(0 0 0 / 10%);
  transition: all 0.3s;
  transform: translateX(0);
}

/* 图标容器，让它可以滚动且占据主要空间 */
.icons-container {
  flex: 1;
  margin-bottom: 80px; /* 为底部按钮预留空间 */
  overflow-y: auto;
}

/* 当框架侧边栏折叠时的样式 */
.sidebar-collapsed {
  left: 54px; /* 框架侧边栏折叠后的宽度 */
}

/* 当侧边栏隐藏时的样式 */
.sidebar-hidden {
  transform: translateX(-100%);
}

.icon-item {
  display: flex;
  align-items: center;
  padding: 10px;
  margin: 8px 0;
  cursor: move;
  background: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 6px;
  transition: all 0.3s;

  &:hover {
    background: #f0f9ff;
    box-shadow: 0 2px 6px rgb(0 0 0 / 5%);
    transform: translateY(-2px);
  }
}

.icon-image {
  display: block;
  width: 26px;
  height: 26px;
  margin-right: 10px;
}

.graph-container {
  position: relative;
  height: 600px;
  margin-left: 0; /* 侧边栏宽度 */
  background-color: #fff;
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  box-shadow: 0 3px 10px rgb(0 0 0 / 5%);
  transition:
    margin 0.3s,
    border-color 0.3s;
}

/* 禁用拖拽时的样式 */
.graph-container.drag-disabled::before {
  position: absolute;
  inset: 0;
  z-index: 1;
  pointer-events: none;
  content: "";
  background-color: rgb(0 0 0 / 2%);
  border-radius: 8px;
}

/* 当自定义侧边栏关闭时 */
.graph-container-full {
  margin-left: 0;
}

/* 当框架侧边栏折叠时 */
.graph-container-collapsed {
  margin-left: 254px; /* 框架侧边栏折叠宽度(54px) + 自定义侧边栏宽度(200px) */
}

/* 当自定义侧边栏关闭且框架侧边栏折叠时 */
.graph-container-full.graph-container-collapsed {
  margin-left: 54px; /* 仅框架侧边栏折叠宽度 */
}

/* 设备控制面板样式 */
.device-control-panel {
  position: fixed;
  inset: 0;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgb(0 0 0 / 50%);
}

.panel-header {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 80%;
  max-width: 600px;
  padding: 15px 20px;
  background-color: #f0f9ff;
  border-bottom: 1px solid #e6f7ff;
  border-radius: 8px 8px 0 0;
}

.panel-header h3 {
  margin: 0;
  color: #1890ff;
}

.close-btn {
  font-size: 1.5rem;
  color: #666;
  cursor: pointer;
  background: none;
  border: none;
  transition: color 0.3s;
}

.close-btn:hover {
  color: #f56c6c;
}

.panel-content {
  box-sizing: border-box;
  width: 80%;
  max-width: 600px;
  padding: 20px;
  background-color: #fff;
  border-radius: 0 0 8px 8px;
  box-shadow: 0 4px 12px rgb(0 0 0 / 15%);
}

.device-info {
  display: flex;
  flex-direction: column;
}

.device-id {
  font-weight: bold;
  margin-bottom: 4px;
}

.device-module-id {
  font-size: 12px;
  color: #999;
}

.device-status {
  display: inline-block;
  padding: 5px 10px;
  margin-top: 8px;
  font-weight: bold;
  border-radius: 4px;
}

/* 设备状态颜色 */
.device-status.running,
.device-status.open,
.device-status.heating {
  color: #67c23a;
  background-color: #f0f9eb;
}

.device-status.stopped,
.device-status.closed,
.device-status.idle {
  color: #909399;
  background-color: #f4f4f5;
}

.device-status.error {
  color: #f56c6c;
  background-color: #fef0f0;
}

.device-status.cooling {
  color: #1890ff;
  background-color: #e6f7ff;
}

.device-controls {
  margin-bottom: 20px;
}

.data-row {
  display: flex;
  justify-content: space-between;
  padding: 8px;
  margin-bottom: 12px;
  background: #f9f9f9;
  border-radius: 4px;
}

.control-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  margin: 15px 0;
}

.control-row button {
  padding: 8px 15px;
  margin-right: 10px;
  color: white;
  cursor: pointer;
  background: #1890ff;
  border: none;
  border-radius: 4px;
  transition: all 0.3s;
}

.control-row button:hover {
  background-color: #40a9ff;
  box-shadow: 0 2px 6px rgb(24 144 255 / 20%);
}

.control-row span {
  margin-right: 10px;
}

.control-row input[type="range"] {
  flex: 1;
  min-width: 150px;
  margin: 0 10px;
}

/* 阀门控制面板新增样式 */
.position-control {
  margin-bottom: 15px;
}

/* 加载指示器样式 */
.loading-overlay {
  position: fixed;
  inset: 0;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgb(255 255 255 / 80%);
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f0f0f0;
  border-top: 5px solid #1890ff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  margin-top: 15px;
  font-size: 16px;
  color: #1890ff;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 错误提示样式 */
.error-message {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 2000;
  padding: 15px 20px;
  color: white;
  background-color: #f56c6c;
  border-radius: 4px;
  box-shadow: 0 4px 12px rgb(0 0 0 / 15%);
}

.close-error-btn {
  margin-left: 10px;
  font-size: 18px;
  color: white;
  cursor: pointer;
  background: none;
  border: none;
}

/* 设备控制面板标题 */
.device-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
}

.device-title {
  font-size: 18px;
  font-weight: bold;
  color: #1890ff;
}

/* 启用/禁用按钮样式 */
button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.active-btn {
  color: white;
  background-color: #67c23a;
}

/* 添加反应路径选择 */
.path-selector {
  position: fixed;
  top: 100px;
  left: 200px;
  z-index: 1000;
  padding: 10px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgb(0 0 0 / 10%);
}

.path-options {
  display: flex;
  flex-wrap: wrap;
  margin-top: 10px;
}

.path-option {
  padding: 8px 15px;
  margin: 5px;
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 4px;
  transition: all 0.3s;
}

.path-option:hover {
  background-color: #f0f0f0;
}

.path-option.selected {
  color: white;
  background-color: #1890ff;
  border-color: #1890ff;
}

/* WebSocket状态指示器 */
.ws-status {
  position: fixed;
  right: 20px;
  bottom: 20px;
  z-index: 1000;
  padding: 5px 10px;
  color: white;
  background-color: #f56c6c;
  border-radius: 4px;
}

.ws-status.connected {
  background-color: #67c23a;
}

/* MFC和光照控制面板样式 */
.intensity-control {
  margin-top: 15px;
}

/* 创建模式样式 */
.create-mode-sidebar {
  background-color: #f8f9fa;
  border-right: 1px solid #e0e0e0;
}

.create-mode-sidebar h3, .path-selector-sidebar h3 {
  padding: 10px 15px;
  margin-top: 0;
  margin-bottom: 15px;
  color: #1890ff;
  font-size: 18px;
  border-bottom: 1px solid #e0e0e0;
}

.create-mode-sidebar h4, .path-selector-sidebar h4 {
  padding: 0 15px;
  margin-top: 0;
  margin-bottom: 10px;
  color: #333;
  font-size: 16px;
}

.graph-container.create-mode {
  border: 2px dashed #1890ff;
  background-color: #fafafa;
}

/* 路径选择器侧边栏样式 */
.path-selector-sidebar {
  background-color: #f8f9fa;
  border-right: 1px solid #e0e0e0;
  overflow-y: auto;
}

.path-section {
  margin-bottom: 15px;
  padding: 0 15px;
}

.path-options {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* 图标说明区域样式 */
.icons-legend-section {
  margin-top: 20px;
  padding: 0 15px;
  border-top: 1px solid #eaeaea;
  padding-top: 15px;
}

.icons-legend {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 10px;
}

.legend-item {
  display: flex;
  align-items: center;
  padding: 8px;
  background-color: #f9f9f9;
  border-radius: 4px;
  transition: all 0.3s;
}

.legend-item:hover {
  background-color: #f0f0f0;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.legend-icon {
  width: 24px;
  height: 24px;
  margin-right: 10px;
  object-fit: contain;
}

.legend-item span {
  font-size: 13px;
  color: #333;
}

.path-option {
  padding: 8px 12px;
  cursor: pointer;
  background-color: #f5f5f5;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  transition: all 0.3s;
}

.path-option:hover {
  background-color: #e6f7ff;
  border-color: #91d5ff;
}

.path-option.selected {
  color: white;
  background-color: #1890ff;
  border-color: #1890ff;
}

.custom-path {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: #f0f7ff;
  border-color: #c6e2ff;
}

.custom-path:hover {
  background-color: #e0f0ff;
}

/* 保存按钮样式 */
.save-button {
  color: white;
  background-color: #52c41a;
  border-color: #52c41a;
}

.save-button:hover {
  background-color: #73d13d;
  border-color: #73d13d;
}

/* 对话框样式 */
.dialog-overlay {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.5);
}

.dialog-content {
  width: 400px;
  padding: 20px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.dialog-content h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: #1890ff;
  font-size: 18px;
}

.dialog-form {
  margin-bottom: 20px;
}

.dialog-form label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
}

.dialog-form input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
}

.dialog-buttons button {
  padding: 8px 16px;
  margin-left: 10px;
  cursor: pointer;
  background-color: #f5f5f5;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  transition: all 0.3s;
}

.dialog-buttons button:hover {
  background-color: #e6e6e6;
}

.primary-button {
  color: white;
  background-color: #1890ff !important;
  border-color: #1890ff !important;
}

.primary-button:hover {
  background-color: #40a9ff !important;
  border-color: #40a9ff !important;
}

.path-type-selector {
  margin-bottom: 20px;
  padding: 0 15px;
}

.path-section h4 {
  margin-top: 0;
  margin-bottom: 10px;
  color: #666;
  font-size: 14px;
}

/* 自定义路径选项中的删除按钮 */
.custom-path {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: #f0f7ff;
  border-color: #c6e2ff;
}

.custom-path:hover {
  background-color: #e0f0ff;
}

.delete-path-btn {
  width: 20px;
  height: 20px;
  padding: 0;
  margin-left: 8px;
  font-size: 16px;
  color: #999;
  cursor: pointer;
  background: none;
  border: none;
  border-radius: 50%;
  transition: all 0.3s;
}

.delete-path-btn:hover {
  color: #f56c6c;
  background-color: rgba(245, 108, 108, 0.1);
}

/* 确认删除对话框中的警告文本 */
.warning-text {
  color: #f56c6c;
  font-weight: bold;
}

/* 删除按钮样式 */
.danger-button {
  color: white !important;
  background-color: #f56c6c !important;
  border-color: #f56c6c !important;
}

.danger-button:hover {
  background-color: #f78989 !important;
  border-color: #f78989 !important;
}

/* WebSocket连接状态指示器样式 */
.websocket-status-container {
  position: fixed;
  top: 10px;
  left: 10px; /* 改为左上角 */
  z-index: 9000; /* 降低z-index，低于参数变更队列面板 */
  display: flex;
  align-items: center;
  padding: 8px 12px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease;
  background: #fff;
  opacity: 0.9; /* 稍微透明 */
}

.ws-connected {
  border: 1px solid #67C23A;
}

.ws-disconnected {
  border: 1px solid #F56C6C;
  background: #FEF0F0;
}

.status-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 8px;
}

.ws-connected .status-indicator {
  background-color: #67C23A;
  box-shadow: 0 0 8px #67C23A;
}

.ws-disconnected .status-indicator {
  background-color: #F56C6C;
  box-shadow: 0 0 8px #F56C6C;
  animation: pulse 1.5s infinite;
}

.status-text {
  font-size: 14px;
  font-weight: 500;
  margin-right: 8px;
}

.ws-connected .status-text {
  color: #67C23A;
}

.ws-disconnected .status-text {
  color: #F56C6C;
}

@keyframes pulse {
  0% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.2);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

.data-source-indicator {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: bold;
  margin-right: 10px;
}

.data-source-indicator.connected {
  background-color: #52c41a;
  color: #fff;
}

.data-source-indicator.disconnected {
  background-color: #f56c6c;
  color: #fff;
}

.device-selection-dialog {
  width: 600px;
  max-height: 80vh;
  overflow-y: auto;
}

.search-box {
  margin-bottom: 15px;
}

.search-box input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  font-size: 14px;
}

.device-list {
  max-height: 400px;
  overflow-y: auto;
  margin-bottom: 15px;
}

.device-group {
  margin-bottom: 15px;
}

.group-title {
  padding: 5px 10px;
  font-weight: bold;
  background-color: #f5f5f5;
  border-left: 3px solid #1890ff;
  margin-bottom: 8px;
}

.device-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  margin-bottom: 5px;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.device-item:hover {
  background-color: #f0f9ff;
  border-color: #91d5ff;
}

.no-devices {
  padding: 20px;
  text-align: center;
  color: #999;
}

/* 撤销按钮样式 */
.undo-button {
  color: white;
  background-color: #1890ff;
  border-color: #1890ff;
}

.undo-button:hover {
  background-color: #40a9ff;
  border-color: #40a9ff;
}

.undo-button:disabled {
  color: #d9d9d9;
  background-color: #f5f5f5;
  border-color: #d9d9d9;
  cursor: not-allowed;
  opacity: 0.6;
}

.operation-count {
  display: inline-block;
  padding: 0 4px;
  font-size: 12px;
  line-height: 16px;
  color: white;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  margin-left: 5px;
}

/* 设备参数输入框样式 */
.parameter-input {
  width: 60px;
  padding: 6px;
  margin: 0 8px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  text-align: center;
  transition: border-color 0.2s;
}

.parameter-input:focus {
  outline: none;
  border-color: #409eff;
}

.parameter-select {
  padding: 6px;
  margin: 0 8px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  background-color: white;
  transition: border-color 0.2s;
}

.parameter-select:focus {
  outline: none;
  border-color: #409eff;
}

.device-controls .control-row button {
  margin: 0 5px;
  padding: 6px 12px;
  color: #fff;
  background-color: #409eff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.device-controls .control-row button:hover {
  background-color: #66b1ff;
}

.reactant-input {
  width: 150px;
  padding: 6px 12px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  transition: border-color 0.2s;
}

/* 命令队列面板样式 */
.command-queue-panel {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 360px;
  max-height: 400px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  display: flex;
  flex-direction: column;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  border-bottom: 1px solid #eee;
}

.panel-title {
  font-weight: bold;
  color: #333;
}

.panel-actions {
  display: flex;
  gap: 10px;
}

.send-all-btn {
  background-color: #1890ff;
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
}

.send-all-btn:disabled {
  background-color: #b3d9ff;
  cursor: not-allowed;
}

.clear-btn {
  background-color: #ff4d4f;
  color: red;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
}

.queue-list {
  padding: 10px;
  overflow-y: auto;
  max-height: 320px;
}

.command-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  border: 1px solid #eee;
  border-radius: 4px;
  margin-bottom: 8px;
  background-color: #f9f9f9;
}

.device-info {
  display: flex;
  flex-direction: column;
}

.device-type {
  font-weight: bold;
  color: #1890ff;
}

.device-id {
  font-size: 0.8em;
  color: #999;
}

.command-info {
  display: flex;
  flex-direction: column;
  max-width: 160px;
  overflow: hidden;
}

.action {
  font-weight: 500;
}

.parameters {
  font-size: 0.8em;
  color: #666;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.remove-btn {
  background: none;
  border: none;
  color: #999;
  font-size: 16px;
  cursor: pointer;
  padding: 0 5px;
}

.remove-btn:hover {
  color: #ff4d4f;
}

/* 适配移动端的命令队列面板 */
@media screen and (max-width: 768px) {
  .command-queue-panel {
    width: 90%;
    left: 5%;
    right: 5%;
    bottom: 70px;
    max-height: 300px;
  }
  
  .queue-list {
    max-height: 200px;
  }
  
  .command-item {
    flex-wrap: wrap;
  }
  
  .command-info {
    max-width: 100%;
    margin-top: 5px;
  }
}

/* 添加参数变更队列面板 - 简洁统一版 */
.parameter-changes-panel-new {
  position: fixed;
  bottom: 100px;
  right: 20px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
  width: 400px;
  max-height: 450px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border: 1px solid #e8e8e8;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 15px;
  background: #f8fafc;
  border-bottom: 1px solid #e8e8e8;
}

.panel-title {
  font-weight: 600;
  font-size: 14px;
  color: #1890ff;
}

.panel-actions {
  display: flex;
  gap: 6px;
}

.send-all-btn {
  background: #1890ff;
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.send-all-btn:hover {
  background: #40a9ff;
}

.send-all-btn:disabled {
  background: #bae7ff;
  cursor: not-allowed;
}

.workflow-btn {
  background: #722ed1;
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.workflow-btn:hover {
  background: #9254de;
}

.workflow-btn:disabled {
  background: #d3adf7;
  cursor: not-allowed;
}

.clear-btn {
  background: #f5f5f5;
  color: #595959;
  border: 1px solid #d9d9d9;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.clear-btn:hover {
  background: #fafafa;
  border-color: #40a9ff;
}

.close-panel-btn {
  background: #f5f5f5;
  color: #595959;
  border: 1px solid #d9d9d9;
  width: 22px;
  height: 22px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  cursor: pointer;
  margin-left: 6px;
}

.close-panel-btn:hover {
  color: #ff4d4f;
  border-color: #ff4d4f;
}

.changes-list {
  overflow-y: auto;
  padding: 0;
  flex: 1;
}

.change-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  border-bottom: 1px solid #f0f0f0;
}

.change-item:hover {
  background-color: #fafafa;
}

.change-item:last-child {
  border-bottom: none;
}

.device-info {
  font-weight: 500;
  flex: 0 0 30%;
}

.device-type {
  color: #1890ff;
  font-size: 13px;
}

.device-id {
  font-size: 12px;
  color: #666;
}

.changes-info {
  display: flex;
  flex-direction: column;
  flex: 1;
  padding: 0 10px;
}

.parameter {
  font-size: 12px;
  color: #333;
  margin: 2px 0;
}

.remove-btn {
  background: none;
  border: none;
  color: #d9d9d9;
  font-size: 16px;
  cursor: pointer;
  padding: 0 5px;
}

.remove-btn:hover {
  color: #ff4d4f;
}

/* 发送参数按钮 */
.send-params-button {
  background-color: #1890ff;
  color: white;
  transition: all 0.3s;
}

.send-params-button:hover {
  background-color: #40a9ff;
}

/* 调试按钮样式 */
.debug-btn {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  padding: 10px 15px;
  color: white;
  background-color: #1890ff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.debug-btn:hover {
  background-color: #40a9ff;
}

.badge {
  background-color: #ff4d4f;
  color: white;
  border-radius: 10px;
  padding: 2px 6px;
  font-size: 12px;
  margin-left: 5px;
}

/* 强制显示的测试面板 */
.force-display-panel {
  position: fixed;
  top: 100px;
  right: 20px;
  width: 300px;
  background-color: white;
  border: 3px solid #ff4d4f;
  border-radius: 8px;
  padding: 15px;
  z-index: 10000;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

.force-display-panel h3 {
  color: #ff4d4f;
  margin-top: 0;
}

.no-changes {
  padding: 20px 15px;
  text-align: center;
  color: #8c8c8c;
  font-style: italic;
  font-size: 13px;
}

.parameter {
  margin: 3px 0;
  padding: 2px 0;
}

.hardware-control-container {
  margin: 15px 0;
}

.hardware-control-card {
  margin-bottom: 15px;
}

.hardware-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.hardware-card-content {
  padding: 10px 0;
}

.hardware-error-message {
  margin-top: 10px;
}

.data-source-indicator {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.data-source-indicator.connected {
  color: #67c23a;
  background-color: #f0f9eb;
}

.data-source-indicator.disconnected {
  color: #f56c6c;
  background-color: #fef0f0;
}


/* 流程编辑器头部 */
.workflow-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 15px;
  border-bottom: 1px solid #f0f0f0;
  margin-bottom: 20px;
}

.workflow-editor-header h3 {
  font-size: 18px;
  color: #722ed1;
  margin: 0;
}

.workflow-actions {
  display: flex;
  gap: 10px;
}

.workflow-action-btn {
  padding: 8px 15px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  background-color: #fff;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s;
}

.workflow-action-btn:hover {
  color: #722ed1;
  border-color: #722ed1;
}

.workflow-action-btn.save-btn {
  color: #fff;
  background-color: #52c41a;
  border-color: #52c41a;
}

.workflow-action-btn.save-btn:hover {
  background-color: #73d13d;
  border-color: #73d13d;
}

.workflow-action-btn.run-btn {
  color: #fff;
  background-color: #1890ff;
  border-color: #1890ff;
}

.workflow-action-btn.run-btn:hover {
  background-color: #40a9ff;
  border-color: #40a9ff;
}

.workflow-action-btn:disabled {
  color: #d9d9d9;
  background-color: #f5f5f5;
  border-color: #d9d9d9;
  cursor: not-allowed;
}

/* 流程编辑器内容 */
.workflow-editor-content {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* 流程基本信息 */
.workflow-info {
  flex: 0 0 300px;
  padding: 15px;
  border-right: 1px solid #f0f0f0;
  overflow-y: auto;
}
.form-item {
  margin-bottom: 15px;
}

.form-item label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
  color: #333;
}

.form-item input, .form-item textarea, .form-item select {
  width: 100%;
  padding: 8px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  transition: all 0.3s;
}

.form-item textarea {
  min-height: 80px;
  resize: vertical;
}

.form-item input:focus, .form-item textarea:focus, .form-item select:focus {
  border-color: #722ed1;
  outline: none;
  box-shadow: 0 0 0 2px rgba(114, 46, 209, 0.2);
}

/* 流程步骤 */
.workflow-steps {
  flex: 1;
  padding: 15px;
  overflow-y: auto;
}

.workflow-steps h4 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #333;
}

.add-step-btn {
  padding: 4px 10px;
  background-color: #722ed1;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.3s;
}

.add-step-btn:hover {
  background-color: #9254de;
}

.no-steps {
  padding: 30px;
  text-align: center;
  color: #999;
  background-color: #f9f9f9;
  border-radius: 4px;
}

.steps-container {
  margin-top: 20px;
}

.step-item {
  margin-bottom: 15px;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  transition: all 0.3s;
}

.step-item:hover {
  border-color: #d3adf7;
}

.step-item.active-step {
  border-color: #722ed1;
  box-shadow: 0 0 0 2px rgba(114, 46, 209, 0.1);
}

.step-header {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  background-color: #f9f9f9;
  border-bottom: 1px solid #e8e8e8;
  cursor: pointer;
  transition: all 0.3s;
}

.active-step .step-header {
  background-color: #f0e6fd;
  border-color: #d3adf7;
}

.step-number {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #722ed1;
  color: white;
  border-radius: 50%;
  margin-right: 10px;
  font-size: 12px;
  font-weight: bold;
}

.step-title {
  flex: 1;
  font-weight: 500;
}

.step-actions {
  display: flex;
  gap: 5px;
}

.step-btn {
  width: 24px;
  height: 24px;
  background: none;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s;
}

.step-btn:hover {
  color: #722ed1;
  border-color: #722ed1;
}

.step-btn.delete:hover {
  color: #f5222d;
  border-color: #f5222d;
}

.step-btn:disabled {
  color: #d9d9d9;
  cursor: not-allowed;
}

.step-details {
  padding: 15px;
  background-color: #fafafa;
}

/* 设备命令和条件样式 */
.device-commands, .step-conditions {
  margin-top: 20px;
  border-top: 1px dashed #e8e8e8;
  padding-top: 15px;
}

.device-commands h5, .step-conditions h5 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 14px;
  color: #333;
}

.add-command-btn, .add-condition-btn {
  padding: 3px 8px;
  background-color: #13c2c2;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.3s;
}

.add-command-btn:hover, .add-condition-btn:hover {
  background-color: #36cfc9;
}

.no-commands, .no-conditions {
  padding: 15px;
  text-align: center;
  color: #999;
  background-color: #f9f9f9;
  border-radius: 4px;
  font-size: 13px;
}

.command-item, .condition-item {
  margin-bottom: 15px;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  overflow: hidden;
}

.command-header, .condition-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background-color: #e6fffb;
  border-bottom: 1px solid #b5f5ec;
}

.condition-header {
  background-color: #fcf4dc;
  border-bottom: 1px solid #ffe58f;
}

.command-title, .condition-title {
  font-weight: 500;
  font-size: 13px;
  color: #08979c;
}

.condition-title {
  color: #d4b106;
}

.cmd-btn, .cond-btn {
  width: 20px;
  height: 20px;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  color: #999;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cmd-btn.delete:hover, .cond-btn.delete:hover {
  color: #f5222d;
}

.command-form, .condition-form {
  padding: 12px;
  background-color: #fcfcfc;
}

.form-row {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.form-row label {
  width: 80px;
  flex-shrink: 0;
  font-size: 13px;
  color: #666;
}

.form-row select, .form-row input {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  transition: all 0.3s;
}

.form-row select:focus, .form-row input:focus {
  border-color: #722ed1;
  outline: none;
  box-shadow: 0 0 0 2px rgba(114, 46, 209, 0.1);
}

/* 流程执行面板 */
.workflow-execution-panel {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 400px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1001;
  overflow: hidden;
}

.execution-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 15px;
  background-color: #722ed1;
  color: white;
}

.execution-header h3 {
  margin: 0;
  font-size: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 250px;
}

.execution-controls {
  display: flex;
  gap: 8px;
}

.execution-control-btn {
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 4px;
  background-color: rgba(255, 255, 255, 0.2);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s;
}

.execution-control-btn.pause::before {
  content: "⏸";
}

.execution-control-btn.resume::before {
  content: "▶";
}

.execution-control-btn.stop::before {
  content: "⏹";
}

.execution-control-btn:hover {
  background-color: rgba(255, 255, 255, 0.3);
}

.execution-progress {
  padding: 15px;
  border-bottom: 1px solid #f0f0f0;
}

.progress-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  color: #666;
  font-size: 13px;
}

.execution-steps {
  max-height: 300px;
  overflow-y: auto;
  padding: 0 15px 15px;
}

.execution-step {
  display: flex;
  padding: 10px 0;
  border-bottom: 1px solid #f0f0f0;
}

.execution-step:last-child {
  border-bottom: none;
}

.step-indicator {
  margin-right: 12px;
  position: relative;
}

.step-indicator::after {
  content: "";
  position: absolute;
  top: 30px;
  left: 12px;
  bottom: -10px;
  width: 1px;
  background-color: #e8e8e8;
}

.execution-step:last-child .step-indicator::after {
  display: none;
}

.step-number {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  font-size: 12px;
  margin-bottom: 8px;
}

.completed-step .step-number {
  background-color: #52c41a;
  color: white;
}

.active-step .step-number {
  background-color: #1890ff;
  color: white;
}

.pending-step .step-number {
  background-color: #f5f5f5;
  color: #999;
}

.step-status-icon {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.step-content {
  flex: 1;
}

.step-name {
  font-weight: 500;
  margin-bottom: 5px;
}

.completed-step .step-name {
  color: #52c41a;
}

.active-step .step-name {
  color: #1890ff;
}

.pending-step .step-name {
  color: #999;
}

.step-description {
  font-size: 12px;
  color: #999;
}

/* 流程列表对话框 */
.workflow-list {
  max-height: 500px;
  overflow-y: auto;
}

.workflow-item {
  padding: 15px;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}

.workflow-item:hover {
  border-color: #722ed1;
  background-color: #f9f0ff;
}

.workflow-name {
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 5px;
  color: #333;
}

.path-info {
  font-size: 13px;
  color: #666;
}

.path-actions {
  padding: 12px 15px;
  display: flex;
  flex-direction: column;
  border-top: 1px solid #f0f0f0;
}

.path-action-instructions {
  margin-bottom: 12px;
  padding: 10px;
  background-color: #f0f9ff;
  border-radius: 4px;
  border-left: 3px solid #1890ff;
}

.instruction-step {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.instruction-step:last-child {
  margin-bottom: 0;
}

.step-icon {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: #1890ff;
  color: white;
  font-weight: bold;
  margin-right: 8px;
  flex-shrink: 0;
}

.step-text {
  font-size: 13px;
  color: #333;
}

.clear-path-btn {
  background-color: #ff4d4f;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
  align-self: flex-end;
}

.clear-path-btn:hover {
  background-color: #ff7875;
  box-shadow: 0 2px 6px rgba(255, 77, 79, 0.2);
}

.no-paths {
  padding: 20px;
  text-align: center;
  color: #999;
  font-style: italic;
}

/* 反应路径加载状态 */
.loading-paths {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 30px 20px;
  color: #722ed1;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(114, 46, 209, 0.2);
  border-radius: 50%;
  border-top-color: #722ed1;
  animation: spin 1s ease-in-out infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-text {
  font-size: 14px;
  color: #722ed1;
}

/* 反应路径错误信息 */
.path-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  text-align: center;
}

.error-icon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: #ff4d4f;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 15px;
}

.error-text {
  color: #ff4d4f;
  margin-bottom: 15px;
  font-size: 14px;
}

.retry-btn {
  background-color: #ff4d4f;
  color: white;
  border: none;
  padding: 6px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.retry-btn:hover {
  background-color: #ff7875;
  box-shadow: 0 2px 6px rgba(255, 77, 79, 0.2);
}

/* 反应路径按钮样式 */
.reaction-path-button {
  position: relative;
  background-color: #722ed1;
  color: white;
  border-color: #722ed1;
}

.reaction-path-button::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.3), rgba(255,255,255,0.1));
  background-size: 300% 100%;
  border-radius: 4px;
  z-index: 1;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  animation: shimmer 2s infinite;
}

.reaction-path-button.active::after {
  opacity: 1;
}

@keyframes shimmer {
  0% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* 路径节点高亮动画 */
@keyframes pathNodePulse {
  0% {
    box-shadow: 0 0 0 0 rgba(114, 46, 209, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(114, 46, 209, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(114, 46, 209, 0);
  }
}

.workflow-from-path {
  margin: 15px 0;
}

.generate-btn {
  background-color: #67c23a;
  color: white;
}

.generate-btn:hover {
  background-color: #85ce61;
}

.standard-workflow-params {
  max-height: 60vh;
  overflow-y: auto;
  padding: 0 10px;
}

.param-section {
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #ebeef5;
  border-radius: 4px;
}

.param-item {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  gap: 10px;
}

.param-item span {
  min-width: 70px;
}

/* 添加到style标签内 */
.device-param-container {
  margin-bottom: 20px;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  padding: 15px;
  background-color: #f9fafc;
}

.device-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.device-header h4 {
  margin: 0;
  color: #409eff;
  font-size: 16px;
}

.workflow-steps-preview {
  margin-top: 20px;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  padding: 10px;
  background-color: #f9fafc;
}

.step-preview-item {
  display: flex;
  padding: 12px;
  margin-bottom: 10px;
  border-radius: 4px;
  background-color: white;
  box-shadow: 0 2px 12px 0 rgba(0,0,0,.05);
}

.step-number {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background-color: #409eff;
  color: white;
  font-weight: bold;
  margin-right: 15px;
  flex-shrink: 0;
}

.step-content {
  flex: 1;
}

.step-title {
  font-weight: bold;
  color: #333;
  margin-bottom: 5px;
}

.step-desc {
  color: #666;
  font-size: 13px;
}

/* 工作流预览对话框样式 */
.workflow-preview-content {
  max-height: 70vh;
  overflow-y: auto;
}

.workflow-preview-header {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #ebeef5;
}

.workflow-preview-header h3 {
  margin: 0 0 10px 0;
  color: #722ed1;
  font-size: 20px;
}

.workflow-preview-desc {
  margin: 0 0 10px 0;
  color: #666;
  font-size: 14px;
}

.workflow-preview-meta {
  display: flex;
  gap: 15px;
  color: #999;
  font-size: 12px;
}

.workflow-preview-steps {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.workflow-preview-step {
  border: 1px solid #ebeef5;
  border-radius: 8px;
  overflow: hidden;
}

.preview-step-header {
  display: flex;
  align-items: center;
  padding: 12px 15px;
  background-color: #f9f0ff;
  border-bottom: 1px solid #ebeef5;
}

.preview-step-number {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background-color: #722ed1;
  color: white;
  font-weight: bold;
  margin-right: 10px;
}

.preview-step-name {
  font-weight: bold;
  color: #333;
  font-size: 16px;
}

.preview-step-content {
  padding: 15px;
}

.preview-step-desc {
  margin-bottom: 15px;
  padding: 8px 12px;
  background-color: #f9f9f9;
  border-radius: 4px;
  color: #666;
}

.preview-commands-list {
  margin-bottom: 15px;
}

.preview-commands-list h4 {
  margin: 0 0 10px 0;
  font-size: 14px;
  color: #333;
}

.preview-commands-scroll {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #ebeef5;
  border-radius: 4px;
}

.preview-command-item {
  display: flex;
  padding: 10px;
  border-bottom: 1px solid #ebeef5;
}

.preview-command-item:last-child {
  border-bottom: none;
}

.preview-command-device {
  flex: 0 0 120px;
  display: flex;
  flex-direction: column;
}

.preview-device-type {
  font-weight: bold;
  color: #1890ff;
  margin-bottom: 3px;
}

.preview-device-id {
  font-size: 12px;
  color: #999;
}

.preview-command-action {
  flex: 1;
  font-weight: 500;
}

.preview-command-params {
  margin-top: 5px;
  font-size: 12px;
  color: #666;
}

.preview-param {
  margin-bottom: 3px;
}

.param-value {
  font-weight: bold;
  color: #333;
}


.preview-step-conditions {
  margin-bottom: 15px;
}

.preview-condition-item {
  margin-bottom: 10px;
  padding: 10px;
  background-color: #fffbe6;
  border: 1px solid #ffe58f;
  border-radius: 4px;
}

.condition-type {
  font-weight: bold;
  color: #d48806;
  margin-bottom: 5px;
}

.condition-details {
  color: #666;
  font-size: 13px;
}

.preview-step-delay {
  display: flex;
  align-items: center;
  padding: 10px;
  background-color: #f6ffed;
  border: 1px solid #b7eb8f;
  border-radius: 4px;
}

.delay-icon {
  margin-right: 8px;
  font-size: 16px;
}

.delay-text {
  color: #52c41a;
  font-weight: 500;
}

/* 切换开关样式 */
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 30px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-switch label {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
  padding: 5px 10px;
  text-align: center;
  color: white;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toggle-switch input:checked + label {
  background-color: #1890ff;
}

.toggle-switch label:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

.toggle-switch input:checked + label:before {
  transform: translateX(30px);
}

.toggle-switch input:focus + label {
  box-shadow: 0 0 1px #1890ff;
}

.valve-info {
  margin-left: 10px;
  color: #1890ff;
  font-size: 12px;
  font-style: italic;
}

/* 编辑模式样式 */
.edit-mode-indicator {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #e6f7ff;
  border: 1px solid #91d5ff;
  border-radius: 4px;
  padding: 8px 15px;
  margin-bottom: 10px;
  width: 100%;
}

.edit-mode-indicator span {
  font-weight: bold;
  color: #1890ff;
}

.edit-mode-actions {
  display: flex;
  gap: 10px;
}

.edit-mode-actions .tool-button.save-button {
  background-color: #52c41a;
  color: white;
}

.edit-mode-actions .tool-button.cancel-button {
  background-color: #f5f5f5;
  color: rgba(0, 0, 0, 0.65);
}
.edit-mode-indicator {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: #ecf5ff;
  border: 1px solid #d9ecff;
  border-radius: 4px;
  padding: 8px 12px;
  margin-bottom: 10px;
}

.edit-mode-actions {
  display: flex;
  gap: 8px;
}

.save-button {
  background-color: #67c23a;
  color: white;
}

.save-button:hover {
  background-color: #85ce61;
}

.cancel-button {
  background-color: #909399;
  color: white;
}

.cancel-button:hover {
  background-color: #a6a9ad;
}
</style>
      