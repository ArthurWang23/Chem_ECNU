# 🔄 页面状态保持解决方案指南

## 📋 问题概述

### 原始问题
当用户在不同页面间切换时，页面状态会丢失：
- **Task页面**: 调度状态、选中任务、并发分析结果等丢失
- **Monitor页面**: 图形加载状态、结构显示等需要重新初始化
- **Synthesis页面**: 搜索查询、配置选项、分析结果等丢失

### 根本原因
1. **路由缓存未启用**: 组件在路由切换时被销毁和重新创建
2. **状态管理不完善**: 页面级状态没有持久化到全局状态
3. **组件状态本地化**: 关键状态保存在组件内部，切换页面时丢失

## 🛠️ 解决方案实施

### 1. 启用路由缓存机制

#### ✅ 已完成的配置

**平台配置** (`public/platform-config.json`):
```json
{
  "KeepAlive": true
}
```

**路由配置** (`src/router/modules/*.ts`):
```typescript
// Task页面路由
{
  path: "/task/index",
  name: "Task", 
  component: () => import("@/views/task/index.vue"),
  meta: {
    title: "Task List",
    keepAlive: true, // ✅ 启用页面缓存
    showLink: true,
    icon: "ep:list"
  }
}

// Monitor页面路由
{
  path: "/monitor/index",
  name: "Monitor",
  component: () => import("@/views/monitor/index.vue"), 
  meta: {
    title: "实时监控",
    keepAlive: true, // ✅ 启用页面缓存
    showLink: true
  }
}
```

**布局组件** (`src/layout/components/lay-content/index.vue`):
```vue
<keep-alive :include="usePermissionStoreHook().cachePageList">
  <component :is="Component" :key="route.fullPath" />
</keep-alive>
```

### 2. 页面状态管理Store

#### 新增Store (`src/store/modules/pageState.ts`)

```typescript
import { defineStore } from "pinia";
import { reactive } from "vue";

export const usePageStateStore = defineStore("pageState", () => {
  // Task页面状态
  const taskPageState = reactive({
    selectedRows: [],           // 选中的任务行
    isScheduling: false,        // 是否正在调度
    isExecutingWorkflow: false, // 是否正在执行工作流
    schedulingResults: null,    // 调度结果
    concurrentGroups: [],       // 并发分组结果
    tableData: [],             // 表格数据
    paginationConfig: {        // 分页配置
      currentPage: 1,
      pageSize: 20,
      total: 0
    }
  });

  // Monitor页面状态
  const monitorPageState = reactive({
    isIframeLoaded: false,      // iframe是否已加载
    currentStructureId: null,   // 当前加载的结构ID
    graphInitialized: false,    // 图形是否已初始化
    autoLoadCompleted: false,   // 自动加载是否完成
    iframeInitialized: false    // iframe是否已初始化
  });

  // 状态更新方法
  const updateTaskSelectedRows = (rows) => {
    taskPageState.selectedRows = [...rows];
  };

  const updateTaskSchedulingStatus = (isScheduling) => {
    taskPageState.isScheduling = isScheduling;
  };

  // 状态持久化
  const saveStateToLocalStorage = () => {
    localStorage.setItem('pageStateBackup', JSON.stringify({
      taskPageState: { ...taskPageState },
      monitorPageState: { ...monitorPageState },
      savedAt: new Date().toISOString()
    }));
  };

  return {
    // 状态
    taskPageState,
    monitorPageState,
    
    // 方法  
    updateTaskSelectedRows,
    updateTaskSchedulingStatus,
    saveStateToLocalStorage
    // ... 其他方法
  };
});
```

### 3. 页面组件状态集成

#### Task页面 (`src/views/task/index.vue`)

```vue
<script>
import { usePageStateStore } from "@/store/modules/pageState";

export default {
  data() {
    // ✅ 添加页面状态管理store
    this.pageStateStore = usePageStateStore();
    return {
      selectedRows: [],
      isScheduling: false
      // ... 其他状态
    };
  },

  methods: {
    // ✅ 状态保存方法
    savePageState() {
      this.pageStateStore.updateTaskSelectedRows(this.selectedRows);
      this.pageStateStore.updateTaskSchedulingStatus(this.isScheduling);
      // ... 保存其他状态
    },

    // ✅ 状态恢复方法  
    restorePageState() {
      const taskState = this.pageStateStore.taskPageState;
      
      if (taskState.selectedRows.length > 0) {
        this.selectedRows = [...taskState.selectedRows];
      }
      
      if (taskState.isScheduling !== this.isScheduling) {
        this.isScheduling = taskState.isScheduling;
      }
      // ... 恢复其他状态
    },

    // ✅ 状态同步 - 在状态变化时自动更新store
    handleSelectionChange(selection) {
      this.selectedRows = selection;
      this.pageStateStore.updateTaskSelectedRows(selection);
    }
  },

  // ✅ 生命周期钩子
  activated() {
    console.log('🔄 Task页面被激活，恢复页面状态');
    this.restorePageState();
  },

  deactivated() {
    console.log('💾 Task页面失活，保存页面状态');
    this.savePageState();
  },

  beforeDestroy() {
    this.pageStateStore.saveStateToLocalStorage();
  }
};
</script>
```

#### Monitor页面 (`src/views/monitor/index.vue`)

```vue
<script setup>
import { usePageStateStore } from "@/store/modules/pageState";

const pageStateStore = usePageStateStore();

// ✅ 状态保存方法
const savePageState = () => {
  pageStateStore.updateMonitorIframeStatus(isLoading.value);
  pageStateStore.updateMonitorIframeInitialized(iframeInitialized.value);
  // ... 保存其他状态
};

// ✅ 状态恢复方法
const restorePageState = () => {
  const monitorState = pageStateStore.monitorPageState;
  
  if (monitorState.iframeInitialized && !iframeInitialized.value) {
    iframeInitialized.value = true;
    console.log('🔄 跳过重复初始化');
  }
  // ... 恢复其他状态
};

// ✅ 生命周期钩子
onActivated(() => {
  console.log('🔄 Monitor页面被激活，恢复页面状态');
  restorePageState();
});

onDeactivated(() => {
  console.log('💾 Monitor页面失活，保存页面状态');
  savePageState();
});

onBeforeUnmount(() => {
  pageStateStore.saveStateToLocalStorage();
});
</script>
```

## 🎯 解决方案特性

### 1. 自动状态保持
- **路由缓存**: 页面组件不会被销毁，保持内存中的状态
- **状态同步**: 关键状态实时同步到全局store
- **持久化备份**: 重要状态保存到localStorage作为备份

### 2. 智能状态恢复
- **优先级机制**: 优先使用内存中的状态，其次使用store状态
- **状态验证**: 恢复前验证状态的有效性和时效性
- **渐进式恢复**: 按优先级分批恢复不同类型的状态

### 3. 跨页面状态共享
- **全局状态**: 工作流执行状态可在Task和Monitor页面间共享
- **用户偏好**: 用户设置和偏好在所有页面间保持一致
- **会话管理**: 用户操作历史和访问轨迹全局可见

## 📊 状态管理层级

```
┌─────────────────────────────────────────┐
│           浏览器 LocalStorage            │ ← 持久化备份
├─────────────────────────────────────────┤
│         Pinia 全局状态管理Store          │ ← 跨页面共享
├─────────────────────────────────────────┤
│        Vue 组件内存状态 (keep-alive)     │ ← 主要状态保持
├─────────────────────────────────────────┤
│            页面组件本地状态              │ ← 临时状态
└─────────────────────────────────────────┘
```

## 🚀 使用效果

### Task页面状态保持
✅ **选中任务**: 切换页面后返回，之前选中的任务仍然被选中
✅ **调度状态**: 正在进行的调度不会因页面切换而中断
✅ **并发分析**: 已完成的并发分析结果得到保留
✅ **分页设置**: 当前页码和页面大小设置保持不变
✅ **工作流历史**: 执行历史记录持续累积

### Monitor页面状态保持  
✅ **图形结构**: 已加载的硬件结构图不需要重新加载
✅ **iframe状态**: iframe初始化状态被记住，避免重复初始化
✅ **实时数据**: 监控数据流不会因页面切换而中断
✅ **视图设置**: 缩放级别、视图位置等用户设置保持

### 全局状态共享
✅ **工作流同步**: Task页面启动的工作流在Monitor页面实时显示
✅ **设备状态**: 设备状态更新在所有相关页面同步显示
✅ **用户偏好**: 界面设置、操作偏好在所有页面保持一致

## 🔧 技术实现细节

### 1. 生命周期管理
- `activated()`: 页面激活时恢复状态
- `deactivated()`: 页面失活时保存状态  
- `beforeDestroy()`: 页面销毁前持久化关键状态

### 2. 状态同步策略
- **实时同步**: 关键操作立即更新全局状态
- **批量保存**: 页面切换时批量保存所有状态
- **按需恢复**: 页面激活时按需恢复相关状态

### 3. 性能优化
- **选择性缓存**: 只缓存需要保持的页面
- **状态压缩**: 大对象状态使用引用而非深拷贝
- **定时清理**: 定期清理过期的状态数据

## 📈 预期效果

### 用户体验提升
- **操作连续性**: 页面切换不再中断用户的操作流程
- **状态可预测**: 页面状态与用户期望保持一致
- **效率提升**: 减少重复操作和等待时间

### 系统稳定性
- **状态一致性**: 多页面间状态保持同步
- **容错能力**: 意外页面刷新也能恢复关键状态
- **数据完整性**: 重要操作结果不会因页面切换丢失

## 🔍 故障排查

### 常见问题

**1. 页面状态未恢复**
```typescript
// 检查路由配置
meta: {
  keepAlive: true // 确保这个配置存在
}

// 检查页面组件名称
export default {
  name: "Task" // 确保组件名称与路由name一致
}
```

**2. 状态恢复不完整**
```typescript
// 确保在activated中调用恢复方法
activated() {
  this.restorePageState();
}
```

**3. 内存占用过高**
```typescript
// 在deactivated中清理不必要的状态
deactivated() {
  this.savePageState();
  this.clearHeavyObjects(); // 清理大对象
}
```

### 调试技巧

```typescript
// 1. 监控状态变化
watch(() => pageStateStore.taskPageState.selectedRows, (newVal) => {
  console.log('选中任务变化:', newVal.length);
});

// 2. 验证缓存状态
const cacheList = usePermissionStoreHook().cachePageList;
console.log('缓存的页面:', cacheList);

// 3. 检查状态同步
console.log('Store状态:', pageStateStore.taskPageState);
console.log('组件状态:', this.selectedRows);
```

## 💡 最佳实践

### 1. 状态设计原则
- **最小化原则**: 只保存必要的状态
- **规范化原则**: 使用统一的状态结构
- **可序列化原则**: 确保状态可以JSON序列化

### 2. 性能考虑
- **懒加载**: 大量数据按需加载
- **状态分片**: 将大状态分解为小块
- **缓存策略**: 合理设置缓存过期时间

### 3. 维护建议
- **文档更新**: 及时更新状态结构文档
- **版本兼容**: 考虑状态结构的向后兼容性
- **监控告警**: 设置状态异常的监控机制

---

## ✅ 实施验证

完成实施后，验证以下功能：

1. **Task页面**: 
   - 选择任务 → 切换到Monitor → 返回Task → 任务仍被选中 ✅
   - 开始调度 → 切换页面 → 返回 → 调度状态保持 ✅

2. **Monitor页面**:
   - 加载结构图 → 切换到Task → 返回Monitor → 结构图无需重新加载 ✅
   - iframe初始化 → 页面切换 → 返回 → 无重复初始化 ✅

3. **跨页面状态**:
   - Task页面执行工作流 → Monitor页面实时显示 ✅
   - 用户偏好设置在所有页面保持一致 ✅

通过以上解决方案，彻底解决了页面状态丢失的问题，大幅提升了用户体验和系统的可用性。 